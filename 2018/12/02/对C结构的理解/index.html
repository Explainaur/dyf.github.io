<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <link rel="stylesheet" href="/style/style.css">
<script>
  var nlviconfig = {
    title: "dyf",
    author: "dyf",
    baseUrl: "/",
    theme: {
      scheme: "banderole",
      lightbox: true,
      animate: true,
      search: true,
      friends: false,
      reward: false,
      lazy: false
    }
  }
</script>




    <link rel="stylesheet" href="/script/lib/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">











<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="dyf">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name="format-detection" content="telephone=no">
<meta name="keywords" content="nlvi, Nlvi">





  <meta name="keywords" content="thinking, Nlvi">

  <title> 对C结构的理解 · dyf </title>
</head>
<body>
  <div class="progress">
  <div class="progress-inner"></div>
</div>

  
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
  <div class="tagcloud-inner">
    <a href="/tags/solo/" style="font-size: 14px;">solo</a> <a href="/tags/thinking/" style="font-size: 14px;">thinking</a> <a href="/tags/tutorial/" style="font-size: 14px;">tutorial</a>
  </div>
</div>
  

  <div class="container" style="display:none;">

    <header class="header" id="header">
  <div class="header-wrapper">
    <div class="logo">
  <div class="logo-inner syuanpi tvIn">
    <span><a href="/">dyf</a></span>
    
  </div>
</div>
    <nav class="main-nav">
  
  <ul class="main-nav-list syuanpi tvIn">
  
    <li class="menu-item">
      <a href="javascript:;" id="search">
        <span>Search</span>
        
          <span class="menu-item-label">search</span>
        
      </a>
    </li>
  
  
    
      
    
    <li class="menu-item">
      <a href="/" id="article">
        <span class="base-name">Articles</span>
        
          <span class="menu-item-label">article</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="/archives" id="archives">
        <span class="base-name">Archives</span>
        
          <span class="menu-item-label">archives</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="javascript:;" id="tags">
        <span class="base-name">Tags</span>
        
          <span class="menu-item-label">tags</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="/about" id="about">
        <span class="base-name">About</span>
        
          <span class="menu-item-label">about</span>
        
      </a>
    </li>
  
  </ul>
  
</nav>

    
    
  </div>
</header>
<div class="mobile-header">
  <div class="mobile-header-body">
    <div class="mobile-header-list">
      
        
            <div class="mobile-nav-item">
                <a href="/">
                    <span>Articles</span>
                    
                    
                </a>
            </div>
        
      
        
            <div class="mobile-nav-item">
                <a href="/archives">
                    <span>Archives</span>
                    
                    
                </a>
            </div>
        
      
        
          <div class="mobile-nav-item inner-cloud">
            <div class="mobile-nav-tag">
              <a href="javascript:;" id="mobile-tags">
                <span>Tags</span>
                
                
              </a>
            </div>
            <div class="mobile-nav-tagcloud">
              <div class="mobile-tagcloud-inner">
                <a href="/tags/solo/" style="font-size: 14px;">solo</a> <a href="/tags/thinking/" style="font-size: 14px;">thinking</a> <a href="/tags/tutorial/" style="font-size: 14px;">tutorial</a>
              </div>
            </div>
          </div>
        
      
        
            <div class="mobile-nav-item">
                <a href="/about">
                    <span>About</span>
                    
                    
                </a>
            </div>
        
      
    </div>
  </div>
  <div class="mobile-header-nav">
    <div class="mobile-header-item" id="mobile-left">
      <div class="header-menu-item">
        <span class="header-menu-line"></span>
      </div>
    </div>
    <h1 class="mobile-header-title">
      <a href="/">dyf</a>
    </h1>
    <div class="mobile-header-item"></div>
  </div>
</div>
    <div class="container-inner">

    <h1 style="
    text-align:center;
    font-family:cathsgbr;
    color: #FC5185;
    font-weight:500;
    font-size:30px;
    ">The dyf's blog</h1>

      <main class="main" id="main">
        <div class="main-wrapper">
          
    
  


  <article class="
  post
   is_post 
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2018-12-02</span>
          
            
              <span class="post-category"><a href="/categories/C/">C</a></span>
            
          
          
            
              <aside class="post-tags syuanpi fadeInUpShort back-3">
              
                <a href="/tags/thinking/">thinking</a>
              
              </aside>
            
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          对C结构的理解
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        <h3 id="记录一下学习C结构的想法"><a href="#记录一下学习C结构的想法" class="headerlink" title="记录一下学习C结构的想法"></a>记录一下学习C结构的想法</h3><hr>
<p> 我认为结构这种数据类型为C++奠定了面向对象的基础。这是一种很自由的数据类型，我们甚至可以用指针和结构实现面向对象。  </p>
<ul>
<li><p><strong>关于结构的声明</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span>  </span><br><span class="line">  　type1 a;</span><br><span class="line">  　type2 b;　　</span><br><span class="line">&#125;;       <span class="comment">//注意这里的分号</span></span><br></pre></td></tr></table></figure>
<p>这里的声明并未创建一个实际的数据对象，而是描述了这类对象的元素形式，我们也可以将结构声明称之为模板，因为他勾勒出数据将如何存储。<br>之后我们声明name结构的变量：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">dyf</span>;</span></span><br></pre></td></tr></table></figure>
<p>当编译器读到这条指令时，它将以name模板为dyf分配内存空间，即使未初始化，该结构的大小也由type1 与 type2 的大小决定。这就意味着结构的大小可能会大于数据集本身，因为系统对数据的对齐要求会导致存储裂缝。<br>再者，我们可以如下声明：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>  </span><br><span class="line">　　type1 a;  </span><br><span class="line">　　type2 b;　　  </span><br><span class="line">&#125; dyf;</span><br></pre></td></tr></table></figure>
<h2 id="即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。"><a href="#即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。" class="headerlink" title="即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。  "></a>即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。  </h2></li>
</ul>
<ul>
<li><strong>关于结构的初始化</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span>  </span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">int</span>  weight[<span class="number">20</span>];</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">math</span>&#123;</span></span><br><span class="line">  <span class="string">"高等数学"</span>，</span><br><span class="line">  <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>非指定初始化应当保持初始化项目与结构成员类型一一对应。<br>而指定初始化则类似于数组：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">dyf</span>&#123;</span></span><br><span class="line">  .name=<span class="string">"高等数学"</span>,</span><br><span class="line">  .weight=<span class="number">10</span>      </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>其中的.name类似于数组的下标，寻址自然与数组类似。  </p>
<hr>
<ul>
<li><strong>关于结构数组的声明</strong>  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[20];</span></span><br><span class="line">library[<span class="number">2</span>].name=<span class="string">"高等数学"</span>;  <span class="comment">//代表library的第三个元素的那么成员</span></span><br></pre></td></tr></table></figure>
<p>此时，[2]是library的下标，应当注意区别：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">2</span>].name;</span><br><span class="line">library.name[<span class="number">2</span>];</span><br></pre></td></tr></table></figure></p>
<p>后者指的是library的第一个成员的name的第三个字符。  </p>
<hr>
<ul>
<li><strong>关于嵌套结构</strong>  </li>
</ul>
<p>有时候我们会在一个结构中嵌套另一个结构例如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span> </span><br><span class="line">  <span class="keyword">char</span> firstname[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">char</span> lastname[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">dyf</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只需在外层结构中声明即可，同理，使用两次点运算符进行访问：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.dyf.name=<span class="string">"dyf"</span>;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong>指向结构的指针</strong><br>我们可以通过指针来传递并访问结构，这种操作非常舒服。  </li>
<li>声明与初始化指针： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">dyf</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p</span>;</span>    <span class="comment">//定义一个只想person结构类型的指针p</span></span><br><span class="line"></span><br><span class="line">p = &amp;dyf;    <span class="comment">//将dyf的地址赋值给指针p</span></span><br></pre></td></tr></table></figure>
<p>p指针在被定义后只能指向person的结构类型，储存person结构的地址。<br>与数组不同的是，结构的名并不代表首个成员的地址，因此必须使用&amp;操作符。  </p>
<ul>
<li><strong>指向结构的指针</strong>  </li>
</ul>
<p>我们可以通过指针来传递并访问结构，这种操作非常舒服。  </p>
<ul>
<li>声明与初始化指针： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">dyf</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p</span>;</span>    <span class="comment">//定义一个指向person结构类型的指针p</span></span><br><span class="line">     </span><br><span class="line">p = &amp;dyf;    <span class="comment">//将dyf的地址赋值给指针p  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> * <span class="title">m</span>;</span></span><br><span class="line">m = &amp;library[<span class="number">2</span>];    <span class="comment">//同理，结构数组内的结构如图赋值</span></span><br></pre></td></tr></table></figure>
<p>p指针在被定义后只能指向person的结构类型，储存person结构的地址。<br>与数组不同的是，结构的名并不代表首个成员的地址，因此必须使用&amp;操作符。  </p>
<ul>
<li><p>使用指针访问成员：<br>此时我们可以引入一个新的运算符”-&gt;”。例如：  </p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m-&gt;name == library[<span class="number">2</span>].name;</span><br><span class="line"></span><br><span class="line">m == &amp;library[<span class="number">2</span>];  <span class="comment">//m存的地址即为library[2]的地址</span></span><br><span class="line">     </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,m-&gt;name);   <span class="comment">//打印library[2].name 即高等数学</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>m -&gt; value 此操作符意味着取m地址中存的结构的成员，即：  </p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m -&gt; value.name == (*m).name == library[<span class="number">2</span>].name;</span><br></pre></td></tr></table></figure>

 注意：`&apos; * &apos;` 的运算级大于` &apos; . &apos;`　使用时注意加()  
</code></pre><hr>
<ul>
<li><strong>向函数传递结构</strong>  </li>
</ul>
<p>只要结构具有单个值的数据类型，即：int及其相关类型、char、float、double、指针等，就可以把它作为一个参数传递给函数，如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> firstname[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">char</span> lastname[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">myname</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(struct person * p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outIbfo</span><span class="params">(struct person * p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">dyf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p</span>;</span></span><br><span class="line">  p = &amp;dyf;</span><br><span class="line">  getInfo(p);</span><br><span class="line">  outInfo(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(struct person * p)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your firstname\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;((*p).myname.firstname));        <span class="comment">//注意理解这里</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your last name\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;((p-&gt;myname).lastname));         <span class="comment">//注意理解这里</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your age\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(p-&gt;age));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your height\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(p-&gt;height));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outInfo</span><span class="params">(struct person * p)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nname\t);</span></span><br><span class="line"><span class="string">  printf("</span>%s %s\n<span class="string">",(p-&gt;myname).firstname,(p-&gt;myname).lastname);</span></span><br><span class="line"><span class="string">  printf("</span>age   %d\n<span class="string">",p-&gt;age);</span></span><br><span class="line"><span class="string">  printf("</span>height    %d\n<span class="string">",p-&gt;height);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上是利用指针来传递结构参数，应当深刻理解’-&gt;’的意义。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;dyf;    <span class="comment">//这仅仅是获得dyf变量的名而不是其地址  等价于(*dyf)</span></span><br></pre></td></tr></table></figure>
<p>但<code>scanf()</code>需要传递给地址，因此我们需要使用&amp;操作符。如果你理解了以上两种寻址方式，那么你对-&gt;的理解算是合格了。但距离用结构和指针实现面向对象还有一定距离。顺便说一句，我们通常用结构和指针实现队列的数据结构，好好理解指针吧。  </p>
<p>当然除了以上这种用指针传递参数的方式，我们还可以直接用结构的名传递参数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yourmark</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> English;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mark</span><span class="params">(struct yourmark mark )</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mark.math + mark.English;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种传参方式很自然也很好理解，但是这毕竟只是赋值给形参，因此如果想改变元数据，我们依旧要使用指针。  </p>
<p>  如果要返回struct则：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yourmark</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> English;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct yourmark <span class="title">getmark</span><span class="params">(struct yourmark mark)</span></span>&#123;      <span class="comment">// 此处的返回类型为yourmark结构类型</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your math mark and English mark\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;(mark.math),&amp;(mark.English));</span><br><span class="line">  <span class="keyword">return</span> mark</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct yourmark mark;</span><br><span class="line">mark = getmark(mark);   <span class="comment">// 注意，给结构赋值时直接用其名而不是其地址</span></span><br></pre></td></tr></table></figure></p>
<p>  同理，要返回指针只需要<code>struct yourmark * mark getmark(struct yourmark mark)</code></p>
<p>好了到这里，把结构在函数里传来传去已经差不多说完了。  </p>
<hr>
<ul>
<li><strong>复合文字和结构</strong> </li>
</ul>
<p>C99引入了一些新的概念，比如变长数组(VLA)、复合文字(compound literal)、指针的兼容性等。  </p>
<p>  复合文字的意思：<br>  假如我要给函数传递参数，我可以传递一个变量也可以传递一个常量，例如：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>;</span><br><span class="line">sum(a,b)==sum(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>  但是对于数组或者结构来讲我们之前没有说过常量这个概念，在传递参数时或者向另一结构传递时可能要定义新的变量，很浪费内存。此时，便引入了复合文字这一概念。<br>  声明如下：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">guy</span>;</span>     <span class="comment">//定义一个person结构类型的结构</span></span><br><span class="line"></span><br><span class="line">guy = (struct person)&#123;<span class="string">"dyf"</span>,<span class="number">18</span>&#125;;   <span class="comment">//把复合文字赋值给guy  </span></span><br><span class="line"></span><br><span class="line">outInfo((struct person)&#123;<span class="string">"麂皮"</span>，<span class="number">18</span>&#125;)；  <span class="comment">//将一个匿名结构作为实参传递给函数  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class23</span> &#123;</span></span><br><span class="line">  (struct person)&#123;<span class="string">"dyf"</span>,<span class="number">18</span>&#125;;</span><br><span class="line">  (struct person)&#123;<span class="string">"麂皮"</span>，<span class="number">18</span>&#125;;</span><br><span class="line">&#125;;                                    <span class="comment">//将两个匿名结构传递给class23</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mark</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> English;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(struct mark * p)</span></span>;       <span class="comment">//声明一个参数为mark结构的指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,mark(&amp;(struct mark )&#123;<span class="number">150</span>，<span class="number">150</span>&#125;))；   <span class="comment">//传递复合文字的地址</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(struct mark * p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p-&gt;math + p-&gt;English；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注：用G++编译会报错，因为其地址是temporary 而C99版本的GCC是可行的,因为临时具有自动储存时期，而在函数外具有静态储存时期 */</span></span><br></pre></td></tr></table></figure></p>
<p>这是复合文字的大概用法，他能够创建一个匿名常量对象，直接在结构体或者函数中传递的常量。  </p>
<hr>
<ul>
<li><strong>伸缩性数组成员</strong>  </li>
</ul>
<p>C99加入了一个成为伸缩性数组成员(flexible array member)的新特性,该特性允许结构的最后一个成员是一个具有特殊属性的数组结构，<br>该数组的属性之一就是他并不立即存在。创建规则如下：  </p>
<ol>
<li>伸缩性数组成员必须是最后一个成员  </li>
<li>结构中至少有一个其他成员  </li>
<li>像普通数组那样声明，只是长度不定，例：<code>int a[];</code>  </li>
</ol>
<p>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mark</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> average;</span><br><span class="line">  <span class="keyword">char</span> subjects[]   <span class="comment">//伸缩数组成员</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p>
<p>此时subjects[]并未被创建，系统没有为他分配足够的内存空间。通常我们要使用伸缩数组时，都会为其先分配足够的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mark</span> * <span class="title">p</span>;</span></span><br><span class="line">p=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct mark) + <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure>
<p>这时我们已经有足够的内存来存放一个mark型结构，并且他可以存放一个19个字符的字符串。没错，开辟的内存空间要能存放结构本身和所需大小的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flex</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">char</span> * name;</span><br><span class="line">        <span class="keyword">char</span> * favobook[<span class="number">20</span>];    <span class="comment">//思考一下，他在main()中能直接赋值吗</span></span><br><span class="line">        <span class="keyword">int</span> favonumber[];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">p</span>;</span></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flex)+<span class="number">6</span>* <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    p-&gt;age=<span class="number">18</span>;</span><br><span class="line">    p-&gt;favonumber[<span class="number">7</span>]=<span class="number">1</span>;</span><br><span class="line">    p-&gt;name=<span class="string">"dyf"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s \t %d \t %d"</span>,p-&gt;name,p-&gt;age,p-&gt;favonumber[<span class="number">7</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们声明里一个指针name，要注意在C语言中，字符串以数组的形式存储，也就是说其变量名实际是个地址，在我们对其进行声明时计算机已经为他在内存中开辟了空间，所以其地址实际上是个常量，即name是个常量。假如我要进行<code>name=&quot;dyf&quot;;</code>操作，编译器将报错。<code>&quot;dyf&quot;</code>的地址很明显与<code>name</code>本身冲突，故不能直接赋值。<br>这里我们看到favonumber能存8个整数，我也不知道为什么，回去查查资料再来修改。</p>
<hr>
<ul>
<li><strong>将结构存到文件中</strong>  </li>
</ul>
<p>结构的整套信息我们称之为记录(record),单个的项目称之为字段(field)，下面，我们来进行讨论。<br>第一种方法，也是最笨拙的方法，使用<code>fprinf()</code>函数，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> title[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> author[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">math</span>;</span></span><br><span class="line"><span class="built_in">fprintf</span>(books, <span class="string">"%9s %9s %7.2d"</span>,math.title,math.author,math.value);</span><br></pre></td></tr></table></figure>
<p>我们使用<code>%9s</code>来固定输入格式，以便于下一次读取,这里的books是文件流。</p>
<p>第二种方法，我们可以使用fread()和fwrite()以结构大小为单位来进行读写，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(&amp;math,<span class="keyword">sizeof</span>(struct book),<span class="number">1</span>,books)</span><br></pre></td></tr></table></figure></p>
<p>这时我们将定位到math的地址<code>sizeof(struct book)</code>将返回一块book结构的大小，<code>&#39;1&#39;</code>则告诉函数只需复制一块结构，最后将整个record写入<code>books</code>相关联的文件。同样<code>fread()</code>将record写入<code>&amp;math</code>地址。  </p>
<hr>
<ul>
<li><strong>衍生出的其他数据类型</strong></li>
</ul>
<p>通过对结构体进行封装，C中还有联合又称为共用体(union)、枚举(enumerated type)两种类型。首先，union声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> id&#123;</span><br><span class="line">    <span class="keyword">char</span> id_string[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> id_int;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>假如一个物体的id有可能是整数，也有可能是字符串，那么我们可以用以上操作。<br>union并不是复合结构,这其中的声明的类型只能同时存在一种，也就是说id可以是字符串类型，也可以是int类型。<br>因此，我们可以声明一个union数组来存放不同类型的数据，这样就实现了混合数据类型存储。这种数据类型封装的方法与结构相同，同样支持<code>. -&gt;</code>等运算符，但是其意义却完全不同。<br>其次，枚举类型声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> subjects &#123;math=,English=<span class="number">2</span>,Chinese,CS&#125;;</span><br><span class="line"><span class="keyword">enum</span> subjects my_favo_subject;</span><br><span class="line"><span class="keyword">for</span>(my_favo_subject=math;my_favo_subject&lt;=CS;my_favo_subject++)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,my_favo_subject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通常用枚举创建符号常量，例如，<br><code>math，CS</code>是枚举常量，默认为int类型，math是枚举对象的首元素，其默认值为0，这就好比数组的下标，方便我们进行枚举。我们也可以给枚举常量一个指定值，例如上面<code>English=2</code>，那么，其后面的元素依次从2递增。由于枚举类型是一个整数类型，所以我们常将其用于表达式当中，方便进行逻辑判断或者运算。<br><strong>注：</strong><br>C语言支持枚举变量自增，即<code>my_favo_subject++;</code>但是C++不支持，注意代码兼容性。</p>
<hr>
<ul>
<li><strong>用结构实现链表</strong>  </li>
</ul>
<p>dyf is cool.</p>
<hr>
<ul>
<li><strong>用结构实现面向对象</strong>  </li>
</ul>

      
    
    </div>
    
      

      
  <hr class="copy-line">
  <div class="post-copyright">
    <div class="copy-author">
      <span>Author :</span>
      <span>dyf</span>
    </div>
    <div class="copy-url">
      <span>Url :</span>
      <a href="http://blog.dyf.ink/2018/12/02/对C结构的理解/">http://blog.dyf.ink/2018/12/02/对C结构的理解/</a>
    </div>
    <div class="copy-origin">
      <span>Origin :</span>
      <a href="http://blog.dyf.ink">http://blog.dyf.ink</a>
    </div>
    <div class="copy-license">
      
      著作权归作者所有，转载请联系作者获得授权。
    </div>
  </div>

    
  </article>
  
    
  <nav class="article-page">
    
      <a href="/2018/12/12/laravel-with-kali/" id="art-left" class="art-left">
        <span class="next-title">
          <i class="iconfont icon-left"></i>Laravel with kali
        </span>
      </a>
    
    
      <a href="/2018/12/02/对装饰器的理解/" id="art-right" class="art-right">
        <span class="prev-title"> 
          对装饰器的理解<i class="iconfont icon-right"></i>  
        </span>
      </a>
    
  </nav>

    
  <i id="com-switch" class="iconfont icon-more jumping-in long infinite" style="font-size:24px;display:block;text-align:center;transform:rotate(180deg);"></i>
  <div class="post-comments" id="post-comments" style="display: block;margin: auto 16px;">
    
    
    

    

  </div>



  
  
    
  

  <aside class="post-toc">
    <span class="title" id="toc-switch"><span>Index</span></span>
    <div class="toc-inner syuanpi back-1" style="display:none;">
      <li class="title-link"><a href="javascript:;" class="toTop">对C结构的理解</a></li>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#记录一下学习C结构的想法"><span class="toc-text">记录一下学习C结构的想法</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。"><span class="toc-text">即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。  </span></a>
    </li></div>
  </aside>



  


        </div>
      </main>

      <footer class="footer syuanpi fadeIn" id="footer">
  <hr>
  <div class="footer-wrapper">
    <div class="left">
      <div class="contact-icon">
    
    
    
    
    
    
    
    
    
        
        
        
        
        
            <a href="https://www.facebook.com/dong.yifan.1" class="iconfont icon-social-facebook" title="facebook"></a>
        
        
        
        
    
        
        
        
            <a href="https://twitter.com/dong_yifan" class="iconfont icon-social-twitter" title="twitter"></a>
        
        
        
        
        
        
    
        
        
        
        
            <a href="https://www.zhihu.com/people/aurora-56-20/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
        
        
        
        
    
        
            <a href="https://github.com/Explainaur" class="iconfont icon-social-github" title="github"></a>
        
        
        
        
        
        
        
        
    
</div>

    </div>
    <div class="right">
      <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2016 ~ 2020</span>
        <span>❤</span>
        <span>dyf</span>
    </div>
    <div class="theme">
        <span>
            Powered by
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            Theme
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
</div>

    </div>
  </div>
</footer>
    </div>
  </div>
  <script src="/script/lib/jquery/jquery-3.2.1.min.js"></script>


  <script src="/script/lib/lightbox/js/lightbox.min.js"></script>








<script src="/script/src/nlvi.js"></script>

  <script src="/script/scheme/banderole.js"></script>

<script src="/script/bootstarp.js"></script>


<div class="backtop syuanpi melt toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>


  <div class="search" id="search">
    <div class="mask" id="mask"></div>
    <div class="search-wrapper syuanpi">
      <h2 id="search-header" class="syuanpi">Search？</h2>
      <div class="input">
        <input type="text" id="local-search-input" results="0" name>
      </div>
      <div id="local-search-result"></div>
    </div>
  </div>


</body>
</html>
